BlendingService.java
---------------------
package com.gaudi.ai.service;

import org.springframework.http.ResponseEntity;

import com.gaudi.ai.request.BlendingDiscardImageRequest;
import com.gaudi.ai.request.BlendingGenerateRequest;
import com.gaudi.ai.request.BlendingMaskRequest;
import com.gaudi.ai.request.BlendingSourceRequest;
import com.gaudi.ai.request.BlendingTargetMaskRequest;
import com.gaudi.ai.request.BlendingTargetRequest;
import com.gaudi.ai.request.DeleteImageRequest;
import com.gaudi.ai.request.GaudiAINasRequest;
import com.gaudi.ai.request.GaudiAINasUpdateRequest;

public interface BlendingService {

	ResponseEntity<?> configureNAS(GaudiAINasRequest gaudiAINasRequest);

	ResponseEntity<?> getListOfConfiguredNAS(Long createdBy);

	ResponseEntity<?> updateNASConfiguration(GaudiAINasUpdateRequest gaudiAINasUpdateRequest);

	ResponseEntity<?> deleteNASConfiguration(Long nasID);

	ResponseEntity<?> saveSource(BlendingSourceRequest blendingSourceRequest);

	ResponseEntity<?> saveMask(BlendingMaskRequest blendingMaskRequest);

	ResponseEntity<?> saveTarget(BlendingTargetRequest blendingTargetRequest);

	ResponseEntity<?> saveTargetMask(BlendingTargetMaskRequest blendingTargetMaskRequest);

	ResponseEntity<?> saveGenerateJson(BlendingGenerateRequest blendingGenerateRequest);

	ResponseEntity<?> getLogProcessStatus(String smartID);

	ResponseEntity<?> terminateBlending(String smartID);

	ResponseEntity<?> getSourceData(Long sourceID);

	ResponseEntity<?> getMaskData(Long maskID);

	ResponseEntity<?> getTargetData(Long targetID);

	ResponseEntity<?> getTargetMaskData(Long targetMaskID);

	ResponseEntity<?> getGenerateData(Long generateID);

	ResponseEntity<?> getParticularVersion(Long versionID);

	ResponseEntity<?> updateSourceData(BlendingSourceRequest gaudiAISourceUpdateRequest);

	ResponseEntity<?> updateMaskData(BlendingMaskRequest gaudiAIMaskUpdateRequest);

	ResponseEntity<?> updateTargetData(BlendingTargetRequest gaudiAITargetUpdateRequest);

	ResponseEntity<?> updateTargetMaskData(BlendingTargetMaskRequest gaudiAITargetMaskUpdateRequest);

	ResponseEntity<?> updateGenerateData(BlendingGenerateRequest gaudiAIGenerateUpdateRequest);

	ResponseEntity<?> deleteBlendingImage(DeleteImageRequest deleteBlendingImageRequest);

	ResponseEntity<?> discardTheBlendingImage(BlendingDiscardImageRequest blendingDiscardImageRequest);

	ResponseEntity<?> getListOfChannels(Long versionID, String tabName);

	ResponseEntity<?> checkTheBlendingImageCountBasis(BlendingDiscardImageRequest blendingDiscardImageRequest);

	ResponseEntity<?> deleteBlendingImages(DeleteImageRequest deleteBlendingImageRequest);

}
---------------------------------------------------------------------------------------------------------------
BlendingServiceImpl.java
-------------------------
package com.gaudi.ai.service;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale.LanguageRange;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.HttpClientErrorException.UnprocessableEntity;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientException;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.server.ServerErrorException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.constants.PythonServiceEndPointConstant;
import com.gaudi.ai.exception.AppError;
import com.gaudi.ai.exception.BadRequestException;
import com.gaudi.ai.exception.ServiceUnavailableException;
import com.gaudi.ai.model.GaudiAIBlendingGenerate;
import com.gaudi.ai.model.GaudiAIBlendingMask;
import com.gaudi.ai.model.GaudiAIBlendingSource;
import com.gaudi.ai.model.GaudiAIBlendingTarget;
import com.gaudi.ai.model.GaudiAIBlendingTargetMask;
import com.gaudi.ai.model.GaudiAINas;
import com.gaudi.ai.model.GaudiAIProjects;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.GaudiAIBlendingGenerateRepository;
import com.gaudi.ai.repository.GaudiAIBlendingMaskRepository;
import com.gaudi.ai.repository.GaudiAIBlendingSourceRepository;
import com.gaudi.ai.repository.GaudiAIBlendingTargetMaskRepository;
import com.gaudi.ai.repository.GaudiAIBlendingTargetRepository;
import com.gaudi.ai.repository.GaudiAINasRepository;
import com.gaudi.ai.repository.GaudiAIProjectsRepository;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import com.gaudi.ai.request.BlendingDiscardImageRequest;
import com.gaudi.ai.request.BlendingGenerateRequest;
import com.gaudi.ai.request.BlendingMaskRequest;
import com.gaudi.ai.request.BlendingSourceRequest;
import com.gaudi.ai.request.BlendingTargetMaskRequest;
import com.gaudi.ai.request.BlendingTargetRequest;
import com.gaudi.ai.request.DeleteImageRequest;
import com.gaudi.ai.request.GaudiAINasRequest;
import com.gaudi.ai.request.GaudiAINasUpdateRequest;

import com.gaudi.ai.request.GenerateJsonReuest;
import com.gaudi.ai.request.PythonBlendingRequest;
import com.gaudi.ai.request.PythonSmartIDrequest;
import com.gaudi.ai.response.BlendingStreamLogs;
import com.gaudi.ai.response.BlendingTabImageCount;
import com.gaudi.ai.response.GaudiAIVersionData;
import com.gaudi.ai.response.GenerateTabResponse;
import com.gaudi.ai.response.HttpOperationResponseBean;
import com.gaudi.ai.response.MaskTabResponse;
import com.gaudi.ai.response.PythonSucessResponse;
import com.gaudi.ai.response.SourceTabResponse;
import com.gaudi.ai.response.TabResponseBean;
import com.gaudi.ai.response.TargetMaskTabResponse;
import com.gaudi.ai.response.TargetTabResponse;
import com.gaudi.ai.util.ApplicationUtil;
import com.google.gson.Gson;

@Service
public class BlendingServiceImpl implements BlendingService {

	private static final Logger LOG = LogManager.getLogger(BlendingServiceImpl.class);

	@Autowired
	private GaudiAINasRepository gaudiAINasRepository;

	@Autowired
	private GaudiAIVersionRepository gaudiAIVersionRepository;

	@Autowired
	private GaudiAIBlendingSourceRepository gaudiAIBlendingSourceRepository;

	@Autowired
	private GaudiAIBlendingMaskRepository gaudiAIBlendingMaskRepository;

	@Autowired
	private GaudiAIBlendingTargetMaskRepository gaudiAIBlendingTargetMaskRepository;

	@Autowired
	private GaudiAIBlendingTargetRepository gaudiAIBlendingTargetRepository;

	@Autowired
	private GaudiAIBlendingGenerateRepository gaudiAIBlendingGenerateRepository;
	
	@Autowired
	private GaudiAIProjectsRepository gaudiAIProjectsRepository;
	
	@Autowired
	private FilesStorageService filesStorageService;
	
	@Autowired
	private ApplicationUtil applicationUtil;
	
	@Autowired
	private MessageSource messageSource;
	
	@Autowired
	private WebClient webClient;

	@Value("#{'${gaudiServiceUrl}'}")
	String gaudiServiceUrl;

	@Override
	public ResponseEntity<?> configureNAS(GaudiAINasRequest gaudiAINasRequest) {
		HttpOperationResponseBean response = null;
		GaudiAINas savedGaudiAINas = null;

		try {
			GaudiAINas gaudiAINas = new GaudiAINas();
			gaudiAINas.setNasName(gaudiAINasRequest.getNasName());
			gaudiAINas.setNasUsername(gaudiAINasRequest.getNasUsername());
			gaudiAINas.setNasPassword(gaudiAINasRequest.getNasPassword());
			gaudiAINas.setPrefixPath(gaudiAINasRequest.getPrefixPath());
			gaudiAINas.setIsActive(ApplicationConstants.YES);
			gaudiAINas.setCreatedBy(gaudiAINasRequest.getCreatedBy());
			gaudiAINas.setCreatedDate(new Date(System.currentTimeMillis()));
			savedGaudiAINas = gaudiAINasRepository.save(gaudiAINas);
			if (savedGaudiAINas.getNasID() > 0) {
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("nas.configuration.created.successfully", null, LocaleContextHolder.getLocale()));
				LOG.info("NAS Configuration created successfully");
			} else {
				LOG.error("NAS Configuration Creatation Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("nas.configuration.creation.failure", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Exception - NAS Configuration.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.nas.configuration", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getListOfConfiguredNAS(Long createdBy) {
		try {
			List<GaudiAINas> listGaudiAINas = gaudiAINasRepository.findNasListByCreatedBy(createdBy);
			if (listGaudiAINas.isEmpty()) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("do.not.find.list.of.nas.for.userid", null, LocaleContextHolder.getLocale()) + createdBy, null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			return new ResponseEntity<>(listGaudiAINas, HttpStatus.OK);

		} catch (Exception e) {
			LOG.error("Error In Get List Of Configured NAS.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.get.list.of.configured.nas", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateNASConfiguration(GaudiAINasUpdateRequest gaudiAINasUpdateRequest) {
		Long nasID = gaudiAINasUpdateRequest.getNasID();
		HttpOperationResponseBean response = null;
		try {

			List<GaudiAINas> existGaudiAINas = gaudiAINasRepository.findByNasID(nasID);
			if (existGaudiAINas.isEmpty()) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,messageSource.getMessage("do.not.find.the.nas.configure.for.userid", null, LocaleContextHolder.getLocale()) + nasID, null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

			String nasName = gaudiAINasUpdateRequest.getNasName() != null
					&& !gaudiAINasUpdateRequest.getNasName().equalsIgnoreCase(ApplicationConstants.BLANK) ? gaudiAINasUpdateRequest.getNasName()
							: existGaudiAINas.get(0).getNasName();
			String nasUsername = gaudiAINasUpdateRequest.getNasUsername() != null
					&& !gaudiAINasUpdateRequest.getNasUsername().equalsIgnoreCase(ApplicationConstants.BLANK)
							? gaudiAINasUpdateRequest.getNasUsername()
							: existGaudiAINas.get(0).getNasUsername();
			String nasPassword = gaudiAINasUpdateRequest.getNasPassword() != null
					&& !gaudiAINasUpdateRequest.getNasPassword().equalsIgnoreCase(ApplicationConstants.BLANK)
							? gaudiAINasUpdateRequest.getNasPassword()
							: existGaudiAINas.get(0).getNasPassword();
			String nasPrefixPath = gaudiAINasUpdateRequest.getPrefixPath() != null
					&& !gaudiAINasUpdateRequest.getPrefixPath().equalsIgnoreCase(ApplicationConstants.BLANK)
							? gaudiAINasUpdateRequest.getPrefixPath()
							: existGaudiAINas.get(0).getPrefixPath();
			gaudiAINasRepository.updateNASConfigure(nasID, nasName, nasUsername, nasPassword, nasPrefixPath,
					new Date(System.currentTimeMillis()));
			response = new HttpOperationResponseBean();
			response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			response.setStatus(HttpStatus.OK);
			response.setMessage(messageSource.getMessage("the.nas.configure.updated.successfully", null, LocaleContextHolder.getLocale()));
			LOG.info("The NAS Configure Updated successfully.");
		} catch (Exception e) {
			LOG.error("Error In The NAS Configure For UserID - {}",nasID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.updating.list.of.configured.nas", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> deleteNASConfiguration(Long nasID) {
		HttpOperationResponseBean response = null;
		try {
			List<GaudiAINas> existGaudiAINas = gaudiAINasRepository.findByNasID(nasID);
			if (existGaudiAINas.isEmpty()) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("do.not.find.the.nas.configure.for.userid" , null,LocaleContextHolder.getLocale()) + nasID, null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			gaudiAINasRepository.deleteById(nasID);
			response = new HttpOperationResponseBean();
			response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			response.setStatus(HttpStatus.OK);
			response.setMessage(messageSource.getMessage("the.nas.configure.deleted.successfully", null, LocaleContextHolder.getLocale()));
			LOG.info("The NAS Configure Deleted successfully.");
		} catch (Exception e) {
			LOG.error("Error In The NAS Configure Deletation For UserID - {}",nasID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.deletation.the.configured.nasid", null, LocaleContextHolder.getLocale()) + nasID, null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> saveSource(BlendingSourceRequest blendingSourceRequest) {
		TabResponseBean response = null;
		GaudiAIBlendingSource savedGaudiAIBlendingSource = null;
		try {
			GaudiAIBlendingSource gaudiAIBlendingSource = new GaudiAIBlendingSource();
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(blendingSourceRequest.getGaudiVersionID());
			gaudiAIBlendingSource.setGaudiVersionID(blendingSourceRequest.getGaudiVersionID());
			gaudiAIBlendingSource.setImageUploadType(blendingSourceRequest.getImageUploadType());
			gaudiAIBlendingSource.setExternalNASPath(blendingSourceRequest.getExternalNASPath());
			gaudiAIBlendingSource.setNasID(blendingSourceRequest.getNasID());
			gaudiAIBlendingSource.setInternalSourcePath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.SOURCE + File.separator);
			String selectedSourceImageName = new ObjectMapper()
					.writeValueAsString(blendingSourceRequest.getSelectedSourceImageName());
			gaudiAIBlendingSource.setSelectedSourceImageName(selectedSourceImageName);
			gaudiAIBlendingSource.setSelectedSourceImageCount(blendingSourceRequest.getSelectedSourceImageCount());
			gaudiAIBlendingSource.setIsActive(ApplicationConstants.ACTIVE);
			gaudiAIBlendingSource.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIBlendingSource.setCreatedBy(blendingSourceRequest.getCreatedBy());
			savedGaudiAIBlendingSource = gaudiAIBlendingSourceRepository.save(gaudiAIBlendingSource);
			if (savedGaudiAIBlendingSource.getBlendingSourceID() > 0) {
				updateActiveSteps(gaudiAIVersion.get(0), 1);
				response = new TabResponseBean();
				response.setId(savedGaudiAIBlendingSource.getBlendingSourceID());
				response.setTabName(ApplicationConstants.SOURCE);
				response.setVersionID(blendingSourceRequest.getGaudiVersionID());
				response.setMessage(messageSource.getMessage("source.data.saved.successfully", null, LocaleContextHolder.getLocale()));
			} else {
				LOG.info("Source Data Saved Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("source.data.saved.failure", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {

			LOG.error("Error In Save Source");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.source", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> saveMask(BlendingMaskRequest blendingMaskRequest) {
		TabResponseBean response = null;
		GaudiAIBlendingMask savedGaudiAIBlendingMask = null;
		try {
			GaudiAIBlendingMask gaudiAIBlendingMask = new GaudiAIBlendingMask();
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(blendingMaskRequest.getGaudiVersionID());
			gaudiAIBlendingMask.setGaudiVersionID(blendingMaskRequest.getGaudiVersionID());
			gaudiAIBlendingMask.setMaskType(blendingMaskRequest.getMaskType());
			gaudiAIBlendingMask.setImageUploadType(blendingMaskRequest.getImageUploadType());
			gaudiAIBlendingMask.setExternalNASPath(blendingMaskRequest.getExternalNASPath());
			gaudiAIBlendingMask.setNasID(blendingMaskRequest.getNasID());
			gaudiAIBlendingMask.setInternalMaskPath(gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
					+ File.separator + ApplicationConstants.SOURCE_MASK + File.separator);
			String selectedMaskImageName = new ObjectMapper()
					.writeValueAsString(blendingMaskRequest.getSelectedMaskImageName());
			gaudiAIBlendingMask.setSelectedMaskImageName(selectedMaskImageName);
			gaudiAIBlendingMask.setSelectedMaskImageCount(blendingMaskRequest.getSelectedMaskImageCount());
			gaudiAIBlendingMask.setIsActive(ApplicationConstants.ACTIVE);
			gaudiAIBlendingMask.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIBlendingMask.setCreatedBy(blendingMaskRequest.getCreatedBy());
			savedGaudiAIBlendingMask = gaudiAIBlendingMaskRepository.save(gaudiAIBlendingMask);
			if (savedGaudiAIBlendingMask.getBlendingMaskID() > 0) {
				updateActiveSteps(gaudiAIVersion.get(0), 2);
				response = new TabResponseBean();
				response.setId(savedGaudiAIBlendingMask.getBlendingMaskID());
				response.setTabName(ApplicationConstants.SOURCE_MASK);
				response.setVersionID(blendingMaskRequest.getGaudiVersionID());
				response.setMessage(messageSource.getMessage("mask.data.saved.successfully", null, LocaleContextHolder.getLocale()));
			} else {
				LOG.error("Mask Data Saved Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("mask.data.saved.failure", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {

			LOG.error("Error In Save Mask");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.mask", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> saveTarget(BlendingTargetRequest blendingTargetRequest) {
		TabResponseBean response = null;
		GaudiAIBlendingTarget savedGaudiAIBlendingTarget = null;
		try {
			GaudiAIBlendingTarget gaudiAIBlendingTarget = new GaudiAIBlendingTarget();
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(blendingTargetRequest.getGaudiVersionID());
			gaudiAIBlendingTarget.setGaudiVersionID(blendingTargetRequest.getGaudiVersionID());
			gaudiAIBlendingTarget.setImageUploadType(blendingTargetRequest.getImageUploadType());
			gaudiAIBlendingTarget.setExternalNASPath(blendingTargetRequest.getExternalNASPath());
			gaudiAIBlendingTarget.setNasID(blendingTargetRequest.getNasID());
			gaudiAIBlendingTarget.setInternalTargetPath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.TARGET + File.separator);
			String selectedTargetImageName = new ObjectMapper()
					.writeValueAsString(blendingTargetRequest.getSelectedTargetImageName());
			gaudiAIBlendingTarget.setSelectedTargetImageName(selectedTargetImageName);
			gaudiAIBlendingTarget.setSelectedTargetImageCount(blendingTargetRequest.getSelectedTargetImageCount());
			gaudiAIBlendingTarget.setIsActive(ApplicationConstants.ACTIVE);
			gaudiAIBlendingTarget.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIBlendingTarget.setCreatedBy(blendingTargetRequest.getCreatedBy());
			savedGaudiAIBlendingTarget = gaudiAIBlendingTargetRepository.save(gaudiAIBlendingTarget);
			if (savedGaudiAIBlendingTarget.getBlendingTargetID() > 0) {
				updateActiveSteps(gaudiAIVersion.get(0), 3);
				response = new TabResponseBean();
				response.setId(savedGaudiAIBlendingTarget.getBlendingTargetID());
				response.setTabName(ApplicationConstants.TARGET);
				response.setVersionID(blendingTargetRequest.getGaudiVersionID());
				response.setMessage( messageSource.getMessage("targe.data.saved.successfully", null, LocaleContextHolder.getLocale()));
			} else {
				LOG.info("Target Data Saved Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("target.data.saved.failure", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {

			LOG.error("Error In Save Target");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,messageSource.getMessage("error.in.save.target", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> saveTargetMask(BlendingTargetMaskRequest blendingTargetMaskRequest) {
		TabResponseBean response = null;
		GaudiAIBlendingTargetMask savedGaudiAIBlendingTargetMask = null;
		try {
			GaudiAIBlendingTargetMask gaudiAIBlendingTargetMask = new GaudiAIBlendingTargetMask();
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(blendingTargetMaskRequest.getGaudiVersionID());
			gaudiAIBlendingTargetMask.setGaudiVersionID(blendingTargetMaskRequest.getGaudiVersionID());
			gaudiAIBlendingTargetMask.setTargetMaskType(blendingTargetMaskRequest.getTargetMaskType());
			gaudiAIBlendingTargetMask.setImageUploadType(blendingTargetMaskRequest.getImageUploadType());
			gaudiAIBlendingTargetMask.setExternalNASPath(blendingTargetMaskRequest.getExternalNASPath());
			gaudiAIBlendingTargetMask.setNasID(blendingTargetMaskRequest.getNasID());
			gaudiAIBlendingTargetMask.setInternalTargetMaskPath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ApplicationConstants.IMAGE + File.separator + ApplicationConstants.TARGET_MASK + File.separator);
			String selectedTargetMaskImageName = new ObjectMapper()
					.writeValueAsString(blendingTargetMaskRequest.getSelectedTargetMaskImageName());
			gaudiAIBlendingTargetMask.setSelectedTargetMaskImageName(selectedTargetMaskImageName);
			gaudiAIBlendingTargetMask
					.setSelectedTargetMaskImageCount(blendingTargetMaskRequest.getSelectedTargetMaskImageCount());
			gaudiAIBlendingTargetMask.setIsActive(ApplicationConstants.ACTIVE);
			gaudiAIBlendingTargetMask.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIBlendingTargetMask.setCreatedBy(blendingTargetMaskRequest.getCreatedBy());
			savedGaudiAIBlendingTargetMask = gaudiAIBlendingTargetMaskRepository.save(gaudiAIBlendingTargetMask);
			if (savedGaudiAIBlendingTargetMask.getBlendingTargetMaskID() > 0) {
				updateActiveSteps(gaudiAIVersion.get(0), 4);
				response = new TabResponseBean();
				response.setId(savedGaudiAIBlendingTargetMask.getBlendingTargetMaskID());
				response.setTabName(ApplicationConstants.TARGET_MASK);
				response.setVersionID(blendingTargetMaskRequest.getGaudiVersionID());
				response.setMessage(messageSource.getMessage("targetmask.data.saved.successfully", null, LocaleContextHolder.getLocale()));
			} else {
				LOG.error("Target Mask Data Saved Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("target.mask.data.saved.failure", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Save Target Mask");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.target.mask", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	private boolean validateRange(List<Float> floatValues) {
		for (Float floatValue : floatValues) {
			if (floatValue < 0.1f || floatValue > 2.0f) {
				return true;
			}
		}
		return false;
	}
	@Override
	public ResponseEntity<?> saveGenerateJson(BlendingGenerateRequest blendingGenerateRequest) {
		LOG.info("----------blendingGenerateRequest-------------{} ", blendingGenerateRequest);
		GaudiAIBlendingGenerate savedGaudiAIBlendingGenerate = null;

		PythonSucessResponse pythonSucessResponse = null;
		try {
			GaudiAIVersion gaudiAIVersion = gaudiAIVersionRepository.getReferenceById(blendingGenerateRequest.getGaudiVersionID());
			Long projectID = gaudiAIVersion.getProjectID();
			GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.getReferenceById(projectID);
			BlendingDiscardImageRequest blendingDiscardImageRequest1=new BlendingDiscardImageRequest();
			blendingDiscardImageRequest1.setNoOfChannels( gaudiAIProjects.getNoOfChannel());
			blendingDiscardImageRequest1.setTabName(ApplicationConstants.SOURCE);
			blendingDiscardImageRequest1.setVersionID(blendingGenerateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis1 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest1);
			HttpOperationResponseBean body = (HttpOperationResponseBean) imageCountBasis1.getBody();
			if (body.getMessage().equalsIgnoreCase(messageSource.getMessage("please.upload.atleast.one.image",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("please upload atleast one image in source tab.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("please.upload.atleast.one.image.in.source.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			if (body.getMessage().equalsIgnoreCase(messageSource.getMessage("please.make.images.equal.in.all.channel", null,
								LocaleContextHolder.getLocale()))) {
				LOG.error("Blending Source Tab Is Mandatory To Fill.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("image.count.mismatch.across.channels.in.source.tab", null,
								LocaleContextHolder.getLocale()) , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			BlendingDiscardImageRequest blendingDiscardImageRequest2=new BlendingDiscardImageRequest();
			blendingDiscardImageRequest2.setNoOfChannels( 0L);
			blendingDiscardImageRequest2.setTabName(ApplicationConstants.SOURCE_MASK);
			blendingDiscardImageRequest2.setVersionID(blendingGenerateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis2 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest2);
			HttpOperationResponseBean body2 = (HttpOperationResponseBean) imageCountBasis2.getBody();
			if (body2.getMessage().equals(messageSource.getMessage("please.upload.atleast.one.image", null,
								LocaleContextHolder.getLocale()))) {
				LOG.error("Blending Mask Tab Is Mandatory To Fill.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("please.upload.atleast.one.image", null,
								LocaleContextHolder.getLocale()) , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			BlendingDiscardImageRequest blendingDiscardImageRequest3=new BlendingDiscardImageRequest();
			blendingDiscardImageRequest3.setNoOfChannels( gaudiAIProjects.getNoOfChannel());
			blendingDiscardImageRequest3.setTabName(ApplicationConstants.TARGET);
			blendingDiscardImageRequest3.setVersionID(blendingGenerateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis3 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest3);
			HttpOperationResponseBean body3 = (HttpOperationResponseBean) imageCountBasis3.getBody();
			if (body3.getMessage().equalsIgnoreCase(messageSource.getMessage("please.upload.atleast.one.image",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("please upload atleast one image in target tab.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("please.upload.atleast.one.image.in.target.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			 if (body3.getMessage().equalsIgnoreCase(messageSource.getMessage("please.make.images.equal.in.all.channel", null,
						LocaleContextHolder.getLocale()))) {
				LOG.error("Blending Target Is Mandatory To Fill.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,messageSource.getMessage("image.count.mismatch.across.channels.in.target.tab", null,
								LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

			GaudiAIBlendingGenerate gaudiAIBlendingGenerate = new GaudiAIBlendingGenerate();
			gaudiAIBlendingGenerate.setGaudiVersionID(blendingGenerateRequest.getGaudiVersionID());
			gaudiAIBlendingGenerate.setSaveDefectMask(blendingGenerateRequest.getSaveDefectMask());
			List<Float> defectXScale2 = blendingGenerateRequest.getDefectXScale();
				if(validateRange(defectXScale2)) {
					LOG.error("DefectXScale value must be between 0.1f and 2.0f");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, messageSource.getMessage("defect.x.scale.value.must.be.between.0.1f.and.2.0f", null,
									LocaleContextHolder.getLocale()) , null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			
		    List<Float> defectYScale2 = blendingGenerateRequest.getDefectYScale();
				if(validateRange(defectYScale2)) {
					LOG.error("DefectYScale value must be between 0.1f and 2.0f");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, messageSource.getMessage("defect.y.scale.value.must.be.between.0.1f.and.2.0f", null,
									LocaleContextHolder.getLocale()) , null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			String defectXScale = new ObjectMapper().writeValueAsString(blendingGenerateRequest.getDefectXScale());
			String defectYScale = new ObjectMapper().writeValueAsString(blendingGenerateRequest.getDefectYScale());
			gaudiAIBlendingGenerate.setDefectXScale(defectXScale);
			gaudiAIBlendingGenerate.setDefectYScale(defectYScale);
			gaudiAIBlendingGenerate.setDefectRandomScale(blendingGenerateRequest.getDefectRandomScale());
			gaudiAIBlendingGenerate.setImageCount(blendingGenerateRequest.getImageCount());
			gaudiAIBlendingGenerate.setAlgorithm(blendingGenerateRequest.getAlgorithm());
			gaudiAIBlendingGenerate.setIteration(blendingGenerateRequest.getIteration());
			gaudiAIBlendingGenerate.setGradWeight(blendingGenerateRequest.getGradWeight());
			gaudiAIBlendingGenerate.setStyleWeight(blendingGenerateRequest.getStyleWeight());
			gaudiAIBlendingGenerate.setSeed(blendingGenerateRequest.getSeed());
			gaudiAIBlendingGenerate.setIsActive(ApplicationConstants.ACTIVE);
			gaudiAIBlendingGenerate.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIBlendingGenerate.setCreatedBy(blendingGenerateRequest.getCreatedBy());
			gaudiAIBlendingGenerate.setRotation(blendingGenerateRequest.getRotation());
			gaudiAIBlendingGenerate.setDegreeOfRotationMin(blendingGenerateRequest.getDegreeOfRotationMin());
			gaudiAIBlendingGenerate.setDegreeOfRotationMax(blendingGenerateRequest.getDegreeOfRotationMax());
			savedGaudiAIBlendingGenerate = gaudiAIBlendingGenerateRepository.save(gaudiAIBlendingGenerate);

			if (savedGaudiAIBlendingGenerate.getBlendingGenerateID() > 0) {
				pythonSucessResponse = blendingProcess(savedGaudiAIBlendingGenerate);

			}
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
		} catch (WebClientResponseException | WebClientRequestException  e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE,
					messageSource.getMessage("server.is.down.please.try.after.sometimes", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (ServerErrorException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (IOException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (Exception e) {
			LOG.error("Error In Save Generated Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.generated.json", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		
	}

	@Override
	public ResponseEntity<?> getLogProcessStatus(String versionSmartID) {
		BlendingStreamLogs blendingStreamLogs = null;
		try {
			PythonSmartIDrequest pythonSmartIDrequest = new PythonSmartIDrequest();
			pythonSmartIDrequest.setSmartId(versionSmartID);
			LOG.info("Calling Python backend API {}", pythonSmartIDrequest);
			List<LanguageRange> header= applicationUtil.getHeader();
			blendingStreamLogs = webClient.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.STREAMLOGS)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonSmartIDrequest)).retrieve().bodyToMono(BlendingStreamLogs.class)
					.block();
		} catch (WebClientException e) {

			LOG.error("Process Is Not Found For smartID - {}", versionSmartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("process.is.not.found.for.smartid", null, LocaleContextHolder.getLocale()) + versionSmartID, null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		} catch (ServerErrorException e) {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 503,
					ApplicationConstants.SERVICE_UNAVAILABLE,  messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()), null);
			LOG.error("Server Error Exception. Please try after sometimes.");
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (Exception e) {

			LOG.error("Error In Get Log Process Status For smartID - {}", versionSmartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.get.log.process.Status.for.smartid", null, LocaleContextHolder.getLocale())+ versionSmartID ,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(blendingStreamLogs, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> terminateBlending(String versionSmartID) {
		PythonSucessResponse pythonSucessResponse = null;
		try {
			PythonSmartIDrequest pythonSmartIDrequest = new PythonSmartIDrequest();
			pythonSmartIDrequest.setSmartId(versionSmartID);
			LOG.info("Calling Python backend API {}", pythonSmartIDrequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			pythonSucessResponse = webClient.post().uri(gaudiServiceUrl +PythonServiceEndPointConstant.STOP)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonSmartIDrequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();
		} catch (WebClientException e) {
			LOG.error("Web Client Exception In The Terminating Blending For smartID - {}",versionSmartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					 messageSource.getMessage("web.client.exception.in.the.terminating.blending.for.smartid", null, LocaleContextHolder.getLocale())+ versionSmartID , null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		} catch (ServerErrorException e) {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 503,
					ApplicationConstants.SERVICE_UNAVAILABLE, messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()), null);
			LOG.error("Server Error Exception. Please try after sometimes.");
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (Exception e) {
			LOG.error("Error In The Terminating Blending For smartID - {}", versionSmartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.the.terminating.blending.for.smartid", null, LocaleContextHolder.getLocale())+ versionSmartID , null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getSourceData(Long sourceID) {
		SourceTabResponse sourceTabResponse = null;
		try {
			List<GaudiAIBlendingSource> gaudiAIBlendingSource = gaudiAIBlendingSourceRepository
					.getSourceByBlendingSourceID(sourceID);
			if (!gaudiAIBlendingSource.isEmpty()) {
				sourceTabResponse = setSourceTabResponse(gaudiAIBlendingSource.get(0));
			} else {
				LOG.error("No Source Data Available For SourceID {} .", sourceID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("no.source.data.available.for.sourceid", null, LocaleContextHolder.getLocale())+ sourceID , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {
			LOG.error("Error  - Get Source Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error-get.source.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}

		return new ResponseEntity<>(sourceTabResponse, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getMaskData(Long maskID) {
		MaskTabResponse maskTabResponse = null;
		try {
			List<GaudiAIBlendingMask> gaudiAIBlendingMask = gaudiAIBlendingMaskRepository
					.getMaskByBlendingMaskID(maskID);
			if (!gaudiAIBlendingMask.isEmpty()) {
				maskTabResponse = setMaskTabResponse(gaudiAIBlendingMask.get(0));
			} else {

				LOG.error("No Mask Data Available For MaskID {} .", maskID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("no.mask.data.available.for.maskid", null, LocaleContextHolder.getLocale())+maskID , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {

			LOG.error("Error  - Get Mask Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error-get.mask.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(maskTabResponse, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getTargetData(Long targetID) {
		TargetTabResponse targetTabResponse = null;
		try {
			List<GaudiAIBlendingTarget> gaudiAIBlendingTarget = gaudiAIBlendingTargetRepository
					.getTargetByBlendingTarget(targetID);
			if (!gaudiAIBlendingTarget.isEmpty()) {
				targetTabResponse = setTargetTabResponse(gaudiAIBlendingTarget.get(0));
			} else {

				LOG.error("No Target Data Available For TargetID {} .", targetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,messageSource.getMessage("no.target.data.available.for.targetid", null, LocaleContextHolder.getLocale())+ targetID , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {

			LOG.error("Error  - Get Target Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error-get.target.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(targetTabResponse, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getTargetMaskData(Long targetMaskID) {
		TargetMaskTabResponse targetMaskTabResponse = null;
		try {
			List<GaudiAIBlendingTargetMask> gaudiAIBlendingTargetMask = gaudiAIBlendingTargetMaskRepository
					.getTargetMaskByBlendingTargetMaskID(targetMaskID);
			if (!gaudiAIBlendingTargetMask.isEmpty()) {
				targetMaskTabResponse = setTargetMaskTabResponse(gaudiAIBlendingTargetMask.get(0));

			} else {

				LOG.error("No Target Mask Data Available For TargetMaskID - {}", targetMaskID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("no.target.mask.data.available.for.targetMaskid", null, LocaleContextHolder.getLocale())+ targetMaskID , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {

			LOG.error("Error  - Get TargetMask Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,messageSource.getMessage("error-get.targetMask.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(targetMaskTabResponse, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getGenerateData(Long generateID) {
		GenerateTabResponse generateTabResponse = null;
		try {
			List<GaudiAIBlendingGenerate> gaudiAIBlendingGenerate = gaudiAIBlendingGenerateRepository
					.getGenerateByBlendingGenerateID(generateID);
			if (!gaudiAIBlendingGenerate.isEmpty()) {
				generateTabResponse = setGenerateTabResponse(gaudiAIBlendingGenerate.get(0));
			} else {

				LOG.error("No Generated Data Available For GenerateID - {}",generateID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("no.generated.data.available.for.generateid", null, LocaleContextHolder.getLocale()) + generateID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {

			LOG.error("Error  - Get Generate Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error-get.generate.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(generateTabResponse, HttpStatus.OK);

	}

	@Override
	public ResponseEntity<?> getParticularVersion(Long versionID) {
		GaudiAIVersionData gaudiAIVersionData = new GaudiAIVersionData();
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if (!gaudiAIVersion.isEmpty()) {
				gaudiAIVersionData = setGaudiAIVersionData(gaudiAIVersion.get(0));
				Long projectID=gaudiAIVersion.get(0).getProjectID();
				GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.getReferenceById(projectID);
				List<BlendingTabImageCount> sourceTabResponse = getTabCountDetails(gaudiAIProjects.getNoOfChannel(), versionID,
						ApplicationConstants.SOURCE);
				if (!sourceTabResponse.isEmpty()) {
					gaudiAIVersionData.setSourceTabResponse(sourceTabResponse);
				}
				List<BlendingTabImageCount> maskTabResponse = getTabCountDetails(0L, versionID,
						ApplicationConstants.SOURCE_MASK);
				if (!maskTabResponse.isEmpty()) {
					gaudiAIVersionData.setMaskTabResponse(maskTabResponse);
				}
				List<BlendingTabImageCount> targetTabResponse = getTabCountDetails(gaudiAIProjects.getNoOfChannel(), versionID,
						ApplicationConstants.TARGET);
				if (!targetTabResponse.isEmpty()) {
					gaudiAIVersionData.setTargetTabResponse(targetTabResponse);
				}
				List<BlendingTabImageCount> targetMaskTabResponse = getTabCountDetails(0L, versionID,
						ApplicationConstants.TARGET_MASK);
				if (!targetMaskTabResponse.isEmpty()) {
					
					
					gaudiAIVersionData.setTargetMaskTabResponse(targetMaskTabResponse);
				}
				/*
				 * List<GaudiAIBlendingSource> gaudiAIBlendingSource =
				 * gaudiAIBlendingSourceRepository .findByGaudiVersionID(versionID); if
				 * (!gaudiAIBlendingSource.isEmpty()) { SourceTabResponse sourceTabResponse =
				 * setSourceTabResponse(gaudiAIBlendingSource.get(0));
				 * gaudiAIVersionData.setSourceTabResponse(sourceTabResponse); } else {
				 * gaudiAIVersionData.setSourceTabResponse(null); } List<GaudiAIBlendingMask>
				 * gaudiAIBlendingMask = gaudiAIBlendingMaskRepository
				 * .findByGaudiVersionID(versionID); if (!gaudiAIBlendingMask.isEmpty()) {
				 * MaskTabResponse maskTabResponse =
				 * setMaskTabResponse(gaudiAIBlendingMask.get(0));
				 * 
				 * gaudiAIVersionData.setMaskTabResponse(maskTabResponse); } else {
				 * gaudiAIVersionData.setMaskTabResponse(null); } List<GaudiAIBlendingTarget>
				 * gaudiAIBlendingTarget = gaudiAIBlendingTargetRepository
				 * .findByGaudiVersionID(versionID); if (!gaudiAIBlendingTarget.isEmpty()) {
				 * TargetTabResponse targetTabResponse =
				 * setTargetTabResponse(gaudiAIBlendingTarget.get(0));
				 * 
				 * gaudiAIVersionData.setTargetTabResponse(targetTabResponse); }
				 * List<GaudiAIBlendingTargetMask> gaudiAIBlendingTargetMask =
				 * gaudiAIBlendingTargetMaskRepository .findByGaudiVersionID(versionID); if
				 * (!gaudiAIBlendingTargetMask.isEmpty()) { TargetMaskTabResponse
				 * targetMaskTabResponse = setTargetMaskTabResponse(
				 * gaudiAIBlendingTargetMask.get(0));
				 * 
				 * gaudiAIVersionData.setTargetMaskTabResponse(targetMaskTabResponse); }
				 */
				List<GaudiAIBlendingGenerate> listsavedGaudiAIBlendingGenerate = gaudiAIBlendingGenerateRepository
						.getGaudiAIBlendingGenerate(versionID);
				if (!listsavedGaudiAIBlendingGenerate.isEmpty()) {
					GenerateTabResponse generateTabResponse = setGenerateTabResponse(
							listsavedGaudiAIBlendingGenerate.get(0));

					gaudiAIVersionData.setGenerateTabResponse(generateTabResponse);
				}
			}
		} catch (Exception e) {
			LOG.info("Error in getParticularVersion versionID - {}",versionID);
		}
		return new ResponseEntity<>(gaudiAIVersionData, HttpStatus.OK);
	}

	public GaudiAIVersionData setGaudiAIVersionData(GaudiAIVersion gaudiAIVersion) {
		GaudiAIVersionData gaudiAIVersionData = new GaudiAIVersionData();
		gaudiAIVersionData.setVersionID(gaudiAIVersion.getVersionID());
		gaudiAIVersionData.setProjectID(gaudiAIVersion.getProjectID());
		gaudiAIVersionData.setVersionName(gaudiAIVersion.getVersionName());
		gaudiAIVersionData.setNotes(gaudiAIVersion.getNotes());

		Gson g = new Gson();
		SortedSet<?> convert = null;
		convert = g.fromJson(gaudiAIVersion.getActiveStep(), SortedSet.class);

		gaudiAIVersionData.setActiveStep(convert);
		gaudiAIVersionData.setProcessStatus(gaudiAIVersion.getProcessStatus());
		gaudiAIVersionData.setErrorMessage(gaudiAIVersion.getErrorMessage());
		gaudiAIVersionData.setVersionPath(gaudiAIVersion.getVersionPath());
		gaudiAIVersionData.setIsClone(gaudiAIVersion.getIsClone());
		gaudiAIVersionData.setCloneVersionID(gaudiAIVersion.getCloneVersionID());
		gaudiAIVersionData.setIsActive(gaudiAIVersion.getIsActive());
		gaudiAIVersionData.setCreatedDate(gaudiAIVersion.getCreatedDate());
		gaudiAIVersionData.setModifiedDate(gaudiAIVersion.getModifiedDate());
		gaudiAIVersionData.setCreatedBy(gaudiAIVersion.getCreatedBy());
		gaudiAIVersionData.setLockUnlock(gaudiAIVersion.getLockUnlock());
		gaudiAIVersionData.setSmartID(gaudiAIVersion.getSmartID());

		return gaudiAIVersionData;
	}

	private PythonSucessResponse blendingProcess(GaudiAIBlendingGenerate savedGaudiAIBlendingGenerate) {
		PythonBlendingRequest pythonBlendingRequest = null;
		PythonSucessResponse pythonSucessResponse = null;
		LOG.info(savedGaudiAIBlendingGenerate);
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(savedGaudiAIBlendingGenerate.getGaudiVersionID());
			pythonBlendingRequest = new PythonBlendingRequest();
			GenerateJsonReuest generateJsonReuest = new GenerateJsonReuest();
			List<GenerateJsonReuest> listGenerateJsonReuest = new ArrayList<>();

			pythonBlendingRequest.setOperation(Arrays.asList(ApplicationConstants.BLENDING));

			Gson g = new Gson();
			List<?> convert = null;


			generateJsonReuest.setOutput(gaudiAIVersion.get(0).getVersionPath());
			generateJsonReuest.setLogPath(gaudiAIVersion.get(0).getVersionPath() + File.separator+ApplicationConstants.DOC+ File.separator+ApplicationConstants.LOG);
			generateJsonReuest.setSmartId(gaudiAIVersion.get(0).getSmartID());
			Boolean saveDefectMask = (savedGaudiAIBlendingGenerate.getSaveDefectMask().equalsIgnoreCase(ApplicationConstants.YES)) ? true
					: false;
			Boolean rotation = (savedGaudiAIBlendingGenerate.getRotation().equalsIgnoreCase(ApplicationConstants.YES)) ? true : false;
			if (rotation) {
				generateJsonReuest.setRotation(rotation);
				generateJsonReuest.setDegree(savedGaudiAIBlendingGenerate.getDegreeOfRotationMin() + ApplicationConstants.HYPHEN
						+ savedGaudiAIBlendingGenerate.getDegreeOfRotationMax());
			} else {
				generateJsonReuest.setRotation(rotation);
				generateJsonReuest.setDegree(null);
			}
			generateJsonReuest.setSaveDefectMask(saveDefectMask);

			convert = g.fromJson(savedGaudiAIBlendingGenerate.getDefectXScale(), List.class);

			generateJsonReuest.setDefectXScale(convert);

			convert = g.fromJson(savedGaudiAIBlendingGenerate.getDefectYScale(), List.class);

			generateJsonReuest.setDefectYScale(convert);
			boolean defectRandomScale = (savedGaudiAIBlendingGenerate.getDefectRandomScale().equalsIgnoreCase(ApplicationConstants.YES)) ? true
					: false;
			generateJsonReuest.setScale(defectRandomScale);
			generateJsonReuest.setAlgorithm(savedGaudiAIBlendingGenerate.getAlgorithm());
			
			if (savedGaudiAIBlendingGenerate.getAlgorithm().equalsIgnoreCase(ApplicationConstants.DEEPBLENDING)) {
				generateJsonReuest.setIteration(savedGaudiAIBlendingGenerate.getIteration());
				generateJsonReuest.setGradWeight(savedGaudiAIBlendingGenerate.getGradWeight());
				generateJsonReuest.setStyleWeight(savedGaudiAIBlendingGenerate.getStyleWeight());
			} else {
				generateJsonReuest.setIteration(0l);
				generateJsonReuest.setGradWeight(0.0f);
				generateJsonReuest.setStyleWeight(0.0f);
			}
			generateJsonReuest.setImageCount(savedGaudiAIBlendingGenerate.getImageCount());
			generateJsonReuest.setSeed(savedGaudiAIBlendingGenerate.getSeed());

			listGenerateJsonReuest.add(generateJsonReuest);
			pythonBlendingRequest.setParams(listGenerateJsonReuest);
			LOG.info(pythonBlendingRequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			pythonSucessResponse = webClient.post().uri(gaudiServiceUrl+PythonServiceEndPointConstant.BLEND)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonBlendingRequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();
			updateActiveSteps(gaudiAIVersion.get(0), 5);
		} catch (UnprocessableEntity e) {
			LOG.error("UnprocessableEntity - {}"+e);
		 
		} catch (ServiceUnavailableException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (ServerErrorException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		}
		return pythonSucessResponse;
	}

    @SuppressWarnings("unchecked")
	@Transactional
	public void updateActiveSteps(GaudiAIVersion gaudiAIVersion, Integer tabID) {
		try {
			List<Integer> listTab = null;
			Set<Integer> setTab = new HashSet<>();
			if (gaudiAIVersion.getActiveStep() != null) {
				Gson g = new Gson();
				listTab = g.fromJson(gaudiAIVersion.getActiveStep(), List.class);
				listTab.add(tabID);
			} else {
				listTab = new ArrayList<>();
				listTab.add(tabID);
			}
			setTab.addAll(listTab);
			String listTabString = new ObjectMapper().writeValueAsString(setTab);
			LOG.info("----------------------listTabString------------------ {}", listTabString);
			gaudiAIVersionRepository.updateActiveStepVersionPath(new Date(System.currentTimeMillis()), listTabString,
					gaudiAIVersion.getVersionID());

		} catch (JsonProcessingException e) {
			LOG.info("Error in updateActiveSteps tabID - {}",tabID);
		}
	}

	private SourceTabResponse setSourceTabResponse(GaudiAIBlendingSource gaudiAIBlendingSource) {
		SourceTabResponse sourceTabResponse = null;
		try {
			sourceTabResponse = new SourceTabResponse();
			sourceTabResponse.setBlendingSourceID(gaudiAIBlendingSource.getBlendingSourceID());
			sourceTabResponse.setGaudiVersionID(gaudiAIBlendingSource.getGaudiVersionID());
			sourceTabResponse.setImageUploadType(gaudiAIBlendingSource.getImageUploadType());
			sourceTabResponse.setExternalNASPath(gaudiAIBlendingSource.getExternalNASPath());
			sourceTabResponse.setNasID(gaudiAIBlendingSource.getNasID());
			sourceTabResponse.setInternalsourcePath(gaudiAIBlendingSource.getInternalSourcePath());
			Gson g = new Gson();
			List<?> convert = null;
			convert = g.fromJson(gaudiAIBlendingSource.getSelectedSourceImageName(), List.class);
			sourceTabResponse.setSelectedSourceImageName(convert);
			sourceTabResponse.setSelectedSourceImageCount(gaudiAIBlendingSource.getSelectedSourceImageCount());
			sourceTabResponse.setIsActive(gaudiAIBlendingSource.getIsActive());
			sourceTabResponse.setCreatedDate(gaudiAIBlendingSource.getCreatedDate());
			sourceTabResponse.setModifiedDate(gaudiAIBlendingSource.getModifiedDate());
			sourceTabResponse.setCreatedBy(gaudiAIBlendingSource.getCreatedBy());
		} catch (Exception e) {
			LOG.info("Error In setSourceTabResponse blendingSourceID - {}",gaudiAIBlendingSource.getBlendingSourceID());
		}
		return sourceTabResponse;
	}

	private MaskTabResponse setMaskTabResponse(GaudiAIBlendingMask gaudiAIBlendingMask) {
		MaskTabResponse maskTabResponse = new MaskTabResponse();
		maskTabResponse.setBlendingMaskID(gaudiAIBlendingMask.getBlendingMaskID());
		maskTabResponse.setGaudiVersionID(gaudiAIBlendingMask.getGaudiVersionID());
		maskTabResponse.setMaskType(gaudiAIBlendingMask.getMaskType());
		maskTabResponse.setImageUploadType(gaudiAIBlendingMask.getImageUploadType());
		maskTabResponse.setExternalNASPath(gaudiAIBlendingMask.getExternalNASPath());
		maskTabResponse.setNasID(gaudiAIBlendingMask.getNasID());
		maskTabResponse.setInternalMaskPath(gaudiAIBlendingMask.getInternalMaskPath());

		Gson g = new Gson();
		List<?> convert = null;
		convert = g.fromJson(gaudiAIBlendingMask.getSelectedMaskImageName(), List.class);

		maskTabResponse.setSelectedMaskImageName(convert);
		maskTabResponse.setSelectedMaskImageCount(gaudiAIBlendingMask.getSelectedMaskImageCount());
		maskTabResponse.setMaskJsonName(gaudiAIBlendingMask.getMaskJsonName());
		maskTabResponse.setMaskJsonName(gaudiAIBlendingMask.getMaskJsonName());
		maskTabResponse.setOriginalAnnotationMaskImage(gaudiAIBlendingMask.getOriginalAnnotationMaskImage());
		maskTabResponse.setAnnotatedMaskImage(gaudiAIBlendingMask.getAnnotatedMaskImage());
		maskTabResponse.setIsActive(gaudiAIBlendingMask.getIsActive());
		maskTabResponse.setCreatedDate(gaudiAIBlendingMask.getCreatedDate());
		maskTabResponse.setModifiedDate(gaudiAIBlendingMask.getModifiedDate());
		maskTabResponse.setCreatedBy(gaudiAIBlendingMask.getCreatedBy());

		return maskTabResponse;
	}

	private TargetTabResponse setTargetTabResponse(GaudiAIBlendingTarget gaudiAIBlendingTarget) {
		TargetTabResponse targetTabResponse = new TargetTabResponse();
		targetTabResponse.setBlendingTargetID(gaudiAIBlendingTarget.getBlendingTargetID());
		targetTabResponse.setGaudiVersionID(gaudiAIBlendingTarget.getGaudiVersionID());
		targetTabResponse.setImageUploadType(gaudiAIBlendingTarget.getImageUploadType());
		targetTabResponse.setNasID(gaudiAIBlendingTarget.getNasID());
		targetTabResponse.setExternalNASPath(gaudiAIBlendingTarget.getExternalNASPath());
		targetTabResponse.setInternalTargetPath(gaudiAIBlendingTarget.getInternalTargetPath());
		Gson g = new Gson();
		List<?> convert = null;
		convert = g.fromJson(gaudiAIBlendingTarget.getSelectedTargetImageName(), List.class);
		targetTabResponse.setSelectedTargetImageName(convert);
		targetTabResponse.setSelectedTargetImageCount(gaudiAIBlendingTarget.getSelectedTargetImageCount());
		targetTabResponse.setIsActive(gaudiAIBlendingTarget.getIsActive());
		targetTabResponse.setCreatedDate(gaudiAIBlendingTarget.getCreatedDate());
		targetTabResponse.setModifiedDate(gaudiAIBlendingTarget.getModifiedDate());
		targetTabResponse.setCreatedBy(gaudiAIBlendingTarget.getCreatedBy());
		return targetTabResponse;
	}

	private TargetMaskTabResponse setTargetMaskTabResponse(GaudiAIBlendingTargetMask gaudiAIBlendingTargetMask) {
		TargetMaskTabResponse targetMaskTabResponse = new TargetMaskTabResponse();
		targetMaskTabResponse.setBlendingTargetMaskID(gaudiAIBlendingTargetMask.getBlendingTargetMaskID());
		targetMaskTabResponse.setGaudiVersionID(gaudiAIBlendingTargetMask.getGaudiVersionID());
		targetMaskTabResponse.setTargetMaskType(gaudiAIBlendingTargetMask.getTargetMaskType());
		targetMaskTabResponse.setImageUploadType(gaudiAIBlendingTargetMask.getImageUploadType());
		targetMaskTabResponse.setExternalNASPath(gaudiAIBlendingTargetMask.getExternalNASPath());
		targetMaskTabResponse.setNasID(gaudiAIBlendingTargetMask.getNasID());
		targetMaskTabResponse.setInternalTargetMaskPath(gaudiAIBlendingTargetMask.getInternalTargetMaskPath());

		Gson g = new Gson();
		List<?> convert = null;
		convert = g.fromJson(gaudiAIBlendingTargetMask.getSelectedTargetMaskImageName(), List.class);

		targetMaskTabResponse.setSelectedTargetMaskImageName(convert);
		targetMaskTabResponse
				.setSelectedTargetMaskImageCount(gaudiAIBlendingTargetMask.getSelectedTargetMaskImageCount());
		targetMaskTabResponse.setTargetMaskModelName(gaudiAIBlendingTargetMask.getTargetMaskModelName());
		targetMaskTabResponse.setTargetMaskJsonName(gaudiAIBlendingTargetMask.getTargetMaskJsonName());
		targetMaskTabResponse
				.setOriginalAnnotationTargetMaskImage(gaudiAIBlendingTargetMask.getOriginalAnnotationTargetMaskImage());
		targetMaskTabResponse.setAnnotatedTargetMaskImage(gaudiAIBlendingTargetMask.getAnnotatedTargetMaskImage());
		targetMaskTabResponse.setIsActive(gaudiAIBlendingTargetMask.getIsActive());
		targetMaskTabResponse.setCreatedDate(gaudiAIBlendingTargetMask.getCreatedDate());
		targetMaskTabResponse.setModifiedDate(gaudiAIBlendingTargetMask.getModifiedDate());
		targetMaskTabResponse.setCreatedBy(gaudiAIBlendingTargetMask.getCreatedBy());
		return targetMaskTabResponse;
	}

	private GenerateTabResponse setGenerateTabResponse(GaudiAIBlendingGenerate gaudiAIBlendingGenerate) {
		GenerateTabResponse generateTabResponse = new GenerateTabResponse();
		generateTabResponse.setBlendingGenerateID(gaudiAIBlendingGenerate.getBlendingGenerateID());
		generateTabResponse.setGaudiVersionID(gaudiAIBlendingGenerate.getGaudiVersionID());
		generateTabResponse.setSaveDefectMask(gaudiAIBlendingGenerate.getSaveDefectMask());
		generateTabResponse.setDefectXScale(gaudiAIBlendingGenerate.getDefectXScale());
		generateTabResponse.setDefectYScale(gaudiAIBlendingGenerate.getDefectYScale());
		generateTabResponse.setImageCount(gaudiAIBlendingGenerate.getImageCount());
		generateTabResponse.setAlgorithm(gaudiAIBlendingGenerate.getAlgorithm());
		generateTabResponse.setIteration(gaudiAIBlendingGenerate.getIteration());
		generateTabResponse.setGradWeight(gaudiAIBlendingGenerate.getGradWeight());
		generateTabResponse.setStyleWeight(gaudiAIBlendingGenerate.getStyleWeight());
		generateTabResponse.setSeed(gaudiAIBlendingGenerate.getSeed());
		generateTabResponse.setIsActive(gaudiAIBlendingGenerate.getIsActive());
		generateTabResponse.setCreatedDate(gaudiAIBlendingGenerate.getCreatedDate());
		generateTabResponse.setModifiedDate(gaudiAIBlendingGenerate.getModifiedDate());
		generateTabResponse.setCreatedBy(gaudiAIBlendingGenerate.getCreatedBy());
		generateTabResponse.setRotation(gaudiAIBlendingGenerate.getRotation());
		generateTabResponse.setDegreeOfRotationMin(gaudiAIBlendingGenerate.getDegreeOfRotationMin());
		generateTabResponse.setDegreeOfRotationMax(gaudiAIBlendingGenerate.getDegreeOfRotationMax());
		generateTabResponse.setDefectRandomScale(gaudiAIBlendingGenerate.getDefectRandomScale());
		return generateTabResponse;
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateSourceData(BlendingSourceRequest gaudiAISourceUpdateRequest) {

		Long gaudiVersionID = gaudiAISourceUpdateRequest.getGaudiVersionID();

		Long blendingSourceID = gaudiAISourceUpdateRequest.getBlendingSourceID();

		HttpOperationResponseBean response = null;

		try {
			if (gaudiVersionID != null && blendingSourceID != null) {
				List<GaudiAIBlendingSource> existSourceData = gaudiAIBlendingSourceRepository
						.getSourceByBlendingSourceID(blendingSourceID);

				if (existSourceData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.source.data.for.blendingSourceid", null,
									LocaleContextHolder.getLocale()) + blendingSourceID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				String imageUploadType = gaudiAISourceUpdateRequest.getImageUploadType() != null
						&& !gaudiAISourceUpdateRequest.getImageUploadType().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAISourceUpdateRequest.getImageUploadType()
								: existSourceData.get(0).getImageUploadType();

				String externalNASPath = gaudiAISourceUpdateRequest.getExternalNASPath() != null
						&& !gaudiAISourceUpdateRequest.getExternalNASPath().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAISourceUpdateRequest.getExternalNASPath()
								: existSourceData.get(0).getExternalNASPath();

				String selectedSourceImageName = new ObjectMapper()
						.writeValueAsString(gaudiAISourceUpdateRequest.getSelectedSourceImageName());

				String selectedSourceImage = selectedSourceImageName != null
						&& !selectedSourceImageName.equalsIgnoreCase(ApplicationConstants.BLANK)
								? selectedSourceImageName
								: existSourceData.get(0).getSelectedSourceImageName();

				Long selectedSourceImageCount = gaudiAISourceUpdateRequest.getSelectedSourceImageCount() != 0
						&& !gaudiAISourceUpdateRequest.getSelectedSourceImageCount().equals(null)
								? gaudiAISourceUpdateRequest.getSelectedSourceImageCount()
								: existSourceData.get(0).getSelectedSourceImageCount();

				gaudiAIBlendingSourceRepository.updateSourceData(blendingSourceID, imageUploadType, externalNASPath,
						selectedSourceImage, selectedSourceImageCount, new Date(System.currentTimeMillis()));

				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("the.sourceData.updated.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("The Source data Updated successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Error In The SOurce Data For blendingSourceID - {}",blendingSourceID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.source.data.for.versionid", null,
								LocaleContextHolder.getLocale()) + gaudiVersionID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The Source Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("Error.In.Updating.The.Source.Data",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateMaskData(BlendingMaskRequest gaudiAIMaskUpdateRequest) {
		Long gaudiVersionID = gaudiAIMaskUpdateRequest.getGaudiVersionID();

		Long blendingMaskID = gaudiAIMaskUpdateRequest.getBlendingMaskID();

		HttpOperationResponseBean response = null;

		try {
			if (gaudiVersionID != null && blendingMaskID != null) {
				List<GaudiAIBlendingMask> existMaskData = gaudiAIBlendingMaskRepository
						.getMaskByBlendingMaskID(blendingMaskID);

				if (existMaskData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.mask.data.for.blendingMaskid", null,
									LocaleContextHolder.getLocale())+ blendingMaskID ,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				String imageUploadType = gaudiAIMaskUpdateRequest.getImageUploadType() != null
						&& !gaudiAIMaskUpdateRequest.getImageUploadType().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAIMaskUpdateRequest.getImageUploadType()
								: existMaskData.get(0).getImageUploadType();

				String externalNASPath = gaudiAIMaskUpdateRequest.getExternalNASPath() != null
						&& !gaudiAIMaskUpdateRequest.getExternalNASPath().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAIMaskUpdateRequest.getExternalNASPath()
								: existMaskData.get(0).getExternalNASPath();

				String selectedSourceImageName = new ObjectMapper()
						.writeValueAsString(gaudiAIMaskUpdateRequest.getSelectedMaskImageName());

				String selectedSourceImage = selectedSourceImageName != null
						&& !selectedSourceImageName.equalsIgnoreCase(ApplicationConstants.BLANK)
								? selectedSourceImageName
								: existMaskData.get(0).getSelectedMaskImageName();

				
				Long selectedSourceImageCount = gaudiAIMaskUpdateRequest.getSelectedMaskImageCount() != 0
						&& !gaudiAIMaskUpdateRequest.getSelectedMaskImageCount().equals(null)
								? gaudiAIMaskUpdateRequest.getSelectedMaskImageCount()
								: existMaskData.get(0).getSelectedMaskImageCount();

				gaudiAIBlendingMaskRepository.updateMaskData(blendingMaskID, imageUploadType, externalNASPath,
						selectedSourceImage, selectedSourceImageCount, new Date(System.currentTimeMillis()));

				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("the.maskdata.updated.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("The Mask data Updated successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Error In The Mask Data For blendingMaskID - {}",blendingMaskID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.mask.data.for.versionid", null,
								LocaleContextHolder.getLocale()) + gaudiVersionID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The Mask Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.updating.the.mask.data", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateTargetData(BlendingTargetRequest gaudiAITargetUpdateRequest) {
		Long gaudiVersionID = gaudiAITargetUpdateRequest.getGaudiVersionID();

		Long blendinTargetID = gaudiAITargetUpdateRequest.getBlendingTargetID();

		HttpOperationResponseBean response = null;
		try {
			if (gaudiVersionID != null && blendinTargetID != null) {
				List<GaudiAIBlendingTarget> existTargetData = gaudiAIBlendingTargetRepository
						.getTargetByBlendingTarget(blendinTargetID);

				if (existTargetData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.target.data.for.blendingtargetid", null,
									LocaleContextHolder.getLocale())+ blendinTargetID ,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				String imageUploadType = gaudiAITargetUpdateRequest.getImageUploadType() != null
						&& !gaudiAITargetUpdateRequest.getImageUploadType().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAITargetUpdateRequest.getImageUploadType()
								: existTargetData.get(0).getImageUploadType();

				String externalNASPath = gaudiAITargetUpdateRequest.getExternalNASPath() != null
						&& !gaudiAITargetUpdateRequest.getExternalNASPath().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAITargetUpdateRequest.getExternalNASPath()
								: existTargetData.get(0).getExternalNASPath();

				String selectedTargetImageName = new ObjectMapper()
						.writeValueAsString(gaudiAITargetUpdateRequest.getSelectedTargetImageName());

				String selectedTargetImage = selectedTargetImageName != null
						&& !selectedTargetImageName.equalsIgnoreCase(ApplicationConstants.BLANK)
								? selectedTargetImageName
								: existTargetData.get(0).getSelectedTargetImageName();

				
				Long selectedTargetImageCount = gaudiAITargetUpdateRequest.getSelectedTargetImageCount() != 0
						&& !gaudiAITargetUpdateRequest.getSelectedTargetImageCount().equals(null)
								? gaudiAITargetUpdateRequest.getSelectedTargetImageCount()
								: existTargetData.get(0).getSelectedTargetImageCount();

				gaudiAIBlendingTargetRepository.updateMaskData(blendinTargetID, imageUploadType, externalNASPath,
						selectedTargetImage, selectedTargetImageCount, new Date(System.currentTimeMillis()));

				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("the.target.data.updated.successfully", null,
						LocaleContextHolder.getLocale()) );
				LOG.info("The Target data Updated successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Error In The Target Data For blendinTargetID - {}",blendinTargetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.target.data.for.versionid", null,
								LocaleContextHolder.getLocale()) + gaudiVersionID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The Target Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.updating.the.target.data",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

		
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateTargetMaskData(BlendingTargetMaskRequest gaudiAITargetMaskUpdateRequest) {
		Long gaudiVersionID = gaudiAITargetMaskUpdateRequest.getGaudiVersionID();

		Long blendingTargetMaskID = gaudiAITargetMaskUpdateRequest.getBlendingTargetMaskID();

		HttpOperationResponseBean response = null;

		try {
			if (gaudiVersionID != null && blendingTargetMaskID != null) {
				List<GaudiAIBlendingTargetMask> existtargetTargetMaskData = gaudiAIBlendingTargetMaskRepository
						.getTargetMaskByBlendingTargetMaskID(blendingTargetMaskID);

				if (existtargetTargetMaskData.isEmpty()) {

					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.targetmask.data.for.blendingtargetmaskid", null,
									LocaleContextHolder.getLocale())+ blendingTargetMaskID ,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				String imageUploadType = gaudiAITargetMaskUpdateRequest.getImageUploadType() != null
						&& !gaudiAITargetMaskUpdateRequest.getImageUploadType()
								.equalsIgnoreCase(ApplicationConstants.BLANK)
										? gaudiAITargetMaskUpdateRequest.getImageUploadType()
										: existtargetTargetMaskData.get(0).getImageUploadType();

				String externalNASPath = gaudiAITargetMaskUpdateRequest.getExternalNASPath() != null
						&& !gaudiAITargetMaskUpdateRequest.getExternalNASPath()
								.equalsIgnoreCase(ApplicationConstants.BLANK)
										? gaudiAITargetMaskUpdateRequest.getExternalNASPath()
										: existtargetTargetMaskData.get(0).getExternalNASPath();

				String selectedTargetMaskImageName = new ObjectMapper()
						.writeValueAsString(gaudiAITargetMaskUpdateRequest.getSelectedTargetMaskImageName());

				String selectedTargetMaskImage = selectedTargetMaskImageName != null
						&& !selectedTargetMaskImageName.equalsIgnoreCase(ApplicationConstants.BLANK)
								? selectedTargetMaskImageName
								: existtargetTargetMaskData.get(0).getSelectedTargetMaskImageName();

				
				Long selectedTargetMaskImageCount = gaudiAITargetMaskUpdateRequest
						.getSelectedTargetMaskImageCount() != 0
						&& !gaudiAITargetMaskUpdateRequest.getSelectedTargetMaskImageCount().equals(null)
								? gaudiAITargetMaskUpdateRequest.getSelectedTargetMaskImageCount()
								: existtargetTargetMaskData.get(0).getSelectedTargetMaskImageCount();

				gaudiAIBlendingTargetMaskRepository.updateTargetMaskData(blendingTargetMaskID, imageUploadType,
						externalNASPath, selectedTargetMaskImage, selectedTargetMaskImageCount,
						new Date(System.currentTimeMillis()));

				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("the.targetmask.data.updated.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("The TargetMask data Updated successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Error In The TargetMask Data For blendingTargetMaskID - {}",blendingTargetMaskID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.targetmask.data.for.versionid", null,
								LocaleContextHolder.getLocale())+ blendingTargetMaskID ,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The TargetMask Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.updating.the.targetmask.data",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateGenerateData(BlendingGenerateRequest gaudiAIGenerateUpdateRequest) {

		Long blendinGenerateID = gaudiAIGenerateUpdateRequest.getBlendingGenerateID();
		PythonSucessResponse pythonSucessResponse = null;
		try {
			
			
			GaudiAIVersion gaudiAIVersion = gaudiAIVersionRepository
					.getReferenceById(gaudiAIGenerateUpdateRequest.getGaudiVersionID());
			Long projectID = gaudiAIVersion.getProjectID();
			GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.getReferenceById(projectID);
			BlendingDiscardImageRequest blendingDiscardImageRequest1 = new BlendingDiscardImageRequest();
			blendingDiscardImageRequest1.setNoOfChannels(gaudiAIProjects.getNoOfChannel());
			blendingDiscardImageRequest1.setTabName(ApplicationConstants.SOURCE);
			blendingDiscardImageRequest1.setVersionID(gaudiAIGenerateUpdateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis1 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest1);
			HttpOperationResponseBean body = (HttpOperationResponseBean) imageCountBasis1.getBody();
			if (body.getMessage().equalsIgnoreCase(messageSource.getMessage("please.upload.atleast.one.image",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("please upload atleast one image in source tab.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("please.upload.atleast.one.image.in.source.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			if (body.getMessage().equalsIgnoreCase(messageSource.getMessage("please.make.images.equal.in.all.channel",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("Image Count Mismatch Across Channels in Source Tab");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("image.count.mismatch.across.channels.in.source.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			BlendingDiscardImageRequest blendingDiscardImageRequest2 = new BlendingDiscardImageRequest();
			blendingDiscardImageRequest2.setNoOfChannels(0L);
			blendingDiscardImageRequest2.setTabName(ApplicationConstants.SOURCE_MASK);
			blendingDiscardImageRequest2.setVersionID(gaudiAIGenerateUpdateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis2 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest2);
			HttpOperationResponseBean body2 = (HttpOperationResponseBean) imageCountBasis2.getBody();
			if (body2.getMessage().equals(messageSource.getMessage("please.upload.atleast.one.image", null,
					LocaleContextHolder.getLocale()))) {
				LOG.error("Blending Mask Tab Is Mandatory To Fill.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("please.upload.atleast.one.image",
								null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			BlendingDiscardImageRequest blendingDiscardImageRequest3 = new BlendingDiscardImageRequest();
			blendingDiscardImageRequest3.setNoOfChannels(gaudiAIProjects.getNoOfChannel());
			blendingDiscardImageRequest3.setTabName(ApplicationConstants.TARGET);
			blendingDiscardImageRequest3.setVersionID(gaudiAIGenerateUpdateRequest.getGaudiVersionID());
			ResponseEntity<?> imageCountBasis3 = checkTheBlendingImageCountBasis(blendingDiscardImageRequest3);
			HttpOperationResponseBean body3 = (HttpOperationResponseBean) imageCountBasis3.getBody();
			if (body3.getMessage().equalsIgnoreCase(messageSource.getMessage("please.upload.atleast.one.image",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("please upload atleast one image in target tab.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("please.upload.atleast.one.image.in.target.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			if (body3.getMessage().equalsIgnoreCase(messageSource.getMessage("please.make.images.equal.in.all.channel",
					null, LocaleContextHolder.getLocale()))) {
				LOG.error("Image Count Mismatch Across Channels in Target Tab");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("image.count.mismatch.across.channels.in.target.tab", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			ResponseEntity<?> updateGenerateJson = updateGenerateJson(gaudiAIGenerateUpdateRequest);

			
			if (updateGenerateJson.getStatusCode().equals(HttpStatus.OK)) {
				GaudiAIBlendingGenerate gaudiAIBlendingGenerate = gaudiAIBlendingGenerateRepository
						.getReferenceById(blendinGenerateID);
				pythonSucessResponse = blendingProcess(gaudiAIBlendingGenerate);
			} else {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
								"error.in.updating.the.generate.data", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
		} catch (WebClientResponseException e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE,
					messageSource.getMessage("server.is.down.please.try.after.sometimes", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		}
		
	
	}
	
	@Transactional
	public ResponseEntity<?> updateGenerateJson(BlendingGenerateRequest gaudiAIGenerateUpdateRequest) {
		Long gaudiVersionID = gaudiAIGenerateUpdateRequest.getGaudiVersionID();
		Long blendinGenerateID = gaudiAIGenerateUpdateRequest.getBlendingGenerateID();

		try {
			if (gaudiVersionID != null && blendinGenerateID != null) {
				List<GaudiAIBlendingGenerate> existtargetGenerateData = gaudiAIBlendingGenerateRepository
						.getGenerateByBlendingGenerateID(blendinGenerateID);
			
				if (existtargetGenerateData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.generate.data.for.blendingGenerateid", null,
									LocaleContextHolder.getLocale())+blendinGenerateID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}

				String saveDefectMask = gaudiAIGenerateUpdateRequest.getSaveDefectMask() != null
						&& !gaudiAIGenerateUpdateRequest.getSaveDefectMask()
								.equalsIgnoreCase(ApplicationConstants.BLANK)
										? gaudiAIGenerateUpdateRequest.getSaveDefectMask()
										: existtargetGenerateData.get(0).getSaveDefectMask();
				List<Float> defectXScale2 = gaudiAIGenerateUpdateRequest.getDefectXScale();
					if(validateRange(defectXScale2)) {
						LOG.error("DefectXScale value must be between 0.1f and 2.0f");
						AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
								ApplicationConstants.BAD_REQUEST, messageSource.getMessage("defect.x.scale.value.must.be.between.0.1f.and.2.0f", null,
										LocaleContextHolder.getLocale()) , null);
						return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
					}
				List<Float> defectYScale2 = gaudiAIGenerateUpdateRequest.getDefectYScale();
					if(validateRange(defectYScale2)) {
						LOG.error("DefectYScale value must be between 0.1f and 2.0f");
						AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
								ApplicationConstants.BAD_REQUEST, messageSource.getMessage("defect.y.scale.value.must.be.between.0.1f.and.2.0f", null,
										LocaleContextHolder.getLocale()) , null);
						return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
					}
				String defectXScale = new ObjectMapper()
						.writeValueAsString(gaudiAIGenerateUpdateRequest.getDefectXScale());

				String defectXScales = defectXScale != null
						&& !defectXScale.equalsIgnoreCase(ApplicationConstants.BLANK) ? defectXScale
								: existtargetGenerateData.get(0).getDefectXScale();

				String defectYScale = new ObjectMapper()
						.writeValueAsString(gaudiAIGenerateUpdateRequest.getDefectYScale());

				String defectYScales = defectYScale != null
						&& !defectYScale.equalsIgnoreCase(ApplicationConstants.BLANK) ? defectYScale
								: existtargetGenerateData.get(0).getDefectYScale();
				String defectRandomScale = gaudiAIGenerateUpdateRequest.getDefectRandomScale() != null
						&& !gaudiAIGenerateUpdateRequest.getDefectRandomScale()
								.equalsIgnoreCase(ApplicationConstants.BLANK)
										? gaudiAIGenerateUpdateRequest.getDefectRandomScale()
										: existtargetGenerateData.get(0).getDefectRandomScale();
				Long imageCount = gaudiAIGenerateUpdateRequest.getImageCount() != 0
						&& !gaudiAIGenerateUpdateRequest.getImageCount().equals(null)
								? gaudiAIGenerateUpdateRequest.getImageCount()
								: existtargetGenerateData.get(0).getImageCount();

				String algorithm = gaudiAIGenerateUpdateRequest.getAlgorithm() != null
						&& !gaudiAIGenerateUpdateRequest.getAlgorithm().equalsIgnoreCase(ApplicationConstants.BLANK)
								? gaudiAIGenerateUpdateRequest.getAlgorithm()
								: existtargetGenerateData.get(0).getAlgorithm();

				Long iteration = gaudiAIGenerateUpdateRequest.getIteration() != 0
						&& !gaudiAIGenerateUpdateRequest.getIteration().equals(null)
								? gaudiAIGenerateUpdateRequest.getIteration()
								: existtargetGenerateData.get(0).getIteration();

				float gradWeight = gaudiAIGenerateUpdateRequest.getGradWeight() != 0.0
						&& !gaudiAIGenerateUpdateRequest.getGradWeight().equals(null)
								? gaudiAIGenerateUpdateRequest.getGradWeight()
								: existtargetGenerateData.get(0).getGradWeight();

				float styleWeight = gaudiAIGenerateUpdateRequest.getStyleWeight() != 0.0
						&& !gaudiAIGenerateUpdateRequest.getStyleWeight().equals(null)
								? gaudiAIGenerateUpdateRequest.getStyleWeight()
								: existtargetGenerateData.get(0).getStyleWeight();

				Long seed = gaudiAIGenerateUpdateRequest.getSeed() != 0
						&& !gaudiAIGenerateUpdateRequest.getSeed().equals(null) ? gaudiAIGenerateUpdateRequest.getSeed()
								: existtargetGenerateData.get(0).getSeed();

				String rotation=gaudiAIGenerateUpdateRequest.getRotation()!=null &&
						 !gaudiAIGenerateUpdateRequest.getRotation().equalsIgnoreCase(ApplicationConstants.BLANK)
						 ?gaudiAIGenerateUpdateRequest.getRotation() :existtargetGenerateData.get(0).getRotation();
				
				Long degreeOfRotationMin=gaudiAIGenerateUpdateRequest.getDegreeOfRotationMin() != 0
						&& !gaudiAIGenerateUpdateRequest.getDegreeOfRotationMin().equals(null) ? gaudiAIGenerateUpdateRequest.getDegreeOfRotationMin()
								: existtargetGenerateData.get(0).getDegreeOfRotationMin();
				
				Long degreeOfRotationMax=gaudiAIGenerateUpdateRequest.getDegreeOfRotationMax() != 0
						&& !gaudiAIGenerateUpdateRequest.getDegreeOfRotationMax().equals(null) ? gaudiAIGenerateUpdateRequest.getDegreeOfRotationMax()
								: existtargetGenerateData.get(0).getDegreeOfRotationMax();
				
				 gaudiAIBlendingGenerateRepository.updateGenerateData(blendinGenerateID,
						saveDefectMask, defectXScales, defectYScales, imageCount, algorithm, iteration, gradWeight,
						styleWeight,seed,rotation,degreeOfRotationMin,degreeOfRotationMax,defectRandomScale,new Date(System.currentTimeMillis()));

				
				LOG.info("The Generate data Updated successfully.");
				return new ResponseEntity<>(HttpStatus.OK);
			} else {
				LOG.error("Error In The Generate Data For blendinGenerateID -{}",blendinGenerateID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.generate.data.for.versionid", null,
								LocaleContextHolder.getLocale()) +gaudiVersionID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The Generate Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.updating.the.generate.data",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteBlendingImage(DeleteImageRequest deleteBlendingImageRequest) {
		HttpOperationResponseBean response = null;
		try {
			if (deleteBlendingImageRequest != null) {
				Long versionID = deleteBlendingImageRequest.getVersionID();
				String tabName = deleteBlendingImageRequest.getTabName();
				if(tabName == null) {
					LOG.error("TabName Is Empty. Please Add TabName In Request.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,messageSource.getMessage("tabname.is.empty.please.add.tabname.in.request",
									null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				
				}
				List<String> listImageName = deleteBlendingImageRequest.getImageName();
				Boolean deleteAllImage = false;
				LOG.info("Service Delete Blending Image.");
				List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
				List<GaudiAIBlendingSource> gaudiAIBlendingSource = gaudiAIBlendingSourceRepository
						.findByGaudiVersionID(versionID);
				List<GaudiAIBlendingMask> gaudiAIBlendingMask = gaudiAIBlendingMaskRepository
						.findByGaudiVersionID(versionID);
				List<GaudiAIBlendingTarget> gaudiAIBlendingTarget = gaudiAIBlendingTargetRepository
						.findByGaudiVersionID(versionID);
				List<GaudiAIBlendingTargetMask> gaudiAIBlendingTargetMask = gaudiAIBlendingTargetMaskRepository
						.findByGaudiVersionID(versionID);

				if (listImageName == null || listImageName.isEmpty()) {
					deleteAllImage = true;
				}
				if (tabName.equalsIgnoreCase(ApplicationConstants.SOURCE)) {
					String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
							+ ApplicationConstants.IMAGE + File.separator + tabName;
					if (gaudiAIBlendingSource.isEmpty()) {
						deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
					} else {
						if (Boolean.TRUE.equals(deleteAllImage)) {
							filesStorageService.deleteFolder(uploadImagePath);
							applicationUtil.createDirectory(uploadImagePath);
							gaudiAIBlendingSourceRepository.deleteGaudiAIBlendingSourceByGaudiVersionID(versionID);
						} else {
							String selectedSourceImageName = gaudiAIBlendingSource.get(0).getSelectedSourceImageName();
							Long selectedSourceImageCount = gaudiAIBlendingSource.get(0).getSelectedSourceImageCount();
							Gson g = new Gson();
							List<?> convert = g.fromJson(selectedSourceImageName, List.class);
							
							 List<File> list = getListOfImagesFromChannels(uploadImagePath, listImageName);
								for (File file2 : list) {
									String channelPath = file2.getAbsolutePath().substring(0,file2.getAbsolutePath().lastIndexOf(File.separator));
									filesStorageService.deleteImage(channelPath,file2.getName());
									String imageName1=file2.getName().substring(0,listImageName.get(0).lastIndexOf(ApplicationConstants.DOT));
									for (int j = 0; j < convert.size(); j++) {
										if (convert.get(j).toString().equals(imageName1)) { 
											convert.remove(convert.get(j).toString());
											selectedSourceImageCount = selectedSourceImageCount - 1;
										}
									}
									continue;
								}  
							String updatedSourceImageName = new ObjectMapper().writeValueAsString(convert);
							gaudiAIBlendingSourceRepository.updateSelectedSourceImageNameAndCount(
									gaudiAIBlendingSource.get(0).getBlendingSourceID(), updatedSourceImageName,
									selectedSourceImageCount, new Date(System.currentTimeMillis()));
						}
					}
					tabName = ApplicationConstants.SOURCE_MASK;
				}
				if (tabName.equalsIgnoreCase(ApplicationConstants.SOURCE_MASK)) {
					String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
							+ ApplicationConstants.IMAGE + File.separator + tabName;
					if (gaudiAIBlendingMask.isEmpty()) {
						deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
					} else {
						if (Boolean.TRUE.equals(deleteAllImage)) {
							filesStorageService.deleteFolder(uploadImagePath);
							applicationUtil.createDirectory(uploadImagePath);
							gaudiAIBlendingMaskRepository.deleteGaudiAIBlendingMaskByGaudiVersionID(versionID);
						} else {
							String selectedMaskImageName = gaudiAIBlendingMask.get(0).getSelectedMaskImageName();
							Long selectedMaskImageCount = gaudiAIBlendingMask.get(0).getSelectedMaskImageCount();
							Gson g1 = new Gson();
							List<?> convert1 =  g1.fromJson(selectedMaskImageName, List.class);
							for (int i = 0; i < listImageName.size(); i++) {
								String imageName1=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT)+1);
								File[] files = getListOfFileWithoutExtension(uploadImagePath, imageName1);
								if(files.length>0) {
								List<File> list = Arrays.asList(files);
									int lastIndexOf = list.get(0).toString().lastIndexOf(File.separator);
									String imageName=list.get(0).toString().substring(lastIndexOf+1);
									filesStorageService.deleteImage(uploadImagePath, imageName);
									}else{
										continue;
									}
									String imageName2=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT));
								for (int j = 0; j < convert1.size(); j++) {
									
									if (convert1.get(j).toString().equals(imageName2)) { 
										convert1.remove(convert1.get(j).toString());
										selectedMaskImageCount = selectedMaskImageCount - 1;
									}
								}
							}
							String updatedSelectedMaskImageName = new ObjectMapper().writeValueAsString(convert1);
							gaudiAIBlendingMaskRepository.updateSelectedMaskImageNameAndCount(
									gaudiAIBlendingMask.get(0).getBlendingMaskID(), updatedSelectedMaskImageName,
									selectedMaskImageCount, new Date(System.currentTimeMillis()));
						}
					}
				}
				if (tabName.equalsIgnoreCase(ApplicationConstants.TARGET)) {
					String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
							+ ApplicationConstants.IMAGE + File.separator + tabName;
					if (gaudiAIBlendingTarget.isEmpty()) {
						deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
					} else {
						if (Boolean.TRUE.equals(deleteAllImage)) {
							filesStorageService.deleteFolder(uploadImagePath);
							applicationUtil.createDirectory(uploadImagePath);
							gaudiAIBlendingTargetRepository.deleteGaudiAIBlendingTargetByGaudiVersionID(versionID);
						} else {
							String selectedTargetImageName = gaudiAIBlendingTarget.get(0).getSelectedTargetImageName();
							Long selectedTargetImageCount = gaudiAIBlendingTarget.get(0).getSelectedTargetImageCount();
							Gson g = new Gson();
							List<?> convert =  g.fromJson(selectedTargetImageName, List.class);
							 List<File> list = getListOfImagesFromChannels(uploadImagePath, listImageName);
								
								for (File file2 : list) {
									String channelPath = file2.getAbsolutePath().substring(0,file2.getAbsolutePath().lastIndexOf(File.separator));
									filesStorageService.deleteImage(channelPath,file2.getName());
									String imageName1=file2.getName().substring(0,listImageName.get(0).lastIndexOf(ApplicationConstants.DOT));
									for (int j = 0; j < convert.size(); j++) {
										
										if (convert.get(j).toString().equals(imageName1)) { 
											convert.remove(convert.get(j).toString());
											selectedTargetImageCount = selectedTargetImageCount - 1;
										}
									}
									continue;
								}
							String updatedTargetImageName = new ObjectMapper().writeValueAsString(convert);
							gaudiAIBlendingTargetRepository.updateSelectedTargetImageNameAndCount(
									gaudiAIBlendingTarget.get(0).getBlendingTargetID(), updatedTargetImageName,
									selectedTargetImageCount, new Date(System.currentTimeMillis()));
						}
					}
					tabName = ApplicationConstants.TARGET_MASK;
				}
				if (tabName.equalsIgnoreCase(ApplicationConstants.TARGET_MASK)) {
					String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
							+ ApplicationConstants.IMAGE + File.separator + tabName;
					if (gaudiAIBlendingTargetMask.isEmpty()) {
						deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
					} else {
						if (Boolean.TRUE.equals(deleteAllImage)) {
							filesStorageService.deleteFolder(uploadImagePath);
							applicationUtil.createDirectory(uploadImagePath);
							gaudiAIBlendingTargetMaskRepository.deleteGaudiAIBlendingTargetMaskByGaudiVersionID(versionID);
						} else {
							String selectedTargetMaskImageName = gaudiAIBlendingTargetMask.get(0).getSelectedTargetMaskImageName();
							Long selectedTargetMaskImageCount = gaudiAIBlendingTargetMask.get(0).getSelectedTargetMaskImageCount();
							Gson g1 = new Gson();
							List<?> convert1 = g1.fromJson(selectedTargetMaskImageName, List.class);
							for (int i = 0; i < listImageName.size(); i++) {
								String imageName1=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT)+1);
								File[] files = getListOfFileWithoutExtension(uploadImagePath, imageName1);
								if(files.length>0) {
								List<File> list = Arrays.asList(files);
									int lastIndexOf = list.get(0).toString().lastIndexOf(File.separator);
									String imageName=list.get(0).toString().substring(lastIndexOf+1);
									filesStorageService.deleteImage(uploadImagePath, imageName);
									}else{
										continue;
									}
								String imageName2=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT));
								for (int j = 0; j < convert1.size(); j++) {
									if (convert1.get(j).toString().equals(imageName2)) { 
										convert1.remove(convert1.get(j).toString());
										selectedTargetMaskImageCount = selectedTargetMaskImageCount - 1;
									}
								}
							}
							String updatedSelectedTargetMaskImageName = new ObjectMapper().writeValueAsString(convert1);
							gaudiAIBlendingTargetMaskRepository.updateSelectedTargetMaskImageNameAndCount(
									gaudiAIBlendingTargetMask.get(0).getBlendingTargetMaskID(), updatedSelectedTargetMaskImageName,
									selectedTargetMaskImageCount, new Date(System.currentTimeMillis()));
						}
					}
				}
				if (tabName.equalsIgnoreCase(ApplicationConstants.RESULT)) {
					deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
				}
			
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("blending.image.deleted.successfully",null, LocaleContextHolder.getLocale()));
				LOG.info("Blending Image Deleted Successfully.");
				return  new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Request Is Empty");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,messageSource.getMessage("request.is.empty",null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Delete Blending Image");
 			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.delete.blending.image",null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		
		}
	}

	private List<File> getListOfImagesFromChannels(String uploadImagePath, List<String> listImageName) {
	
		File folder = new File(uploadImagePath);
		File[] listOfFolder = folder.listFiles();
		List<File> fileList = new ArrayList<>();
		if (listOfFolder != null) {
			for (File folder1 : listOfFolder) {
				for (int i = 0; i < listImageName.size(); i++) {
					String imageName1=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT)+1);
					File[] files = getListOfFileWithoutExtension(folder1.toString(), imageName1);
					List<File> list = Arrays.asList(files);
					fileList.addAll(list);
				}
			}
		}
		return fileList;
	}
	@Transactional
	public void deleteFolderImage(List<GaudiAIVersion> gaudiAIVersion, String tabName, Boolean deleteAllImage,
			List<String> listImageName) {

		String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
				+ File.separator + tabName;
		List<String> listOfFolders = filesStorageService.fetchFolderNames(uploadImagePath);
		Long channelNos=(long) listOfFolders.size();
		if (Boolean.TRUE.equals(deleteAllImage)) {
			filesStorageService.deleteFolder(uploadImagePath);
			if(tabName.equalsIgnoreCase(ApplicationConstants.SOURCE)|| tabName.equalsIgnoreCase(ApplicationConstants.TARGET)) {
				applicationUtil.createChannelFolder(uploadImagePath, channelNos);
			}else {
			applicationUtil.createDirectory(uploadImagePath);
			}
		} else {
			if(tabName.equalsIgnoreCase(ApplicationConstants.SOURCE)|| tabName.equalsIgnoreCase(ApplicationConstants.TARGET)) {
				 List<File> list = getListOfImagesFromChannels(uploadImagePath, listImageName);
					for (File file2 : list) {
						String channelPath = file2.getAbsolutePath().substring(0,file2.getAbsolutePath().lastIndexOf(File.separator));
						filesStorageService.deleteImage(channelPath,file2.getName());
			  }
				}else {
					for (int i = 0; i < listImageName.size(); i++) {
						String imageName1=listImageName.get(i).substring(0,listImageName.get(i).lastIndexOf(ApplicationConstants.DOT)+1);
						File[] files = getListOfFileWithoutExtension(uploadImagePath, imageName1);
						if(files.length>0) {
						List<File> list = Arrays.asList(files);
						int lastIndexOf = list.get(0).toString().lastIndexOf(File.separator);
						String imageName=list.get(0).toString().substring(lastIndexOf+1);
						filesStorageService.deleteImage(uploadImagePath, imageName);
						}else{
							continue;
						}
				}
			}
		}

	}

	@Override
	public ResponseEntity<?> discardTheBlendingImage(BlendingDiscardImageRequest blendingDiscardImageRequest) {
		try {
			Long versionID = blendingDiscardImageRequest.getVersionID();
			String tabName = blendingDiscardImageRequest.getTabName();
			Long noOfChannels = blendingDiscardImageRequest.getNoOfChannels();

			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String versionPath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
					+ File.separator + tabName;
			String channelPath = null;
			Map<String, List<String>> toDeleteImage = new HashMap<>();
			List<List<String>> lists = new ArrayList<>();
			for (int i = 0; i < noOfChannels; i++) {
				String channelName = ApplicationConstants.CHANNEL + (i + 1);
				channelPath = versionPath + File.separator + channelName;

				List<String> listOfFilesImages = filesStorageService.getListOfFilesImages(channelPath);
				List<String> filesImagesWithoutExtension = new ArrayList<>();
				for (String imageName : listOfFilesImages) {
					String likeStatement = imageName;
					likeStatement = likeStatement.substring(0, imageName.lastIndexOf(ApplicationConstants.DOT)+1);
					filesImagesWithoutExtension.add(likeStatement);
				}
				toDeleteImage.put(channelName, filesImagesWithoutExtension);
				filesImagesWithoutExtension.sort((e1, e2) -> e1.compareTo(e2));
				List<String> listString = new ArrayList<>(filesImagesWithoutExtension);
				lists.add(listString);
			}
			List<String> commonData = compare(lists);
			for (Map.Entry<String, List<String>> entry : toDeleteImage.entrySet()) {
				List<String> dd = (List<String>) CollectionUtils.removeAll(entry.getValue(), commonData);
				toDeleteImage.put(entry.getKey(), dd);
			}
			for (Map.Entry<String, List<String>> entry : toDeleteImage.entrySet()) {
				String channelPathToDeleteImage = versionPath + File.separator + entry.getKey();
				if (!entry.getValue().isEmpty()) {
					for (int i = 0; i < entry.getValue().size(); i++) {
						File[] imagetoDelete = getListOfFileWithoutExtension(channelPathToDeleteImage,
								entry.getValue().get(i));
						for (File file : imagetoDelete) {
							filesStorageService.deleteImage(channelPathToDeleteImage, file.getName());
						}
					}
				}
			}

			HttpOperationResponseBean response = new HttpOperationResponseBean();
			response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			response.setStatus(HttpStatus.OK);
			response.setMessage("Discarded The Images From Channel Successfully.");
			LOG.info("Discarded The Images From Channel Successfully.");
			return new ResponseEntity<>(response, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Error In Discard The Image");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.discard.the.image", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	public List<String> compare(List<List<String>> listOfFiles) {
		List<String> result = new ArrayList<>();
		while (isAllEmpty(listOfFiles)) {
			String max = "";
			for (List<String> list : listOfFiles) {
				if (!list.isEmpty()) {
					max = largeString(max, list.get(0));
				}else {
					return result;
				}
			}
			int count = 0;
			for (List<String> list : listOfFiles) {
				if (list.isEmpty()) {
					continue;
				}
				if (list.get(0).compareTo(max) != 0) {
					list.remove(0);
				} else {
					count++;
				}
			}
			if (count == listOfFiles.size()) {
				for (List<String> list : listOfFiles) {
					if (!list.isEmpty())
						list.remove(0);
				}
				result.add(max);
			}
		}
		return result;
	}

	public String largeString(String s1, String s2) {
		if (s1.compareTo(s2) < 0)
			return s2;
		else
			return s1;
	}

	public boolean isAllEmpty(List<List<String>> listOfFiles) {
		for (List<String> list : listOfFiles) {
			if (!list.isEmpty())
				return true;
		}
		return false;
	}

	public File[] getListOfFileWithoutExtension(String directoryPath, String fileName) {
		class OnlyFilter implements FilenameFilter {
			public boolean accept(File dir, String s) {
				if (s.startsWith(fileName))
					return true;
				return false;
			}
		}
		return new java.io.File(directoryPath).listFiles(new OnlyFilter());
	}
	  @Override
		public ResponseEntity<?> getListOfChannels(Long versionID,String tabName) {
			try {		
				GaudiAIVersion gaudiAIVersion = gaudiAIVersionRepository.getReferenceById(versionID);
				Long projectID = gaudiAIVersion.getProjectID();
				GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.getReferenceById(projectID);
				Long noOfChannel = gaudiAIProjects.getNoOfChannel();
				List<String> channelNames =new ArrayList<>();
				for (int i = 0; i < noOfChannel; i++) {
					channelNames.add(ApplicationConstants.CHANNEL+(i+1));
				}
				String[] array =  channelNames.toArray(new String[channelNames.size()]);
				LOG.info("Get List Channels Successfully.");
				return new ResponseEntity<>(array, HttpStatus.OK);
			} catch (Exception e) {
				LOG.error("Exception - Get List Of Channels.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("exception.get.list.Of.channels", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		}

		@Override
		public ResponseEntity<?> checkTheBlendingImageCountBasis(
				BlendingDiscardImageRequest blendingDiscardImageRequest) {
			try {
				Long versionID = blendingDiscardImageRequest.getVersionID();
				String tabName = blendingDiscardImageRequest.getTabName();
				if(tabName == null || tabName.equalsIgnoreCase("null") || tabName.equalsIgnoreCase("")) {
					LOG.error("TabName Is Empty");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,messageSource.getMessage("tabName.is.empty",null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				Long noOfChannels = blendingDiscardImageRequest.getNoOfChannels();
				List<BlendingTabImageCount> listBlendingTabImageCount = getTabCountDetails(noOfChannels, versionID,
						tabName);
				Boolean makeImageEqual = false;
				if (tabName.equals(ApplicationConstants.SOURCE) || tabName.equals(ApplicationConstants.TARGET)) {
					makeImageEqual = checkImageForTab(listBlendingTabImageCount, noOfChannels);
					if(noOfChannels == 1 && Boolean.TRUE.equals(makeImageEqual)) {
						makeImageEqual = true;
					}
				} else if (tabName.equals(ApplicationConstants.SOURCE_MASK)
						&& listBlendingTabImageCount.get(0).getTotalCount() == 0) {
					makeImageEqual = true;
				}
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				if (Boolean.TRUE.equals(makeImageEqual)) {
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					if (tabName.equals(ApplicationConstants.SOURCE) || tabName.equals(ApplicationConstants.TARGET)) {
						if(noOfChannels == 1 && Boolean.TRUE.equals(makeImageEqual)) {
							response.setMessage(messageSource.getMessage("please.upload.atleast.one.image", null,
									LocaleContextHolder.getLocale()));
							LOG.info("Please Upload At Least One Image.");
						}else {
						response.setMessage(messageSource.getMessage("please.make.images.equal.in.all.channel", null,
								LocaleContextHolder.getLocale()));
						LOG.info("Please Make Images Equal In All Channel.");
						}
					} else {
						response.setMessage(messageSource.getMessage("please.upload.atleast.one.image", null,
								LocaleContextHolder.getLocale()));
						LOG.info("Please Upload At Least One Image.");
					}
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("good.to.go.for.next.step", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Good To Go For Next Step.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				}

			} catch (Exception e) {
				LOG.error("Error In Check The Blending Image Count Basis.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("error.in.check.the.blending.image.count.basis", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		}

		public Boolean checkImageForTab(List<BlendingTabImageCount> listBlendingTabImageCount, Long noOfChannels) {
			int imageCountOfFirstChannel = listBlendingTabImageCount.get(0).getTotalCount();
			if (noOfChannels == 1 && listBlendingTabImageCount.get(0).getTotalCount() == 0) {
				return true;
			}
			for (int j = 1; j < listBlendingTabImageCount.size(); j++) {
				if (listBlendingTabImageCount.get(j).getTotalCount() != imageCountOfFirstChannel
						|| listBlendingTabImageCount.get(j).getTotalCount() == 0) {

					return true;
				}
			}
			return false;
		}
		public List<BlendingTabImageCount> getTabCountDetails(Long noOfChannels, Long versionID, String tabName) {
			List<BlendingTabImageCount> listBlendingTabImageCount = new ArrayList<>();
			
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String versionPath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
					+ File.separator + tabName;
			if(noOfChannels > 0) {
			for (int i = 0; i < noOfChannels; i++) {
				String channelName = ApplicationConstants.CHANNEL + (i + 1);
				String channelPath = versionPath + File.separator + channelName;
				List<String> listOfFilesImages;
				try {
					BlendingTabImageCount blendingTabImageCount = new BlendingTabImageCount();
					listOfFilesImages = filesStorageService.getListOfFilesImages(channelPath);
					blendingTabImageCount.setChannel(channelName);
					blendingTabImageCount.setTotalCount(listOfFilesImages.size());
					listBlendingTabImageCount.add(blendingTabImageCount);
				} catch (Exception e) {
					LOG.error("Error In getTabCountDetails. noOfChannels is more than zero.");
					throw new BadRequestException(e.getMessage());
				}
			}
			}else if(noOfChannels == 0){
				List<String> listOfFilesImages;
				try {
					BlendingTabImageCount blendingTabImageCount = new BlendingTabImageCount();
					listOfFilesImages = filesStorageService.getListOfFilesImages(versionPath);
					blendingTabImageCount.setTotalCount(listOfFilesImages.size());
					listBlendingTabImageCount.add(blendingTabImageCount);
				} catch (IOException e) {
					LOG.error("Error In getTabCountDetails. noOfChannels is equal to zero.");
					throw new BadRequestException(e.getMessage());
				}

			}
			return listBlendingTabImageCount;
		}
		@Override
		public ResponseEntity<?> deleteBlendingImages(DeleteImageRequest deleteBlendingImageRequest) {

			HttpOperationResponseBean response = null;
			try {
				Long versionID = deleteBlendingImageRequest.getVersionID();
				String tabName = deleteBlendingImageRequest.getTabName();
				String channelName = deleteBlendingImageRequest.getChannelName();
				List<String> listImageName = deleteBlendingImageRequest.getImageName();
				boolean deleteAllImage = false;
				LOG.info("Service Delete Blending Images.");
				if (listImageName == null || listImageName.isEmpty()) {
					deleteAllImage = true;
				}
				deleteTabWise(versionID, tabName,channelName, deleteAllImage, listImageName);
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("blending.image.deleted.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Blending Image Deleted Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} catch (Exception e) {
				LOG.error("Error In Delete Blending Image");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("error.in.delete.blending.image", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

		}

		private void deleteTabWise(Long versionID, String tabName,String channelName, boolean deleteAllImage, List<String> imageList) {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.IMAGE + File.separator + tabName;

			if (Boolean.TRUE.equals(deleteAllImage)) {
				List<String> listOfFolders = filesStorageService.fetchFolderNames(uploadImagePath);
				Long channelNos = (long) listOfFolders.size();
				filesStorageService.deleteFolder(uploadImagePath);
				if (tabName.equals(ApplicationConstants.SOURCE) || tabName.equals(ApplicationConstants.TARGET)) {
						applicationUtil.createChannelFolder(uploadImagePath, channelNos);

					} else {
						applicationUtil.createDirectory(uploadImagePath);
					}
				
			} else {
				 List<Integer> serchIndex = searchIndex(versionID, tabName,channelName, imageList);
					deleteImageByIndex(serchIndex, versionID,tabName);
			}
		}
		private List<Integer> searchIndex(Long versionID, String tabName,String channelName, List<String> imageList) {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			
			int index = 0;
			List<Integer> indexs = new ArrayList<>();
			if (tabName.equalsIgnoreCase(ApplicationConstants.SOURCE)
					|| tabName.equalsIgnoreCase(ApplicationConstants.TARGET)
					|| tabName.equalsIgnoreCase(ApplicationConstants.RESULT)) {
				String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + tabName+ File.separator + channelName;
					List<String> listImage2 = getImageListForder(uploadImagePath);
					Collections.sort(listImage2);

					for (String image : imageList) {
						index = Collections.binarySearch(listImage2, image);
							indexs.add(index);
					}

				List<Integer> collect = indexs.stream().distinct().collect(Collectors.toList());
				return collect;
			} else {
				String uploadImagePath2 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + tabName;
				File file = new File(uploadImagePath2);
				List<String> listImage2 = getImageListForder(file.getAbsoluteFile().toString());
				Collections.sort(listImage2);
				for (String image : imageList) {
					index = Collections.binarySearch(listImage2, image);
					indexs.add(index);
				}
			}
			List<Integer> collect = indexs.stream().distinct().collect(Collectors.toList());
			return collect;
		}

		private void deleteImageByIndex(List<Integer> indexList, Long versionID, String tabName) {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String uploadImagePath1 = null;
			String uploadImagePath2 = null;
			if (tabName.equalsIgnoreCase(ApplicationConstants.SOURCE)
					|| tabName.equalsIgnoreCase(ApplicationConstants.SOURCE_MASK)) {
				uploadImagePath1 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + ApplicationConstants.SOURCE;
				uploadImagePath2 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + ApplicationConstants.SOURCE_MASK;
			} else if (tabName.equalsIgnoreCase(ApplicationConstants.TARGET)
					|| tabName.equalsIgnoreCase(ApplicationConstants.TARGET_MASK)) {
				uploadImagePath1 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + ApplicationConstants.TARGET;
				uploadImagePath2 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + ApplicationConstants.TARGET_MASK;
			} else {
				uploadImagePath1 = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + ApplicationConstants.RESULT;
			}

			File file = new File(uploadImagePath1);
			File[] listFiles = file.listFiles();
			deleteChannelImages(listFiles, indexList);
			deleteFolderImage(uploadImagePath2, indexList);
		}

		private List<String> getImageListForder(String dir) {
			return Stream.of(new File(dir).listFiles()).map(File::getName).collect(Collectors.toList());
		}

		private void deleteChannelImages(File[] listFiles, List<Integer> indexList) {
			for (File file2 : listFiles) {
				deleteFolderImage(file2.getAbsoluteFile().toString(), indexList);
			}
		}

		private void deleteFolderImage(String path, List<Integer> indexList) {
			if (path != null) {
				List<String> list = getImageListForder(path);
				Collections.sort(list);
				List<String> deleteFile = new ArrayList<>();
				for (Integer indexs : indexList) {
					if (list.isEmpty() || list.size() <= indexs) {
						continue;
					}
					String image = list.get(indexs);
					deleteFile.add(image);
				}
				for (String file3 : deleteFile) {
					filesStorageService.deleteImage(path, file3);
				}
			}
		}
		
}

---------------------------------------------------------------------------------------------------------------
FilesStorageService.java
------------------------

package com.gaudi.ai.service;
import java.io.File;
import java.io.IOException;
import java.util.List;
import org.springframework.core.io.Resource;
import org.springframework.http.ResponseEntity;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import com.fasterxml.jackson.databind.JsonNode;
import com.gaudi.ai.request.PythonExportRequest;

public interface FilesStorageService {

	public Resource load(Long versionID, String tabName, String channelName, String filename);

	public ResponseEntity<?> loadAll(Long versionID, String tabName, String channelName);

	public ResponseEntity<?> loadExport(PythonExportRequest smartIds);

	public void saveImage(MultipartHttpServletRequest request);
	
	public Resource loadGanResult(Long versionID, String ganModuletabName,String tickName,String className,String channelName, String filename);

	public void deleteImage(String imagePath, String imageName);
	
	public List<String> getListOfFilesImages(String dir) throws IOException ;
	
	public List<String> getListOfFolder(String dir);
	
	public void deleteFolder(String channelPath);
	
	public JsonNode readJsonFile(String jsonFilePath ) throws IOException;

	public ResponseEntity<?> importModel(MultipartHttpServletRequest request);
	
	public List<String> fetchFolderNames(String dir);

	public void searchForImageNames(File rootDirectory, List<String> listOfFilesImages);
}

--------------------------------------------------------------------------------------------------
FilesStorageServiceImpl.java
------------------------------

package com.gaudi.ai.service;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale.LanguageRange;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.exception.JDBCConnectionException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.CannotCreateTransactionException;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.servlet.mvc.method.annotation.MvcUriComponentsBuilder;

import com.fasterxml.jackson.databind.*;
import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.constants.PythonServiceEndPointConstant;
import com.gaudi.ai.controller.BlendingController;
import com.gaudi.ai.exception.AppError;
import com.gaudi.ai.exception.ServiceUnavailableException;
import com.gaudi.ai.model.GanChannelImage;
import com.gaudi.ai.model.GanChannels;
import com.gaudi.ai.model.GanDataset;
import com.gaudi.ai.model.GanTestWizard;
import com.gaudi.ai.model.GanTrainingWizard;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.GanChannelImageRepository;
import com.gaudi.ai.repository.GanChannelsRepository;
import com.gaudi.ai.repository.GanDatasetRepository;
import com.gaudi.ai.repository.GanTestWizardRepository;
import com.gaudi.ai.repository.GanTrainingWizardRepository;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import com.gaudi.ai.request.FileInfo;
import com.gaudi.ai.request.PythonExportRequest;
import com.gaudi.ai.response.*;
import com.gaudi.ai.util.ApplicationUtil;

@Service
public class FilesStorageServiceImpl implements FilesStorageService {

	private static final Logger LOG = LogManager.getLogger(FilesStorageServiceImpl.class);

	@Autowired
	private GaudiAIVersionRepository gaudiAIVersionRepository;

	@Autowired
	private GanChannelsRepository ganChannelsRepository;

	@Autowired
	private GanChannelImageRepository ganChannelImageRepository;

	@Autowired
	private GanTrainingWizardRepository ganTrainingWizardRepository;
	
	@Autowired
	private GanTestWizardRepository ganTestWizardRepository;
	
	@Autowired
	private GanDatasetRepository ganDatasetRepository;
	
    @Autowired
	ApplicationUtil applicationUtil;
    
	@Autowired
	private WebClient client;


	@Value("${basefolder.path}") 
	String baseFolderpath;

	@Value("#{'${gaudiServiceUrl}'}")
	String gaudiServiceUrl;

	@Autowired
	private MessageSource messageSource;

	@Override
	public void saveImage(MultipartHttpServletRequest request) {
		List<String> fileNames = new ArrayList<>();
		if (request.getParameter(ApplicationConstants.VERSIONID) != null) {
			Long versionID = (long) Integer.parseInt(request.getParameter(ApplicationConstants.VERSIONID));
			String tabName = request.getParameter(ApplicationConstants.TABNAME);
			String channelName = request.getParameter(ApplicationConstants.CHANNELNAME);
			LOG.info("Upload Image File versionID - {} , tabName - {}", versionID, tabName);

			Path root = null;
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);

			String uploadImagePath = null;
			Long datasetID = null;
			if (gaudiAIVersion.get(0).getDatasetID() != null) {
				datasetID = gaudiAIVersion.get(0).getDatasetID();
				GanDataset ganDataset=ganDatasetRepository.getDatasetByDatasetID(datasetID);
				if (ganDataset != null) {
					uploadImagePath = ganDataset.getDatasetPath()+ File.separator + tabName;
				}
			} else {
				if(channelName != null && channelName.contains(ApplicationConstants.CHANNEL)) {
					uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
							+ File.separator + tabName+ File.separator + channelName;
				}else {
					uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
							+ File.separator + tabName;
				}

			}
			LOG.info("uploadImagePath--------------------------{}", uploadImagePath);
			List<GanChannelImage> listGanChannelImage = new ArrayList<>();
			
			List<MultipartFile> mpf1 = removeDuplicateImage(request,uploadImagePath);
			for (MultipartFile multipartFile : mpf1) {
				GanChannelImage ganChannelImage = new GanChannelImage();
				Boolean existingItem = true;
				try (InputStream inputStream = multipartFile.getInputStream()) {
					root = Paths.get(uploadImagePath);
					File file = new File(uploadImagePath + File.separator + multipartFile.getOriginalFilename());
					if (file.exists()) {
						existingItem = false;
					}
					
					Files.copy(inputStream, root.resolve(multipartFile.getOriginalFilename()),
							StandardCopyOption.REPLACE_EXISTING);

				} catch (Exception e) {
					e.printStackTrace();
					throw new RuntimeException(messageSource.getMessage("could.not.store.the.file.error", null,
							LocaleContextHolder.getLocale()) + e.getMessage());
				}
				if (gaudiAIVersion.get(0).getDatasetID() != null && !Boolean.FALSE.equals(existingItem)) {
					ganChannelImage.setImageName(multipartFile.getOriginalFilename());
					ganChannelImage.setDatasetID(datasetID);
					GanChannels ganChannels = ganChannelsRepository.findGanChannelsByChannelNameDatasetID(tabName, datasetID);
					ganChannelImage.setGanChannels(ganChannels);
					ganChannelImage.setLabelledYN(ApplicationConstants.NO);
					ganChannelImage.setCreatedDate(new Date(System.currentTimeMillis()));
					ganChannelImage.setIsActive(ApplicationConstants.YES);
					listGanChannelImage.add(ganChannelImage);
				}
				fileNames.add(multipartFile.getOriginalFilename());
			}

			if (gaudiAIVersion.get(0).getDatasetID() != null)
				ganChannelImageRepository.saveAll(listGanChannelImage);

		}else {
			throw new RuntimeException(
					messageSource.getMessage("version.id.is.null", null, LocaleContextHolder.getLocale()));
		}
	}
public List<MultipartFile> removeDuplicateImage(MultipartHttpServletRequest request,String uploadImagePath){
	List<MultipartFile> mpf = request.getFiles(ApplicationConstants.FILE);
	List<MultipartFile> mpf1 = new ArrayList<>();
	LOG.info("mpf : {}",mpf.size());
	List<String> imageListFromRequest = new ArrayList<>();
	for (MultipartFile multipartFile : mpf) {
		String withoutExtension = multipartFile.getOriginalFilename();
		withoutExtension = withoutExtension.substring(0, multipartFile.getOriginalFilename().lastIndexOf("."));
		imageListFromRequest.add(withoutExtension);
	}
	 Set<String> duplicateImages = imageListFromRequest
             .stream()
             .filter(image -> Collections.frequency(imageListFromRequest, image) > 1)
             .collect(Collectors.toSet());
	List<String> imageListFromFolder = new ArrayList<>();
	File[] listFiles = new File(uploadImagePath).listFiles();
	for (int i = 0; i < listFiles.length; i++) {
		if (listFiles[i].isFile()) {
			String fileName = listFiles[i].getName();
			fileName = fileName.substring(0, listFiles[i].getName().lastIndexOf("."));
			imageListFromFolder.add(fileName);
		}
	}
	LOG.info("mpf : {}",mpf.size());
	for (int z = 0; z < mpf.size(); z++) {
		String withoutExtension1 = mpf.get(z).getOriginalFilename();
		withoutExtension1 = withoutExtension1.substring(0,
				mpf.get(z).getOriginalFilename().lastIndexOf("."));
		Boolean imageFromFolderStatus = false;
		Boolean imageFromRequestStatus = false;
		for (String imageData : duplicateImages) {
			if (imageData.equals(withoutExtension1)) {
				imageFromRequestStatus = true;
			}
		}
		
		if (!imageListFromFolder.isEmpty()) {
			for (int i = 0; i < imageListFromFolder.size(); i++) {
				if (imageListFromFolder.get(i).equals(withoutExtension1)) {
					imageFromFolderStatus = true;
				}
			}
		}
		
		if (Boolean.FALSE.equals(imageFromFolderStatus) && Boolean.FALSE.equals(imageFromRequestStatus)) {
			mpf1.add(mpf.get(z));
		}
	}
	LOG.info("mpf1 : {}",mpf1.size());
	return mpf1;
	
}
	@Override
	public Resource load(Long versionID, String tabName, String channelName, String filename) {
		String variablePath = null;
		List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
		if (!gaudiAIVersion.isEmpty()) {
			if (gaudiAIVersion.get(0).getDatasetID() != null && tabName.equalsIgnoreCase(ApplicationConstants.RESULT)) {
				variablePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
						+ File.separator + tabName;
			} else if (gaudiAIVersion.get(0).getDatasetID() != null) {
				GanChannels ganChannels = ganChannelsRepository.findGanChannelsByChannelNameDatasetID(channelName,
						gaudiAIVersion.get(0).getDatasetID());
				if (ganChannels != null) {
					variablePath = ganChannels.getChannelPath();
				}
			} else {
				if(channelName != null && channelName.contains(ApplicationConstants.CHANNEL)) {
					variablePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
							+ File.separator + tabName+ File.separator + channelName;
					
				}else {
					variablePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
							+ File.separator + tabName;
				}

			}

		} else if (tabName.equalsIgnoreCase(ApplicationConstants.EXPORT)) {
			variablePath = baseFolderpath + File.separator + tabName;

		}
		Path root = Paths.get(variablePath);
		try {
			Path file = root.resolve(filename);
			Resource resource = new UrlResource(file.toUri());

			if (resource.exists() || resource.isReadable()) {
				return resource;
			} else {
				throw new RuntimeException(
						messageSource.getMessage("could.not.read.the.file", null, LocaleContextHolder.getLocale()));
			}
		} catch (MalformedURLException e) {
			e.printStackTrace();
			throw new RuntimeException(
					messageSource.getMessage("error", null, LocaleContextHolder.getLocale()) + e.getMessage());
		}
	}

	@Override
	public Resource loadGanResult(Long versionID, String ganModuletabName, String tickName, String className,
			String channelName, String filename) {
		try {
			String variablePath = null;
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if (!gaudiAIVersion.isEmpty()) {
				String versionPath = gaudiAIVersion.get(0).getVersionPath();
				List<GanTrainingWizard> listGanTrainingWizard = ganTrainingWizardRepository
						.findBygaudiVersionId(versionID);
				String prefixPath = versionPath + File.separator + ApplicationConstants.IMAGE + File.separator
						+ ApplicationConstants.RESULT + File.separator + tickName + File.separator + ganModuletabName
						+ File.separator;
				String suffix = File.separator + className + File.separator + channelName;
				if (ganModuletabName.equalsIgnoreCase(ApplicationConstants.TRAIN_MODULE)
						&& !listGanTrainingWizard.isEmpty()) {
					String postProcessAutoFilter = listGanTrainingWizard.get(0).getPostProcessAutoFilter();
					variablePath = postProcessAutoFilter != null
							&& postProcessAutoFilter.equalsIgnoreCase(ApplicationConstants.YES)
									? prefixPath + ApplicationConstants.FILTER + suffix
									: prefixPath + ApplicationConstants.IMAGES + suffix;
				} else if (ganModuletabName.equalsIgnoreCase(ApplicationConstants.TEST_MODULE)) {
					
					GanTestWizard ganTestWizard = ganTestWizardRepository
							.findLatestGanTestWizardByGaudiVersionId(versionID, tickName);
					String testAutoFilter = ganTestWizard.getTestAutoFilter();
					variablePath = testAutoFilter != null && testAutoFilter.equalsIgnoreCase(ApplicationConstants.YES)
							? prefixPath + ApplicationConstants.FILTER + suffix
							: prefixPath + ApplicationConstants.IMAGES + suffix;
				} 
			}
			Path root = Paths.get(variablePath);
			
			try {
				Path file = root.resolve(filename);
				Resource resource = new UrlResource(file.toUri());

				if (resource.exists() || resource.isReadable()) {
					return resource;
				} else {
					throw new RuntimeException(
							messageSource.getMessage("could.not.read.the.file", null, LocaleContextHolder.getLocale()));
				}
			} catch (MalformedURLException e) {
				throw new RuntimeException(
						messageSource.getMessage("error", null, LocaleContextHolder.getLocale()) + e.getMessage());
			}
		} catch (Exception e) {
			throw new RuntimeException(
					messageSource.getMessage("error", null, LocaleContextHolder.getLocale()) + e.getMessage());
		}
	}

	@Override
	public ResponseEntity<?> loadAll(Long versionID, String tabName, String channelName) {
		List<FileInfo> fileInfos = null;
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if (!gaudiAIVersion.isEmpty()) {
				String variablePath = null;

				if (gaudiAIVersion.get(0).getDatasetID() != null) {
					GanChannels ganChannels = ganChannelsRepository.findGanChannelsByChannelNameDatasetID(tabName,
							gaudiAIVersion.get(0).getDatasetID());
					if (ganChannels != null) {
						variablePath = ganChannels.getChannelPath();
					}
				} else {
					if((tabName.equals(ApplicationConstants.SOURCE) || tabName.equals(ApplicationConstants.TARGET)) && (channelName == null || channelName.equalsIgnoreCase(ApplicationConstants.NULL))) {
						return ResponseEntity.status(HttpStatus.NO_CONTENT).body(null);
					}
					if(channelName != null && channelName.contains(ApplicationConstants.CHANNEL)) {
						variablePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
								+ File.separator + tabName+ File.separator + channelName;
					}else {
						variablePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
								+ File.separator + tabName;
					}
				}
				LOG.info("VariablePath -----------------{} ", variablePath);
				File file = new File(variablePath);
				if (!file.exists()) {
					return ResponseEntity.status(HttpStatus.NO_CONTENT).body(null);
					
				}
				fileInfos = processLoadAll(variablePath).map(path -> {
					String filename = path.getFileName().toString();
					String url = MvcUriComponentsBuilder.fromMethodName(BlendingController.class,
							ApplicationConstants.GETFILE, versionID, tabName,channelName, path.getFileName().toString()).build()
							.toString();

					return new FileInfo(filename, versionID, tabName,channelName, url);
				}).collect(Collectors.toList());
			} else {
				LOG.info("gaudi AI Version is empty");
				return ResponseEntity.status(HttpStatus.NO_CONTENT).body(null);
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		return ResponseEntity.status(HttpStatus.OK).body(fileInfos);
	}

	private Stream<Path> processLoadAll(String pathVersion) {
		try {
			Path root = Paths.get(pathVersion);
			return Files.walk(root, 1).filter(path -> !path.equals(root)).map(root::relativize);

		} catch (IOException e) {
			throw new RuntimeException(
					messageSource.getMessage("could.not.read.the.file", null, LocaleContextHolder.getLocale()));
		}
	}

	public ResponseEntity<?> loadExport(PythonExportRequest pythonExportRequest) {
		PythonCompressResponse responsePath = null;
		try {
		this.client = WebClient.builder().build();
		List<LanguageRange> header = applicationUtil.getHeader();
		responsePath = client.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.ZIP_IT)
				.headers(h->{
					h.setAcceptLanguage(header);
				}).body(BodyInserters.fromValue(pythonExportRequest)).retrieve().bodyToMono(PythonCompressResponse.class)
				.block();
		String zipfilename = responsePath.getZippedOutputPath();
		List<FileInfo> fileInfos = null;
		String variablePath = baseFolderpath + File.separator + ApplicationConstants.EXPORT;
		fileInfos = processLoadAll(variablePath)
				.filter(path -> path.getFileName().toString().equalsIgnoreCase(zipfilename)).map(path -> {
					String filename = path.getFileName().toString();
					String url = MvcUriComponentsBuilder
							.fromMethodName(BlendingController.class, ApplicationConstants.GETFILE, 0L,
									ApplicationConstants.EXPORT,"null", path.getFileName().toString())
							.build().toString();
					return new FileInfo(filename, 0L, ApplicationConstants.EXPORT,null, url);
				}).collect(Collectors.toList());
		return ResponseEntity.status(HttpStatus.OK).body(fileInfos);
		} catch (WebClientResponseException | WebClientRequestException e) {
			LOG.error("Error in Response From Python");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.response.from.python", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE,
					messageSource.getMessage("server.down.try.afterSome.time", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (JDBCConnectionException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (CannotCreateTransactionException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (Exception e) {
			LOG.error("Error In Save Generated Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.generated.json", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public void deleteImage(String imagePath, String imageName) {
		Path imagesPath = Paths.get(imagePath + File.separator + imageName);
		try {
			File file = new File(imagePath +File.separator +imageName);
			if (file.exists()) {
			Files.delete(imagesPath);
			}
		} catch (IOException e) {
			LOG.error("Unable to delete " + imagesPath.toAbsolutePath().toString() + " due to...");
		}
	}
	@Override
	public List<String> fetchFolderNames(String dir) {
		return Stream.of(new File(dir).listFiles()).filter(file -> file.isDirectory()).map(File::getName)
				.collect(Collectors.toList());
	}
	@Override
	public List<String> getListOfFilesImages(String dir) throws IOException {
		try (Stream<Path> stream = Files.list(Paths.get(dir))) {
			return stream.filter(file -> !Files.isDirectory(file)).map(Path::getFileName)
					.filter(getName -> !getName.endsWith(ApplicationConstants.DB)).map(Path::toString)
					.collect(Collectors.toList());
		}
	}

	@Override
	public List<String> getListOfFolder(String dir) {
		List<String> finalFolderList = null;
		try {
			finalFolderList= listFilesNewlyFirst(dir);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return finalFolderList;
	}
	private List<String> listFilesNewlyFirst(String directoryPath) throws IOException {
	    final List<File> files = Arrays.asList(new File(directoryPath).listFiles());
	    List<String> finalFolder= new ArrayList<>();
	    final Map<String, Long> constantLastModifiedTimes = new HashMap<String,Long>();
	    for (File f : files) {
	    	File jsonFile=new File(f.getAbsolutePath() +File.separator +ApplicationConstants.MODEL_DATA_JSON);
	    	if(jsonFile.exists()) {
	        constantLastModifiedTimes.put(f.getName(),jsonFile.lastModified());
	    	}
	    }
	    
	    Map<String, Long> sortedByTime = constantLastModifiedTimes.entrySet()
                .stream()
                .sorted(Map.Entry.comparingByValue())
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
	    
	    for (Map.Entry<String,Long> entry : sortedByTime.entrySet()) 
	    	finalFolder.add((String) entry.getKey());

	    return finalFolder;
	}

	@Override
	public void deleteFolder(String channelPath) {
		File file = new File(channelPath);
		if (file.exists()) {
			if (file.isDirectory()) {
				try {
					FileUtils.deleteDirectory(file);
				} catch (IOException e) {
					e.printStackTrace();
					LOG.error("Unable to delete folder" + file.toString() + " due to...");
				}
				LOG.info("FInd The File Dirctory and Delete directory ");
			} else {
				file.delete();
				LOG.info("FInd The File  and Delete File ");
			}
		}
	}
	@Override
    public JsonNode readJsonFile(String jsonFilePath) throws IOException {
        Path path = Paths.get(jsonFilePath);
        byte[] jsonData = Files.readAllBytes(path);
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode json = objectMapper.readTree(jsonData);
        return json;
    }

	@Override
	public ResponseEntity<?> importModel(MultipartHttpServletRequest request) {

		try {
			if (request.getParameter(ApplicationConstants.VERSIONID) != null
					&& !request.getParameter(ApplicationConstants.VERSIONID).equalsIgnoreCase("")) {
				Long versionID = (long) Integer.parseInt(request.getParameter(ApplicationConstants.VERSIONID));
				String folderName = request.getParameter(ApplicationConstants.FOLDER_NAME);
				if(folderName == null) {
					LOG.error("Folder Name Is Null.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("folder.name.is.null", null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				LOG.info("Upload Image File versionID - {} , folderName - {}", versionID, folderName);
				List<MultipartFile> mpf = request.getFiles(ApplicationConstants.FILE);
				LOG.info("mpf.size() : {}", mpf.size());
				Path root = null;
				List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
				String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
						+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT + File.separator
						+ folderName;
				LOG.info("uploadImagePath--------------------------{}", uploadImagePath);
				File file = new File(uploadImagePath);

				if (file.exists()) {
					LOG.error(folderName + "this folder name is already exist please provide new name of folder");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							folderName + messageSource.getMessage("this.folder.name.is.already.exist.please.provide.new.name.of.folder", null,
									LocaleContextHolder.getLocale()), null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				} else {
					applicationUtil.createFolder(uploadImagePath);
				}
				Boolean successStatus = false;
				for (MultipartFile multipartFile : mpf) {
					try (InputStream inputStream = multipartFile.getInputStream()) {
						root = Paths.get(uploadImagePath);
						Files.copy(inputStream, root.resolve(multipartFile.getOriginalFilename()),
								StandardCopyOption.REPLACE_EXISTING);
						successStatus = true;
					} catch (Exception e) {
						throw new RuntimeException(messageSource.getMessage("could.not.store.the.file.error", null,
								LocaleContextHolder.getLocale()) + e.getMessage());
					}
				}
				if (Boolean.TRUE.equals(successStatus)) {
					HttpOperationResponseBean response = null;
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("file.uploaded.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("file uploaded successfully");
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					LOG.error("import model failure");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("import.model.failure", null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			} else {
				LOG.error("VersionID Is Null.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("version.id.is.null", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Could not store the file");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("could.not.store.the.file.error", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}
	
	public  void searchForImageNames(File directory, List<String> listOfFilesImages) {
        File[] files = directory.listFiles();
        if (files != null) { 
            for (File file : files) {
                if (file.isDirectory()) {
                    searchForImageNames(file, listOfFilesImages);
                }
                else {
                    String fileName = file.getName();
                    listOfFilesImages.add(fileName);
                }
            }
        }
    }
	
}
------------------------------------------------------------------------------------------------------------------------------
GANService.java
---------------
package com.gaudi.ai.service;
import com.gaudi.ai.request.DeselectionOfDatasetRequest;
import com.gaudi.ai.request.GanClassRequest;
import com.gaudi.ai.request.GanClassUpdateRequest;
import com.gaudi.ai.request.GanDatasetRequest;
import com.gaudi.ai.request.GanDiscardImageRequest;
import com.gaudi.ai.request.GanTestWizardRequest;
import com.gaudi.ai.request.GanTrainingWizardRequest;
import com.gaudi.ai.request.LabelTheImageRequest;
import com.gaudi.ai.request.UnLabelTheImageRequest;
import com.gaudi.ai.response.GanDefaultModelClassAndChannel;
import com.gaudi.ai.response.ListOfGanResultResponse;
import org.springframework.http.ResponseEntity;

import javax.validation.Valid;
import java.util.List;


public interface GANService {

	ResponseEntity<?> createGanClass(GanClassRequest ganClassRequest);

	ResponseEntity<?> getListOfGANClass(Long versionID);

	ResponseEntity<?> updateGANClass(GanClassUpdateRequest ganClassUpdateRequest);

	ResponseEntity<?> getListOfGANChannel(Long versionID);
	
	ResponseEntity<?> saveGanTrainingWizard(GanTrainingWizardRequest gyanTrainingWizardRequest);

	ResponseEntity<?> getGanTrainingData(Long tariningID);
	
	ResponseEntity<?> updateGanTrainingData(GanTrainingWizardRequest ganTrainingWizardRequest);
	
    ResponseEntity<?> getListOfChannelImage(int pageSize, int pageNum, String sortField, String sortDir, Long datasetID,Long  channelID,String filter);

    ResponseEntity<?> getGANParticularVersion(Long versionID);

	ResponseEntity<?> createGanDataset(@Valid GanDatasetRequest ganDatasetRequest);

	ResponseEntity<?> getListOfGANDataset(Long userID);
	
	ResponseEntity<?> createChannel(Long datasetID);

	ResponseEntity<?> deleteChannel(Long channelID, Long datasetID);

	ResponseEntity<?> labelTheImage(LabelTheImageRequest labelTheImageRequest);

	ResponseEntity<?> getParticularGanDataSet(Long datasetID);

	ResponseEntity<?> selectedDatasetForVersion( DeselectionOfDatasetRequest deselectionOfDatasetRequest);
	
	ResponseEntity<?> getListOfLabeledClass(Long datasetID);

	ResponseEntity<?> processDefaultGANResult(Long versionID, String ganModuletabName);

	ResponseEntity<?> deleteGANClass(Long classID);

	ResponseEntity<?> pauseProcess(String smartID);
	
	ResponseEntity<?> resumeTrainWizard(Long trainingId);

	ResponseEntity<?> discardTheimage(GanDiscardImageRequest ganDiscardImageRequest);

	ResponseEntity<?> getListOfGANResultFolder(Long versionID);

	ResponseEntity<?> deSelectionDatasetForVersion( DeselectionOfDatasetRequest deselectionOfDatasetRequest);
	
    ResponseEntity<?> saveGanTestWizard(GanTestWizardRequest ganTestWizardRequest);
	
	ResponseEntity<?> getGanTestWizard(Long testID);

	ResponseEntity<?> imageDimension(Long datasetID);

	ResponseEntity<?> deleteOutputFolder(Long versionID,String outputFolderName);

	ResponseEntity<?> deleteImageFromOutputFolder(Long versionID,String ganModuletabName, String outputFolderName, String className,
			String imageName);

	ResponseEntity<?> unLabelTheImage(UnLabelTheImageRequest unLabelTheImageRequest);
	
	ResponseEntity<?> saveGanTrainingSetting(GanTrainingWizardRequest ganSaveSettingRequest);

	ResponseEntity<?> getGanTrainingSettingData(Long settingID,Long datasetID);
	
	ResponseEntity<?> updateTrainingSettingData(GanTrainingWizardRequest ganSaveSettingRequest);

	ResponseEntity<?> getListOfGANTrainingSetting(Long userID);

	ResponseEntity<?> deleteGanTrainingSetting(Long settingID);

	ResponseEntity<?> deleteDataset(Long datasetID);

	ResponseEntity<?> getListOfGANClassFromJson(Long versionID, String folderName);

	ResponseEntity<?> getListOfGANChannelFromJson(Long versionID, String folderName);
	
	ResponseEntity<List<String>> getListOfDefaultModelName();
	
	ResponseEntity<GanDefaultModelClassAndChannel> getListOfGANDefaultModelChannelAndClassFromJson(String folderName);

	ListOfGanResultResponse processGANResult(Long versionId, String tabName, String tickName, String className,
											 String channelName, int skip, int rows);
}
--------------------------------------------------------------------------------------------------------------------------
GANServiceImpl.java
--------------------
package com.gaudi.ai.service;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Locale.LanguageRange;
import java.util.SortedSet;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.exception.JDBCConnectionException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.CannotCreateTransactionException;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientException;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.server.ServerErrorException;

import com.fasterxml.jackson.databind.*;
import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.constants.PythonServiceEndPointConstant;
import com.gaudi.ai.exception.AppError;
import com.gaudi.ai.exception.BadRequestException;
import com.gaudi.ai.exception.ServiceUnavailableException;
import com.gaudi.ai.model.GanChannelImage;
import com.gaudi.ai.model.GanChannels;
import com.gaudi.ai.model.GanClass;
import com.gaudi.ai.model.GanDataset;
import com.gaudi.ai.model.GanTestWizard;
import com.gaudi.ai.model.GanTrainWizardSetting;
import com.gaudi.ai.model.GanTrainingWizard;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.GanChannelImageRepository;
import com.gaudi.ai.repository.GanChannelsRepository;
import com.gaudi.ai.repository.GanClassRepository;
import com.gaudi.ai.repository.GanDatasetRepository;
import com.gaudi.ai.repository.GanSaveSettingRepository;
import com.gaudi.ai.repository.GanTestWizardRepository;
import com.gaudi.ai.repository.GanTrainingWizardRepository;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import com.gaudi.ai.request.AugmentationSetting;
import com.gaudi.ai.request.DataSettings;
import com.gaudi.ai.request.DeselectionOfDatasetRequest;
import com.gaudi.ai.request.GanClassRequest;
import com.gaudi.ai.request.GanClassUpdateRequest;
import com.gaudi.ai.request.GanDatasetRequest;
import com.gaudi.ai.request.GanDiscardImageRequest;
import com.gaudi.ai.request.GanTestJsonRequest;
import com.gaudi.ai.request.GanTestWizardRequest;
import com.gaudi.ai.request.GanTrainingJsonRequest;
import com.gaudi.ai.request.GanTrainingWizardRequest;
import com.gaudi.ai.request.LabelTheImageRequest;
import com.gaudi.ai.request.NetworkParams;
import com.gaudi.ai.request.OptimizerSettings;
import com.gaudi.ai.request.PathSetting;
import com.gaudi.ai.request.PostProcess;
import com.gaudi.ai.request.PythonGanTestRequest;
import com.gaudi.ai.request.PythonGanTrainingRequest;
import com.gaudi.ai.request.PythonSmartIDrequest;
import com.gaudi.ai.request.TrainingParameters;
import com.gaudi.ai.request.UnLabelTheImageRequest;
import com.gaudi.ai.response.DefaultGanResultResponse;
import com.gaudi.ai.response.GanDatasetCreationResponse;
import com.gaudi.ai.response.GanDefaultModelClassAndChannel;
import com.gaudi.ai.response.GanTestWizardResponse;
import com.gaudi.ai.response.GanTrainingResponse;
import com.gaudi.ai.response.GaudiAIGANVersionData;
import com.gaudi.ai.response.HttpOperationResponseBean;
import com.gaudi.ai.response.IListOfTestData;
import com.gaudi.ai.response.ImageProperties;
import com.gaudi.ai.response.ListOfChannelResponse;
import com.gaudi.ai.response.ListOfClassResponse;
import com.gaudi.ai.response.ListOfGanChannel;
import com.gaudi.ai.response.ListOfGanClass;
import com.gaudi.ai.response.ListOfGanImageResponse;
import com.gaudi.ai.response.ListOfGanResultResponse;
import com.gaudi.ai.response.ListOfGanTrainingSettings;
import com.gaudi.ai.response.ParticularGanDatasetResponse;
import com.gaudi.ai.response.PythonSucessResponse;
import com.gaudi.ai.util.ApplicationUtil;
import com.google.gson.Gson;
import ij.IJ;
import ij.ImagePlus;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.hibernate.exception.JDBCConnectionException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.CannotCreateTransactionException;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientException;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.server.ServerErrorException;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale.LanguageRange;
import java.util.SortedSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class GANServiceImpl implements GANService {

	private static final Logger LOG = LogManager.getLogger(GANServiceImpl.class);

	@Autowired
	private GanClassRepository ganClassRepository;

	@Autowired
	private GanChannelsRepository ganChannelsRepository;

	@Autowired
	private GanTrainingWizardRepository ganTrainingWizardRepository;

	@Autowired
	private GaudiAIVersionRepository gaudiAIVersionRepository;

	@Autowired
	private GanDatasetRepository ganDatasetRepository;

	@Autowired
	private MessageSource messageSource;

	@Autowired
	private GanChannelImageRepository ganChannelImageRepository;

	@Autowired
	private GanTestWizardRepository ganTestWizardRepository;

	@Autowired
	private BlendingServiceImpl blendingServiceImpl;

	@Autowired
	private ApplicationUtil applicationUtil;

	@Autowired
	private WebClient webClient;

	@Autowired
	FilesStorageService storageService;
	
	@Autowired
	private GanSaveSettingRepository  ganSaveSettingRepository;

	@Value("#{'${gaudiServiceUrl}'}")
	String gaudiServiceUrl;

	@Value("${basefolder.path}")
	String baseFolderpath;

	@Override
	@Transactional
	public ResponseEntity<?> createGanClass(GanClassRequest ganClassRequest) {
		HttpOperationResponseBean response = null;
		GanClass savedGanClass = null;
		try {
			if(ganClassRequest.getDatasetID() == null) {

				LOG.error("Please load dataset and then create class.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage("please.load.dataset.and.then.create.class", null, LocaleContextHolder.getLocale()) ,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			
			}
			
			Long classNameExistCount = ganClassRepository.countByDatasetIDAndClassName(ganClassRequest.getDatasetID(),
					ganClassRequest.getClassName());
			if (classNameExistCount > 0) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 302,
						ApplicationConstants.FOUND, messageSource.getMessage("duplicate.class.name.entered.please.enter.different.class.name", null, LocaleContextHolder.getLocale()), null);
				LOG.error("Duplicate Class Name Entered. Please Enter Different Class Name.");
				return new ResponseEntity<>(errorResponse, HttpStatus.FOUND);
			}
			
			GanClass ganClass = new GanClass();
			ganClass.setDatasetID(ganClassRequest.getDatasetID());
			ganClass.setClassName(ganClassRequest.getClassName());
			ganClass.setIsActive(ApplicationConstants.YES);
			ganClass.setCreatedBy(ganClassRequest.getCreatedBy());
			ganClass.setCreatedDate(new Date(System.currentTimeMillis()));
			savedGanClass = ganClassRepository.save(ganClass);
			if (savedGanClass.getClassID() > 0) {
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("gan.class.created.successfully", null, LocaleContextHolder.getLocale()));
				LOG.info("GAN Class created Successfully.");
			} else {
				LOG.error("GAN Class Creatation Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
								"exception.gan.class.creation.failure", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Exception - GAN Class Creatation Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.gan.class.creation.failure",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public ResponseEntity<?> getListOfGANClass(Long datasetID) {
		try {
			List<GanClass> listGanClass = ganClassRepository.findListOfGanClassByDatasetID(datasetID);
			if (!listGanClass.isEmpty()) {
				ListOfClassResponse listOfClassResponse = new ListOfClassResponse();
				listOfClassResponse.setGanClass(listGanClass);
				listOfClassResponse.setTotalGANCLassCount(listGanClass.size());
				return new ResponseEntity<>(listOfClassResponse, HttpStatus.OK);
			} else {
				LOG.error("No GAN Class Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("exception.no.gan.class.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Exception - Get GAN Class Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("exception.get.gan.class.failure", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateGANClass(GanClassUpdateRequest ganClassUpdateRequest) {
		HttpOperationResponseBean response = null;
		try {
			List<GanClass> listOfClass = ganClassRepository.findByClassID(ganClassUpdateRequest.getClassID());
			if (!listOfClass.isEmpty()) {
				Long classNameExistCount = ganClassRepository.countByDatasetIDAndClassName(listOfClass.get(0).getDatasetID(),
						ganClassUpdateRequest.getClassName());
				if (classNameExistCount > 0) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 302,
							ApplicationConstants.FOUND, messageSource.getMessage("duplicate.class.name.entered.please.enter.different.class.name", null, LocaleContextHolder.getLocale()), null);
					LOG.error("Duplicate Class Name Entered. Please Enter Different Class Name.");
					return new ResponseEntity<>(errorResponse, HttpStatus.FOUND);
				}
				ganClassRepository.updateGANClass(ganClassUpdateRequest.getClassName(),
						new Date(System.currentTimeMillis()), ganClassUpdateRequest.getClassID());
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("gan.class.updated.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("GAN Class Updated Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("No GAN Class Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("exception.no.gan.class.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Exception - GAN Class Update Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.gan.class.update.failure",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ResponseEntity<?> getListOfGANChannel(Long datasetID) {
		try {
			List<GanChannels> listGanChannels = ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);
			ListOfChannelResponse listOfChannelResponse = new ListOfChannelResponse();
			if (!listGanChannels.isEmpty()) {
				listOfChannelResponse.setGanChannel(listGanChannels);
				listOfChannelResponse.setTotalGanChannelsCount(listGanChannels.size());
				return new ResponseEntity<>(listOfChannelResponse, HttpStatus.OK);
			} else {
				return new ResponseEntity<>(listOfChannelResponse, HttpStatus.OK);
			}
		} catch (Exception e) {
			LOG.error("Exception - Get List Of GAN Channel Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
							"exception.get.list.of.gan.channel.failure", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> saveGanTrainingWizard(GanTrainingWizardRequest ganTrainingWizardRequest) {
		LOG.info("GanTrainingServiceImpl saveGanTrainingWizard {} ganTrainingWizardRequest ", ganTrainingWizardRequest);
		GanTrainingWizard saveganTrainingWizard = null;

		PythonSucessResponse pythonSucessResponse = null;
		try {

			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(ganTrainingWizardRequest.getGaudiVersionId());
			GanTrainingWizard ganTrainingWizard = new GanTrainingWizard();

			ganTrainingWizard.setGaudiVersionId(ganTrainingWizardRequest.getGaudiVersionId());
			ganTrainingWizard.setTrainingArchitecture(ganTrainingWizardRequest.getTrainingArchitecture());
			if (ganTrainingWizardRequest.getDataHeight().equals(ganTrainingWizardRequest.getDataWidth())) {
				ganTrainingWizard.setDataWidth(ganTrainingWizardRequest.getDataWidth());
				ganTrainingWizard.setDataHeight(ganTrainingWizardRequest.getDataHeight());
			} else {
				LOG.error("Data height and Width must be Same");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
								"data.height.and.width.must.be.same", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

			ganTrainingWizard.setDataUseGray(ganTrainingWizardRequest.getDatauseGray());
			String trainClassName = new ObjectMapper().writeValueAsString(ganTrainingWizardRequest.getClassName());
			ganTrainingWizard.setTrainClassName(trainClassName);
			ganTrainingWizard.setOptimizerType(ganTrainingWizardRequest.getOptimizerType());
			ganTrainingWizard.setOptimizerGLearningRate(ganTrainingWizardRequest.getOptimizerGLearningRate());
			ganTrainingWizard.setOptimizerDLearningRate(ganTrainingWizardRequest.getOptimizerDLearningRate());
			ganTrainingWizard.setOptimizerBeta1(ganTrainingWizardRequest.getOptimizerBeta1());
			ganTrainingWizard.setOptimizerBeta2(ganTrainingWizardRequest.getOptimizerBeta2());
			ganTrainingWizard.setOptimizerVisionLoss(ganTrainingWizardRequest.getOptimizerVisionLoss());
			ganTrainingWizard.setTrainingIterations(ganTrainingWizardRequest.getTrainingIterations());
			ganTrainingWizard.setTrainingBatchSize(ganTrainingWizardRequest.getTrainingBatchSize());
			ganTrainingWizard.setTrainingGamma(ganTrainingWizardRequest.getTrainingGamma());
			ganTrainingWizard.setTrainingMinimumIterations(ganTrainingWizardRequest.getTrainingMinimumIterations());
			ganTrainingWizard.setTrainingNoOfWorkers(ganTrainingWizardRequest.getTrainingNoOfWorkers());
			ganTrainingWizard.setTrainingSampleInterval(ganTrainingWizardRequest.getTrainingSampleInterval());
			ganTrainingWizard.setTrainingSampleNumber(ganTrainingWizardRequest.getTrainingSampleNumber());
			ganTrainingWizard.setTrainingSeedPoint(ganTrainingWizardRequest.getTrainingSeedPoint());
			ganTrainingWizard.setAugmentation(ganTrainingWizardRequest.getAugmentation());
			if (ganTrainingWizardRequest.getAugmentation().equalsIgnoreCase(ApplicationConstants.NOAUG)) {

				ganTrainingWizard.setAugmentationXFrac(0.0f);
				ganTrainingWizard.setAugmentationAnisotropy(0.0f);
				ganTrainingWizard.setAugmentationBrightness(0.0f);
				ganTrainingWizard.setAugmentationContrast(0.0f);
				ganTrainingWizard.setAugmentationIntegerTranslation(0.0f);
				ganTrainingWizard.setAugmentationPvalue(0.0f);
				ganTrainingWizard.setAugmentationRotate(0.0f);
				ganTrainingWizard.setAugmentationRotate90(0.0f);
				ganTrainingWizard.setAugmentationScalling(0.0f);
				ganTrainingWizard.setAugmentationTarget(0.0f);
				ganTrainingWizard.setAugmentationXFlip(0.0f);
				ganTrainingWizard.setAugmentationHue(0.0f);
				ganTrainingWizard.setAugmentationLumaFlip(0.0f);
				ganTrainingWizard.setAugmentationSaturation(0.0f);
			} else {

				ganTrainingWizard.setAugmentationXFrac(ganTrainingWizardRequest.getAugmentationXFrac());
				ganTrainingWizard.setAugmentationAnisotropy(ganTrainingWizardRequest.getAugmentationAnisotropy());
				ganTrainingWizard.setAugmentationBrightness(ganTrainingWizardRequest.getAugmentationBrightness());
				ganTrainingWizard.setAugmentationContrast(ganTrainingWizardRequest.getAugmentationContrast());
				ganTrainingWizard.setAugmentationIntegerTranslation(
						ganTrainingWizardRequest.getAugmentationIntegerTranslation());
				ganTrainingWizard.setAugmentationPvalue(ganTrainingWizardRequest.getAugmentationPValue());
				ganTrainingWizard.setAugmentationRotate(ganTrainingWizardRequest.getAugmentationRotate());
				ganTrainingWizard.setAugmentationRotate90(ganTrainingWizardRequest.getAugmentationRotate90());
				ganTrainingWizard.setAugmentationScalling(ganTrainingWizardRequest.getAugmentationScalling());
				ganTrainingWizard.setAugmentationTarget(ganTrainingWizardRequest.getAugmentationTarget());
				ganTrainingWizard.setAugmentationXFlip(ganTrainingWizardRequest.getAugmentationXFlip());
				ganTrainingWizard.setAugmentationHue(ganTrainingWizardRequest.getAugmentationHue());
				ganTrainingWizard.setAugmentationLumaFlip(ganTrainingWizardRequest.getAugmentationLumaFlip());
				ganTrainingWizard.setAugmentationSaturation(ganTrainingWizardRequest.getAugmentationSaturation());
			}
			ganTrainingWizard.setPostProcessAutoFilter(ganTrainingWizardRequest.getPostProcessAutoFilter());
			if (ganTrainingWizardRequest.getPostProcessAutoFilter().equalsIgnoreCase(ApplicationConstants.YES)) {
				ganTrainingWizard.setPostProcessNoOfCluster(ganTrainingWizardRequest.getPostProcessNoOfCluster());
			} else {
				ganTrainingWizard.setPostProcessNoOfCluster(0L);
			}
			ganTrainingWizard.setPostProcessGenerateHeight(ganTrainingWizardRequest.getPostProcessGenerateHeight());
			ganTrainingWizard.setPostProcessGenerateWidth(ganTrainingWizardRequest.getPostProcessGenerateWidth());
			ganTrainingWizard.setCreatedBy(ganTrainingWizardRequest.getCreatedBy());
			ganTrainingWizard.setIsActive(ApplicationConstants.YES);
			ganTrainingWizard.setCreatedDate(new Date(System.currentTimeMillis()));
			saveganTrainingWizard = ganTrainingWizardRepository.save(ganTrainingWizard);
			if (saveganTrainingWizard.getTrainingId() > 0) {
				blendingServiceImpl.updateActiveSteps(gaudiAIVersion.get(0), 1);
				blendingServiceImpl.updateActiveSteps(gaudiAIVersion.get(0), 2);
				pythonSucessResponse = ganTrainingProcess(saveganTrainingWizard);
			}
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);

		}  catch (WebClientResponseException | WebClientRequestException e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE,
					messageSource.getMessage("server.down.try.afterSome.time", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (JDBCConnectionException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (CannotCreateTransactionException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (Exception e) {
			LOG.error("Error In Save Generated Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.generated.json", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		
	}

	@Override
	public ResponseEntity<?> getGanTrainingData(Long trainingID) {
		GanTrainingResponse ganTrainingResponse = null;
		try {
			if(trainingID!=null) {
			List<GanTrainingWizard> ganTrainingWizardData = ganTrainingWizardRepository
					.getGanTrainingWizardByGanTrainingID(trainingID);
			if (!ganTrainingWizardData.isEmpty()) {
				ganTrainingResponse = setTrainingTabResponse(ganTrainingWizardData.get(0));
				return new ResponseEntity<>(ganTrainingResponse, HttpStatus.OK);
			} else {

				LOG.error("No gan Training Data Available For trainingID {} .", trainingID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.training.data.for.ganTrainingID" , null,
								LocaleContextHolder.getLocale())+ trainingID ,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			}else {
				LOG.error("Error  - Get Training Data.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("error.get.training.data", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error  - Get Training Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.get.training.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	

	}

	private GanTrainingResponse setTrainingTabResponse(GanTrainingWizard ganTrainingWizard) {

		GanTrainingResponse ganTrainingResponse = new GanTrainingResponse();
		ganTrainingResponse.setTrainingId(ganTrainingWizard.getTrainingId());
		ganTrainingResponse.setGaudiVersionId(ganTrainingWizard.getGaudiVersionId());
		ganTrainingResponse.setTrainingArchitecture(ganTrainingWizard.getTrainingArchitecture());
		ganTrainingResponse.setDataWidth(ganTrainingWizard.getDataWidth());
		ganTrainingResponse.setDataHeight(ganTrainingWizard.getDataHeight());
		ganTrainingResponse.setDatauseGray(ganTrainingWizard.getDataUseGray());
		Gson g = new Gson();
		List<?> convert = null;
		convert = g.fromJson(ganTrainingWizard.getTrainClassName(), List.class);
		ganTrainingResponse.setClassName(convert);
		ganTrainingResponse.setOptimizerType(ganTrainingWizard.getOptimizerType());
		ganTrainingResponse.setOptimizerGLearningRate(ganTrainingWizard.getOptimizerGLearningRate());
		ganTrainingResponse.setOptimizerDLearningRate(ganTrainingWizard.getOptimizerDLearningRate());
		ganTrainingResponse.setOptimizerBeta1(ganTrainingWizard.getOptimizerBeta1());
		ganTrainingResponse.setOptimizerBeta2(ganTrainingWizard.getOptimizerBeta2());
		ganTrainingResponse.setOptimizerVisionLoss(ganTrainingWizard.getOptimizerVisionLoss());
		ganTrainingResponse.setTrainingIterations(ganTrainingWizard.getTrainingIterations());
		ganTrainingResponse.setTrainingBatchSize(ganTrainingWizard.getTrainingBatchSize());
		ganTrainingResponse.setTrainingGamma(ganTrainingWizard.getTrainingGamma());
		ganTrainingResponse.setTrainingMinimumIterations(ganTrainingWizard.getTrainingMinimumIterations());
		ganTrainingResponse.setTrainingNoOfWorkers(ganTrainingWizard.getTrainingNoOfWorkers());
		ganTrainingResponse.setTrainingSampleInterval(ganTrainingWizard.getTrainingSampleInterval());
		ganTrainingResponse.setTrainingSampleNumber(ganTrainingWizard.getTrainingSampleNumber());
		ganTrainingResponse.setTrainingSeedPoint(ganTrainingWizard.getTrainingSeedPoint());
		ganTrainingResponse.setAugmentation(ganTrainingWizard.getAugmentation());
		ganTrainingResponse.setAugmentationXFrac(ganTrainingWizard.getAugmentationXFrac());
		ganTrainingResponse.setAugmentationAnisotropy(ganTrainingWizard.getAugmentationAnisotropy());
		ganTrainingResponse.setAugmentationBrightness(ganTrainingWizard.getAugmentationBrightness());
		ganTrainingResponse.setAugmentationContrast(ganTrainingWizard.getAugmentationContrast());
		ganTrainingResponse.setAugmentationIntegerTranslation(ganTrainingWizard.getAugmentationIntegerTranslation());
		ganTrainingResponse.setAugmentationPValue(ganTrainingWizard.getAugmentationPvalue());
		ganTrainingResponse.setAugmentationRotate(ganTrainingWizard.getAugmentationRotate());
		ganTrainingResponse.setAugmentationRotate90(ganTrainingWizard.getAugmentationRotate90());
		ganTrainingResponse.setAugmentationScalling(ganTrainingWizard.getAugmentationScalling());
		ganTrainingResponse.setAugmentationTarget(ganTrainingWizard.getAugmentationTarget());
		ganTrainingResponse.setAugmentationXFlip(ganTrainingWizard.getAugmentationXFlip());
		ganTrainingResponse.setAugmentationHue(ganTrainingWizard.getAugmentationHue());
		ganTrainingResponse.setAugmentationLumaFlip(ganTrainingWizard.getAugmentationLumaFlip());
		ganTrainingResponse.setAugmentationSaturation(ganTrainingWizard.getAugmentationSaturation());
		ganTrainingResponse.setPostProcessAutoFilter(ganTrainingWizard.getPostProcessAutoFilter());
		ganTrainingResponse.setPostProcessNoOfCluster(ganTrainingWizard.getPostProcessNoOfCluster());
		ganTrainingResponse.setPostProcessGenerateHeight(ganTrainingWizard.getPostProcessGenerateHeight());
		ganTrainingResponse.setPostProcessGenerateWidth(ganTrainingWizard.getPostProcessGenerateWidth());
		ganTrainingResponse.setCreatedBy(ganTrainingWizard.getCreatedBy());
		ganTrainingResponse.setCreatedDate(ganTrainingWizard.getCreatedDate());
		ganTrainingResponse.setModifiedDate(ganTrainingWizard.getModifiedDate());
		ganTrainingResponse.setIsActive(ganTrainingWizard.getIsActive());

		return ganTrainingResponse;
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateGanTrainingData(GanTrainingWizardRequest ganTrainingWizardRequest) {
		PythonSucessResponse pythonSucessResponse = null;
		try {
			updateTrainingJson(ganTrainingWizardRequest);
			GanTrainingWizard ganTrainingWizard = ganTrainingWizardRepository
					.getReferenceById(ganTrainingWizardRequest.getTrainingId());
			pythonSucessResponse = ganTrainingProcess(ganTrainingWizard);
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
		} catch (WebClientResponseException | WebClientRequestException e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}  catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE, messageSource.getMessage(
							"server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		}
		

	}

	@Transactional
	public ResponseEntity<?> updateTrainingJson(GanTrainingWizardRequest ganTrainingWizardRequest) {
		List<GanTrainingWizard> existTrainingData = ganTrainingWizardRepository
				.getGanTrainingWizardByGanTrainingID(ganTrainingWizardRequest.getTrainingId());
		Long ganTrainingID = ganTrainingWizardRequest.getTrainingId();
		Long ganVersionID = ganTrainingWizardRequest.getGaudiVersionId();
		try {
			if (ganVersionID != null && ganTrainingID != null) {

				if (existTrainingData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.training.data.for.ganTrainingid", null,
									LocaleContextHolder.getLocale())+ ganTrainingID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				GanTrainingWizard ganTrainingWizard = ganTrainingWizardRepository.getReferenceById(ganTrainingID);

				ganTrainingWizard.setGaudiVersionId(ganTrainingWizardRequest.getGaudiVersionId());

				ganTrainingWizard.setTrainingArchitecture(ganTrainingWizardRequest.getTrainingArchitecture());

				if (ganTrainingWizardRequest.getDataHeight().equals(ganTrainingWizardRequest.getDataWidth())) {
					ganTrainingWizard.setDataWidth(ganTrainingWizardRequest.getDataWidth());
					ganTrainingWizard.setDataHeight(ganTrainingWizardRequest.getDataHeight());
				} else {
					LOG.error("Data height and Width must be Same");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("data.height.and.width.must.be.same", null,
									LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}

				ganTrainingWizard.setDataUseGray(ganTrainingWizardRequest.getDatauseGray());
				String trainClassName = new ObjectMapper().writeValueAsString(ganTrainingWizardRequest.getClassName());
				ganTrainingWizard.setTrainClassName(trainClassName);
				ganTrainingWizard.setOptimizerType(ganTrainingWizardRequest.getOptimizerType());
				ganTrainingWizard.setOptimizerGLearningRate(ganTrainingWizardRequest.getOptimizerGLearningRate());
				ganTrainingWizard.setOptimizerDLearningRate(ganTrainingWizardRequest.getOptimizerDLearningRate());
				ganTrainingWizard.setOptimizerBeta1(ganTrainingWizardRequest.getOptimizerBeta1());
				ganTrainingWizard.setOptimizerBeta2(ganTrainingWizardRequest.getOptimizerBeta2());
				ganTrainingWizard.setOptimizerVisionLoss(ganTrainingWizardRequest.getOptimizerVisionLoss());
				ganTrainingWizard.setTrainingIterations(ganTrainingWizardRequest.getTrainingIterations());
				ganTrainingWizard.setTrainingBatchSize(ganTrainingWizardRequest.getTrainingBatchSize());
				ganTrainingWizard.setTrainingGamma(ganTrainingWizardRequest.getTrainingGamma());
				ganTrainingWizard.setTrainingMinimumIterations(ganTrainingWizardRequest.getTrainingMinimumIterations());
				ganTrainingWizard.setTrainingNoOfWorkers(ganTrainingWizardRequest.getTrainingNoOfWorkers());
				ganTrainingWizard.setTrainingSampleInterval(ganTrainingWizardRequest.getTrainingSampleInterval());
				ganTrainingWizard.setTrainingSampleNumber(ganTrainingWizardRequest.getTrainingSampleNumber());
				ganTrainingWizard.setTrainingSeedPoint(ganTrainingWizardRequest.getTrainingSeedPoint());
				ganTrainingWizard.setAugmentation(ganTrainingWizardRequest.getAugmentation());
				if (ganTrainingWizardRequest.getAugmentation().equalsIgnoreCase(ApplicationConstants.NOAUG)) {

					ganTrainingWizard.setAugmentationXFrac(0.0f);
					ganTrainingWizard.setAugmentationAnisotropy(0.0f);
					ganTrainingWizard.setAugmentationBrightness(0.0f);
					ganTrainingWizard.setAugmentationContrast(0.0f);
					ganTrainingWizard.setAugmentationIntegerTranslation(0.0f);
					ganTrainingWizard.setAugmentationPvalue(0.0f);
					ganTrainingWizard.setAugmentationRotate(0.0f);
					ganTrainingWizard.setAugmentationRotate90(0.0f);
					ganTrainingWizard.setAugmentationScalling(0.0f);
					ganTrainingWizard.setAugmentationTarget(0.0f);
					ganTrainingWizard.setAugmentationXFlip(0.0f);
					ganTrainingWizard.setAugmentationHue(0.0f);
					ganTrainingWizard.setAugmentationLumaFlip(0.0f);
					ganTrainingWizard.setAugmentationSaturation(0.0f);
				} else {

					ganTrainingWizard.setAugmentationXFrac(ganTrainingWizardRequest.getAugmentationXFrac());
					ganTrainingWizard.setAugmentationAnisotropy(ganTrainingWizardRequest.getAugmentationAnisotropy());
					ganTrainingWizard.setAugmentationBrightness(ganTrainingWizardRequest.getAugmentationBrightness());
					ganTrainingWizard.setAugmentationContrast(ganTrainingWizardRequest.getAugmentationContrast());
					ganTrainingWizard.setAugmentationIntegerTranslation(
							ganTrainingWizardRequest.getAugmentationIntegerTranslation());
					ganTrainingWizard.setAugmentationPvalue(ganTrainingWizardRequest.getAugmentationPValue());
					ganTrainingWizard.setAugmentationRotate(ganTrainingWizardRequest.getAugmentationRotate());
					ganTrainingWizard.setAugmentationRotate90(ganTrainingWizardRequest.getAugmentationRotate90());
					ganTrainingWizard.setAugmentationScalling(ganTrainingWizardRequest.getAugmentationScalling());
					ganTrainingWizard.setAugmentationTarget(ganTrainingWizardRequest.getAugmentationTarget());
					ganTrainingWizard.setAugmentationXFlip(ganTrainingWizardRequest.getAugmentationXFlip());
					ganTrainingWizard.setAugmentationHue(ganTrainingWizardRequest.getAugmentationHue());
					ganTrainingWizard.setAugmentationLumaFlip(ganTrainingWizardRequest.getAugmentationLumaFlip());
					ganTrainingWizard.setAugmentationSaturation(ganTrainingWizardRequest.getAugmentationSaturation());
				}
				ganTrainingWizard.setPostProcessAutoFilter(ganTrainingWizardRequest.getPostProcessAutoFilter());
				if (ganTrainingWizardRequest.getPostProcessAutoFilter().equalsIgnoreCase(ApplicationConstants.YES)) {
					ganTrainingWizard.setPostProcessNoOfCluster(ganTrainingWizardRequest.getPostProcessNoOfCluster());
				} else {
					ganTrainingWizard.setPostProcessNoOfCluster(0L);
				}
				ganTrainingWizard.setPostProcessGenerateHeight(ganTrainingWizardRequest.getPostProcessGenerateHeight());
				ganTrainingWizard.setPostProcessGenerateWidth(ganTrainingWizardRequest.getPostProcessGenerateWidth());

				ganTrainingWizard.setCreatedBy(ganTrainingWizardRequest.getCreatedBy());
				ganTrainingWizard.setIsActive(ApplicationConstants.YES);
				ganTrainingWizard.setCreatedDate(new Date(System.currentTimeMillis()));
				LOG.info(ganTrainingWizard);
				ganTrainingWizardRepository.save(ganTrainingWizard);
				
				LOG.info("The Training data Updated successfully.");
				return new ResponseEntity<>(HttpStatus.OK);

			} else {
				LOG.error("Error In The training Data For trainingId - {}",ganTrainingID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.training.data.for.ganTrainingid", null,
								LocaleContextHolder.getLocale())+ ganTrainingID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Updating The Training Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("Error.In.Updating.The.Training.Data",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ResponseEntity<?> getListOfChannelImage(int pageSize, int pageNum, String sortField, String sortDir,
			Long datasetID, Long channelID, String filter) {
		try {
			ListOfGanImageResponse pageData = listOfImage(pageSize, pageNum, sortField, sortDir, datasetID, channelID,
					filter);
			if (pageData != null) {
				return new ResponseEntity<>(pageData, HttpStatus.OK);
			} else {
				LOG.error("No Image Details Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.image.details.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Error In Get List Of Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.get.image.details", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	@Override
	public ResponseEntity<?> getListOfLabeledClass(Long datasetID) {
		try {
			if (datasetID != null) {
				List<String> gaudiganClass = ganClassRepository.findGaudiGanClassNamesBydatasetID(datasetID);
				return new ResponseEntity<>(gaudiganClass, HttpStatus.OK);
			} else {
				LOG.error("Error In Get datasetID.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("datasetid.cannot.be.null", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In Get List Of ClassName.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.classname.details", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	private PythonSucessResponse ganTrainingProcess(GanTrainingWizard saveganTrainingWizard) {
		LOG.info(saveganTrainingWizard);

		PythonGanTrainingRequest pythonganTrainingRequest = null;

		PythonSucessResponse pythonSucessResponse = null;
		try {
			pythonganTrainingRequest = new PythonGanTrainingRequest();

			List<GanTrainingJsonRequest> listganrequest = new ArrayList<>();
			GanTrainingJsonRequest ganTrainingJsonRequest = new GanTrainingJsonRequest();
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(saveganTrainingWizard.getGaudiVersionId());
			List<GanTrainingWizard> trainingWizard = ganTrainingWizardRepository
					.findBygaudiVersionId(saveganTrainingWizard.getGaudiVersionId());
			GanDataset dataset = ganDatasetRepository.getDatasetByDatasetID(gaudiAIVersion.get(0).getDatasetID());
			Long noOfChannel = dataset.getNoOfChannel();
			String datasetPath = dataset.getDatasetPath();
			pythonganTrainingRequest.setOperation(Arrays.asList(ApplicationConstants.TRAINNING));
			ganTrainingJsonRequest.setLogPath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.DOC + File.separator + ApplicationConstants.LOG);
			ganTrainingJsonRequest.setSmartId(gaudiAIVersion.get(0).getSmartID());
			ganTrainingJsonRequest.setDatasetId(gaudiAIVersion.get(0).getDatasetID());

			PathSetting pathSetting = new PathSetting();
			pathSetting.setNoOfChannel(noOfChannel);
			pathSetting.setVersionPath(gaudiAIVersion.get(0).getVersionPath());
			pathSetting.setDatasetPath(datasetPath);
			ganTrainingJsonRequest.setPathSetting(pathSetting);

			NetworkParams networkParams = new NetworkParams();
			networkParams.setSelectArchitecture(saveganTrainingWizard.getTrainingArchitecture());

			ganTrainingJsonRequest.setNetworkParams(networkParams);

			DataSettings dataSettings = new DataSettings();
			dataSettings.setHeight(saveganTrainingWizard.getDataHeight());
			dataSettings.setWidth(saveganTrainingWizard.getDataWidth());
			Gson g = new Gson();
			List<?> convert = null;
			convert = g.fromJson(trainingWizard.get(0).getTrainClassName(), List.class);
			dataSettings.setClasses(convert);
			boolean datauseGray = (saveganTrainingWizard.getDataUseGray().equalsIgnoreCase(ApplicationConstants.NO))
					? false
					: true;
			dataSettings.setUseGray(datauseGray);
			ganTrainingJsonRequest.setDataSettings(dataSettings);

			OptimizerSettings optimizerSettings = new OptimizerSettings();
			optimizerSettings.setBeta1(saveganTrainingWizard.getOptimizerBeta1());
			optimizerSettings.setBeta2(saveganTrainingWizard.getOptimizerBeta2());
			optimizerSettings.setDlearningRate(saveganTrainingWizard.getOptimizerDLearningRate());
			optimizerSettings.setGlearningRate(saveganTrainingWizard.getOptimizerGLearningRate());
			optimizerSettings.setType(saveganTrainingWizard.getOptimizerType());
			boolean visionLoss = (saveganTrainingWizard.getOptimizerVisionLoss()
					.equalsIgnoreCase(ApplicationConstants.NO)) ? false : true;
			optimizerSettings.setVisionLoss(visionLoss);
			ganTrainingJsonRequest.setOptimizerSettings(optimizerSettings);

			TrainingParameters trainingParameters = new TrainingParameters();
			trainingParameters.setIterations(saveganTrainingWizard.getTrainingIterations());
			trainingParameters.setBatchSize(saveganTrainingWizard.getTrainingBatchSize());
			trainingParameters.setGamma(saveganTrainingWizard.getTrainingGamma());
			trainingParameters.setMinimumIterations(saveganTrainingWizard.getTrainingMinimumIterations());
			trainingParameters.setNoOfWorkers(saveganTrainingWizard.getTrainingNoOfWorkers());
			trainingParameters.setSampleInterval(saveganTrainingWizard.getTrainingSampleInterval());
			trainingParameters.setSampleNumber(saveganTrainingWizard.getTrainingSampleNumber());
			trainingParameters.setSeedPoint(saveganTrainingWizard.getTrainingSeedPoint());
			ganTrainingJsonRequest.setTrainingParameters(trainingParameters);

			AugmentationSetting augmentationSetting = new AugmentationSetting();
			augmentationSetting.setAugmentation(saveganTrainingWizard.getAugmentation());
			augmentationSetting.setXfrac(saveganTrainingWizard.getAugmentationXFrac());
			augmentationSetting.setAnistropy(saveganTrainingWizard.getAugmentationAnisotropy());
			augmentationSetting.setBrightness(saveganTrainingWizard.getAugmentationBrightness());
			augmentationSetting.setContrast(saveganTrainingWizard.getAugmentationContrast());
			augmentationSetting.setIntegerTranslation(saveganTrainingWizard.getAugmentationIntegerTranslation());
			augmentationSetting.setAugmentationPValue(saveganTrainingWizard.getAugmentationPvalue());
			augmentationSetting.setRotate(saveganTrainingWizard.getAugmentationRotate());
			augmentationSetting.setRotate90(saveganTrainingWizard.getAugmentationRotate90());
			augmentationSetting.setScaling(saveganTrainingWizard.getAugmentationScalling());
			augmentationSetting.setAugmentationTarget(saveganTrainingWizard.getAugmentationTarget());
			augmentationSetting.setXflip(saveganTrainingWizard.getAugmentationXFlip());
			augmentationSetting.setHue(saveganTrainingWizard.getAugmentationHue());
			augmentationSetting.setLumaFlip(saveganTrainingWizard.getAugmentationLumaFlip());
			augmentationSetting.setSaturation(saveganTrainingWizard.getAugmentationSaturation());
			ganTrainingJsonRequest.setAugmentationSetting(augmentationSetting);

			PostProcess postProcess = new PostProcess();
			boolean autoFilter = (saveganTrainingWizard.getPostProcessAutoFilter()
					.equalsIgnoreCase(ApplicationConstants.NO)) ? false : true;
			postProcess.setAutoFilter(autoFilter);
			postProcess.setNoOfCluster(saveganTrainingWizard.getPostProcessNoOfCluster());
			postProcess.setGenerateHeight(saveganTrainingWizard.getPostProcessGenerateHeight());
			postProcess.setGenerateWidth(saveganTrainingWizard.getPostProcessGenerateWidth());
			ganTrainingJsonRequest.setPostProcess(postProcess);

			listganrequest.add(ganTrainingJsonRequest);
			pythonganTrainingRequest.setParams(listganrequest);

			LOG.info(pythonganTrainingRequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			pythonSucessResponse = webClient.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.TRAIN)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonganTrainingRequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();

		} catch (ServiceUnavailableException e) {
			LOG.error("server.is.down.please.try.after.sometimes");
			throw new ServiceUnavailableException(messageSource
					.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (ServerErrorException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes",
					null, LocaleContextHolder.getLocale()));
		}
		return pythonSucessResponse;

	}

	private ListOfGanImageResponse listOfImage(int pageSize, int pageNum, String sortField, String sortDir,
			Long datasetID, Long channelID, String filter) {
		sortField = sortField == null ? ApplicationConstants.CREATEDDATE : sortField;
		sortDir = sortDir == null ? ApplicationConstants.ASC : sortDir;

		Pageable pageable = PageRequest.of(pageNum - 1, pageSize,
				sortDir.equals(ApplicationConstants.ASC) ? Sort.by(sortField).ascending()
						: Sort.by(sortField).descending());
		ListOfGanImageResponse listOfGanImageResponse = null;
		new ListOfGanImageResponse();
		Long count;
		Page<GanChannelImage> page = null;
		if (channelID == null && filter.equalsIgnoreCase(ApplicationConstants.ALL)) {
			count = ganChannelImageRepository.countByDatasetIDAndIsActive(datasetID, ApplicationConstants.YES);
			page = ganChannelImageRepository.findListOfImageByDatasetID(datasetID, ApplicationConstants.YES, pageable);
		} else if (channelID == null && !filter.equalsIgnoreCase(ApplicationConstants.ALL)) {
			String labelledYN = filter.equalsIgnoreCase(ApplicationConstants.LABEL) ? ApplicationConstants.YES
					: ApplicationConstants.NO;
			count = ganChannelImageRepository.countByDatasetIDAndLabelledYNAndAndIsActive(datasetID, labelledYN,
					ApplicationConstants.YES);
			page = ganChannelImageRepository.findListOfImageByDatasetIDLaUlAl(datasetID, labelledYN,
					ApplicationConstants.YES, pageable);
		} else if (channelID != null && filter.equalsIgnoreCase(ApplicationConstants.ALL)) {
			GanChannels ganChannels = ganChannelsRepository.findGanChannelsBychannelID(channelID);
			count = ganChannelImageRepository.countByDatasetIDAndGanChannelsAndIsActive(datasetID, ganChannels,
					ApplicationConstants.YES);
			page = ganChannelImageRepository.findListOfImageByDatasetIDAllGanChannels(datasetID, ganChannels,
					ApplicationConstants.YES, pageable);
		} else {
			String labelledYN = filter.equalsIgnoreCase(ApplicationConstants.LABEL) ? ApplicationConstants.YES
					: ApplicationConstants.NO;
			GanChannels ganChannels = ganChannelsRepository.findGanChannelsBychannelID(channelID);
			count = ganChannelImageRepository.countByDatasetIDAndGanChannelsAndLabelledYNAndIsActive(datasetID,
					ganChannels, labelledYN, ApplicationConstants.YES);
			page = ganChannelImageRepository.findListOfImageByDatasetIDGanChannels(datasetID, ganChannels, labelledYN,
					ApplicationConstants.YES, pageable);
		}

		List<GanChannelImage> listImageDetails = null;
		if (page != null && !page.isEmpty()) {
			listOfGanImageResponse = new ListOfGanImageResponse();
			listImageDetails = page.getContent();
			listOfGanImageResponse.setTotalImageCount(count);
			listOfGanImageResponse.setGanChannelImage(listImageDetails);
		}
		return listOfGanImageResponse;
	}

	@Override
	public ResponseEntity<?> getGANParticularVersion(Long versionID) {
		GaudiAIGANVersionData gaudiAIVersionData = new GaudiAIGANVersionData();
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if (!gaudiAIVersion.isEmpty()) {
				gaudiAIVersionData = setGaudiAIGANVersionData(gaudiAIVersion.get(0));
				List<GanClass> listGanClass = ganClassRepository
						.findListOfGanClassByDatasetID(gaudiAIVersion.get(0).getDatasetID());
				if (!listGanClass.isEmpty()) {
					ListOfClassResponse listOfClassResponse = new ListOfClassResponse();
					listOfClassResponse.setGanClass(listGanClass);
					listOfClassResponse.setTotalGANCLassCount(listGanClass.size());
					gaudiAIVersionData.setListOfClassResponse(listOfClassResponse);
				}
				List<GanTrainingWizard> listGanTrainingWizard = ganTrainingWizardRepository
						.findBygaudiVersionId(versionID);
				if (!listGanTrainingWizard.isEmpty()) {
					Long trainingID = listGanTrainingWizard.get(0).getTrainingId();
					gaudiAIVersionData.setTrainingID(trainingID);
				}
				List<IListOfTestData> listGanTestWizard = ganTestWizardRepository
						.findTestFolderMaxTestIDByGaudiVersionId(versionID);
				listGanTestWizard.sort(Comparator.comparing(IListOfTestData::getTestID));
				Collections.reverse(listGanTestWizard);
				if (!listGanTestWizard.isEmpty()) {
					gaudiAIVersionData.setGanTestDetail(listGanTestWizard);
				}
				return new ResponseEntity<>(gaudiAIVersionData, HttpStatus.OK);
			} else {
				LOG.error("No GAN Version Data Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.gan.version.data.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}

		} catch (Exception e) {
			LOG.error("Error In Get GAN Particular Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.get.gan.particular.version",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	public GaudiAIGANVersionData setGaudiAIGANVersionData(GaudiAIVersion gaudiAIVersion) {
		GaudiAIGANVersionData gaudiAIVersionData = new GaudiAIGANVersionData();
		gaudiAIVersionData.setVersionID(gaudiAIVersion.getVersionID());
		gaudiAIVersionData.setProjectID(gaudiAIVersion.getProjectID());
		gaudiAIVersionData.setVersionName(gaudiAIVersion.getVersionName());
		gaudiAIVersionData.setNotes(gaudiAIVersion.getNotes());

		Gson g = new Gson();
		SortedSet<?> convert = null;
		convert = g.fromJson(gaudiAIVersion.getActiveStep(), SortedSet.class);

		gaudiAIVersionData.setActiveStep(convert);
		gaudiAIVersionData.setProcessStatus(gaudiAIVersion.getProcessStatus());
		gaudiAIVersionData.setErrorMessage(gaudiAIVersion.getErrorMessage());
		gaudiAIVersionData.setVersionPath(gaudiAIVersion.getVersionPath());
		gaudiAIVersionData.setIsClone(gaudiAIVersion.getIsClone());
		gaudiAIVersionData.setCloneVersionID(gaudiAIVersion.getCloneVersionID());
		gaudiAIVersionData.setIsActive(gaudiAIVersion.getIsActive());
		gaudiAIVersionData.setCreatedDate(gaudiAIVersion.getCreatedDate());
		gaudiAIVersionData.setModifiedDate(gaudiAIVersion.getModifiedDate());
		gaudiAIVersionData.setCreatedBy(gaudiAIVersion.getCreatedBy());
		gaudiAIVersionData.setLockUnlock(gaudiAIVersion.getLockUnlock());
		gaudiAIVersionData.setSmartID(gaudiAIVersion.getSmartID());
		gaudiAIVersionData.setDatasetID(gaudiAIVersion.getDatasetID());
		gaudiAIVersionData.setProcessGanTestStatus(gaudiAIVersion.getProcessGanTestStatus());
		gaudiAIVersionData.setErrorGanTestMessage(gaudiAIVersion.getErrorGanTestMessage());
		return gaudiAIVersionData;
	}

	@Override
	@Transactional
	public ResponseEntity<?> createGanDataset(GanDatasetRequest ganDatasetRequest) {
		GanDatasetCreationResponse response = null;
		GanDataset savedGanDataset = null;
		try {

			Long datasetNameExistCount = ganDatasetRepository.countByDatasetNameAndCreatedBy(
					ganDatasetRequest.getDatasetName(), ganDatasetRequest.getCreatedBy());
			if (datasetNameExistCount > 0) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 302,
						ApplicationConstants.FOUND, messageSource.getMessage("duplicate.dataset.name.entered.please.enter.different.dataset.name", null, LocaleContextHolder.getLocale()), null);
				LOG.error("Duplicate Dataset Name Entered. Please Enter Different Dataset Name.");
				return new ResponseEntity<>(errorResponse, HttpStatus.FOUND);
			}

			GanDataset ganDataset = new GanDataset();
			ganDataset.setDatasetName(ganDatasetRequest.getDatasetName());
			ganDataset.setRestriction(ganDatasetRequest.getRestriction());
			ganDataset.setIsActive(ApplicationConstants.YES);
			String ganDatasetFolderPath = baseFolderpath + File.separator + ApplicationConstants.GANDATASET
					+ File.separator + ganDatasetRequest.getDatasetName();

			ganDataset.setCreatedBy(ganDatasetRequest.getCreatedBy());
			ganDataset.setCreatedDate(new Date(System.currentTimeMillis()));
			savedGanDataset = ganDatasetRepository.save(ganDataset);
			if (savedGanDataset.getDatasetID() > 0) {

				applicationUtil.createFolder(ganDatasetFolderPath);

				ganDatasetRepository.updateGanDatasetPathBydatasetID(new Date(System.currentTimeMillis()),
						ganDatasetFolderPath, savedGanDataset.getDatasetID());

				gaudiAIVersionRepository.updateGanDatasetIDByVersionID(new Date(System.currentTimeMillis()),
						savedGanDataset.getDatasetID(), ganDatasetRequest.getVersionID());
				createChannel(savedGanDataset.getDatasetID());

				response = new GanDatasetCreationResponse();
				response.setDatasetID(savedGanDataset.getDatasetID());
				response.setVersionID(ganDatasetRequest.getVersionID());
				response.setDatasetName(savedGanDataset.getDatasetName());
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("gan.dataset.created.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("GAN Dataset created Successfully.");
			} else {
				LOG.error("GAN Dataset Creatation Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("gan.dataset.creation.failure", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Exception - GAN Dataset Creatation Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.gan.dataset.creation.failure",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);

	}

	@Override
	@Transactional
	public ResponseEntity<?> createChannel(Long datasetID) {
		try {
			LOG.info("createChannel for datasetID :{}", datasetID);
			GanDataset ganDataset = ganDatasetRepository.getDatasetByDatasetID(datasetID);

			if (ganDataset != null) {
				Long noOfChannel = (ganDataset.getNoOfChannel() == null ? 0 : ganDataset.getNoOfChannel()) + 1L;

				String channelPath = ganDataset.getDatasetPath() + File.separator + ApplicationConstants.CHANNEL
						+ noOfChannel;
				applicationUtil.createFolder(channelPath);

				GanChannels ganChannels = new GanChannels();
				ganChannels.setDatasetID(ganDataset.getDatasetID());
				ganChannels.setChannelName(ApplicationConstants.CHANNEL + noOfChannel);
				ganChannels.setCreatedDate(new Date(System.currentTimeMillis()));
				ganChannels.setChannelPath(channelPath);
				ganChannelsRepository.save(ganChannels);
				ganDatasetRepository.updateNoOfChannelBydatasetID(new Date(System.currentTimeMillis()), noOfChannel,
						datasetID);

				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("created.the.channel.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Created The Channel Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);

			} else {
				LOG.error("No of Channel should be less than or equal to 10.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("no.of.channel.should.be.less.than.or.equal.to.10", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {
			LOG.error("Exception - GAN Channel Creatation Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.gan.channel.creation.failure",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteChannel(Long channelID, Long datasetID) {
		try {
			GanDataset ganDataset = ganDatasetRepository.getDatasetByDatasetID(datasetID);
			if (ganChannelsRepository.existsById(channelID)) {
				GanChannels ganChannels = ganChannelsRepository.findGanChannelsBychannelID(channelID);
				String channelPath = ganChannels.getChannelPath();
				ganChannelsRepository.deleteById(channelID);
				ganDatasetRepository.updateNoOfChannelBydatasetID(new Date(System.currentTimeMillis()),
						(ganDataset.getNoOfChannel() - 1), datasetID);
				storageService.deleteFolder(channelPath);
				
				List<GanChannels> listGanChannels=ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);

				for (int i = 0; i < listGanChannels.size(); i++) {
					File file1 = new File(listGanChannels.get(i).getChannelPath());
					File file2 = new File(ganDataset.getDatasetPath()+File.separator +ApplicationConstants.CHANNEL+(i+1));
					if(file1.renameTo(file2)){
			            ganChannelsRepository.updateChannelNameChannelPathByChannelID(ApplicationConstants.CHANNEL+(i+1), new Date(System.currentTimeMillis()), ganDataset.getDatasetPath()+File.separator +ApplicationConstants.CHANNEL+(i+1), listGanChannels.get(i).getChannelID());
			            LOG.info("File renamed");
					}else{
			            LOG.info("Sorry! the file can't be renamed");
			        }
				}
				
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("delete.the.channel.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Channel Deleted Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.info("No of Channel should be less than or equal to 10.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("no.of.channel.should.be.less.than.or.equal.to.10", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}
		} catch (Exception e) {
			LOG.info("Exception - GAN Channel Deletion Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("exception.gan.channel.deletion.failure",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}

	}

	@Override
	public ResponseEntity<?> getListOfGANDataset(Long userID) {
		try {
			List<GanDataset> listOfGanDataset = ganDatasetRepository.findByCreatedBy(userID);
			if (!listOfGanDataset.isEmpty()) {
				
				return new ResponseEntity<>(listOfGanDataset, HttpStatus.OK);
			} else {
				LOG.error("No List Of GAN Dataset Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.list.of.gan.dataset.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Error In Get List Of GAN Dataset.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.get.list.of.gan.dataset", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> labelTheImage(LabelTheImageRequest labelTheImageRequest) {
		try {
			if (labelTheImageRequest.getClassID() != null) {
			List<GanClass> listGanClass = ganClassRepository.findByClassID(labelTheImageRequest.getClassID());
			
			if(listGanClass.isEmpty()) {
				LOG.error("No Class Found For ClassID - {}",labelTheImageRequest.getClassID());
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						"No Class Found For ClassID - "+labelTheImageRequest.getClassID(),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			List<String> listOfChannelImage = labelTheImageRequest.getChannelImageName();
			if (!listOfChannelImage.isEmpty()) {
				Boolean labelStatus = false;
				for (int i = 0; i < listOfChannelImage.size(); i++) {
					String likeStatement = listOfChannelImage.get(i);
					likeStatement = likeStatement.substring(0, listOfChannelImage.get(i).lastIndexOf(".")+1);
					List<Long> listGanChannelID = ganChannelImageRepository
							.findListOfImageByDatasetIDLike(labelTheImageRequest.getDatasetID(), likeStatement);
					int updateStatusID = ganChannelImageRepository.updateClassLabelByListChannelImageID(
							new Date(System.currentTimeMillis()), listGanClass.get(0), ApplicationConstants.YES,
							listGanChannelID);
					if (updateStatusID > 0) {
						labelStatus = true;
					} else {
						labelStatus = false;
					}
				}
				if (Boolean.TRUE.equals(labelStatus)) {
					HttpOperationResponseBean response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("labelled.the.image.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Labelled The Image Successfully.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					LOG.error("Labelled The Image Failed.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, "Labelled The Image Failed.", null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			} else {
				LOG.error("List Of Selected Image Is Empty.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("list.of.selected.image.empty", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		}else {

			LOG.error("ClassID Is Not Present.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, "ClassID Is Not Present.", null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		
		}
		} catch (Exception e) {
			LOG.error("Exception - GAN Label The Image.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, "Exception - GAN Label The Image.",
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> getParticularGanDataSet(Long datasetID) {
		ParticularGanDatasetResponse particularGanDatasetResponse = null;
		try {
			GanDataset ganDataset = ganDatasetRepository.getDatasetByDatasetID(datasetID);
			if (ganDataset != null) {
				particularGanDatasetResponse = new ParticularGanDatasetResponse();
				particularGanDatasetResponse.setGanDataset(ganDataset);
				List<GanChannels> listGanChannels = ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);
				if (!listGanChannels.isEmpty()) {
					particularGanDatasetResponse.setListGanChannels(listGanChannels);
				}
				return new ResponseEntity<>(particularGanDatasetResponse, HttpStatus.OK);
			} else {
				LOG.error("No GAN DataSet Found.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("error.gan.dataset.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}

		} catch (Exception e) {
			LOG.error("Error In Get Particular GAN DataSet.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.get.particular.gan.dataset",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> selectedDatasetForVersion( DeselectionOfDatasetRequest deselectionOfDatasetRequest) {
		try {
			Long versionID = deselectionOfDatasetRequest.getVersionID();
			Long datasetID = deselectionOfDatasetRequest.getDatasetID();
			if (gaudiAIVersionRepository.existsById(versionID) && ganDatasetRepository.existsById(datasetID)) {
				gaudiAIVersionRepository.updateGanDatasetIDByVersionID(new Date(System.currentTimeMillis()), datasetID,
						versionID);
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("selected.dataset.for.version.added.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Selected Dataset For Version Added Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Does No Exist Entity.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("does.no.exist.entity", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

			}
		} catch (Exception e) {
			LOG.error("Error In Selected Dataset For Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.selected.dataset.for.version",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> processDefaultGANResult(Long versionID, String ganModuletabName) {
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			LOG.info("Version id for processDefaultGANResult {}",gaudiAIVersion.get(0).getVersionID());
			String versionPath = gaudiAIVersion.get(0).getVersionPath();
			Long datasetID = gaudiAIVersion.get(0).getDatasetID();
			List<GanTrainingWizard> listGanTrainingWizard = ganTrainingWizardRepository.findBygaudiVersionId(versionID);
			List<GanChannels> listGanChannels = ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);
			List<String> listOfFolder = storageService.getListOfFolder(versionPath + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT);
			String classname= null;
			DefaultGanResultResponse defaultGanResultResponse = new DefaultGanResultResponse();
			if (listGanTrainingWizard.isEmpty() || gaudiAIVersion.get(0).getProcessStatus()==null) {
				return new ResponseEntity<>(defaultGanResultResponse, HttpStatus.OK);
			}else {
				Gson g = new Gson();
				List<?> convert = null;
				convert = g.fromJson(listGanTrainingWizard.get(0).getTrainClassName(), List.class);
				 classname=convert.get(0).toString();
			}
			
			if (listGanChannels.isEmpty()) {
				LOG.error("No Channel Listed. DatasetID - {}", datasetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.channel.listed.datasetid", null, LocaleContextHolder.getLocale())
								+ datasetID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
			if (listOfFolder.isEmpty()) {
				LOG.error("No Output Folder Created Under Result. DatasetID - {}", datasetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.output.folder.created.under.result.datasetid", null,
								LocaleContextHolder.getLocale())+ datasetID ,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

			}
			Collections.reverse(listOfFolder);
			ListOfGanResultResponse showCaseListOfFilesImages = processGANResult(versionID, ganModuletabName,
					listOfFolder.get(0), classname , listGanChannels.get(0).getChannelName(), 0, 10);

			defaultGanResultResponse.setFolderName(listOfFolder);
			defaultGanResultResponse
					.setListOfGanResultResponse(showCaseListOfFilesImages);
			return new ResponseEntity<>(defaultGanResultResponse, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Error In Process Default GAN Result.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.process.default.gan.result",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ListOfGanResultResponse processGANResult(
			final Long versionId,
			final String tabName,
			final String tickName,
			final String className,
			final String channelName,
			final int skip,
			final int rows
	) {
		final GaudiAIVersion gaudiAIVersion = gaudiAIVersionRepository.findByVersionID(versionId);
		if (gaudiAIVersion == null) {
			throw new BadRequestException(
					messageSource.getMessage(
							"version.not.found.by.given.versionID",
							null,
							LocaleContextHolder.getLocale()));
		}
		final String resultType = getResultType(versionId, tabName, tickName);

		final String imageFolderPath = Stream.of(
				gaudiAIVersion.getVersionPath(),
				ApplicationConstants.IMAGE,
				ApplicationConstants.RESULT,
				tickName,
				tabName,
				resultType,
				className,
				getChannelName(channelName))
				.filter(StringUtils::isNotBlank)
				.collect(Collectors.joining(File.separator));

		final List<String> images = new ArrayList<>();
		final File rootFolder = new File(imageFolderPath);

		if (!rootFolder.exists()) {
			return ListOfGanResultResponse.builder().listOfImage(Collections.emptyList()).totalImageCount(0).build();
		}
		storageService.searchForImageNames(rootFolder, images);

		final List<String> paginatedImages = images.stream()
				.sorted().skip(skip).limit(rows).collect(Collectors.toList());

		return ListOfGanResultResponse.builder()
				.listOfImage(paginatedImages)
				.totalImageCount(images.size())
				.build();
	}

	private String getResultType(
			final Long versionId,
			final String tabName,
			final String tickName

	) {
		final String autoFilter = getAutoFilter(versionId, tabName, tickName);

		if (ApplicationConstants.YES.equalsIgnoreCase(autoFilter)) {
			return ApplicationConstants.FILTER;
		} else {
			return ApplicationConstants.IMAGES;
		}
	}

	private String getAutoFilter(
			final Long versionId,
			final String tabName,
			final String tickName
	) {
		if (ApplicationConstants.TRAIN_MODULE.equalsIgnoreCase(tabName)) {
			final GanTrainingWizard ganTrainingWizard = ganTrainingWizardRepository.findByGaudiVersionId(versionId);
			if (ganTrainingWizard != null) {
				return ganTrainingWizard.getPostProcessAutoFilter();
			}
		} else if (ApplicationConstants.TEST_MODULE.equalsIgnoreCase(tabName)) {
			final GanTestWizard ganTestWizard = ganTestWizardRepository
					.findLatestGanTestWizardByGaudiVersionId(versionId, tickName);
			if (ganTestWizard != null) {
				return ganTestWizard.getTestAutoFilter();
			}
		} else {
			throw new BadRequestException(
					messageSource.getMessage(
							"not.correct.module.tab.name.given",
							null,
							LocaleContextHolder.getLocale()) + tabName);
		}
		return null;
	}

	private String getChannelName(final String channelName) {
		if (ApplicationConstants.COMPOSITE.equalsIgnoreCase(channelName)) {
			return null;
		}
		return channelName;
	}

	@Override
	public ResponseEntity<?> pauseProcess(String smartID) {
		PythonSucessResponse pythonSucessResponse = null;
		try {
			PythonSmartIDrequest pythonSmartIDrequest = new PythonSmartIDrequest();
			pythonSmartIDrequest.setSmartId(smartID);
			LOG.info("Calling Python backend API {}", pythonSmartIDrequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			pythonSucessResponse = webClient.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.PAUSE)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonSmartIDrequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
		} catch (WebClientException e) {
			LOG.error("Web Client Exception In pause process For smartID - {}", smartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("webclient.exception.in.pause.the.process.for.smartid", null,
							LocaleContextHolder.getLocale())+ smartID ,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		} catch (ServerErrorException e) {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 503,
					ApplicationConstants.SERVICE_UNAVAILABLE, messageSource.getMessage(
							"server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()),
					null);
			LOG.error("Server Error Exception. Please try after sometimes.");
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (Exception e) {
			LOG.error("Error In pause the process For smartID - {}",smartID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.pause.for.smartid", null, LocaleContextHolder.getLocale())
					+ smartID,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteGANClass(Long classID) {
		try {
			LOG.info("Deleted GAN Class  {} ", classID);
			if (ganClassRepository.existsById(classID)) {
				List<GanClass> listGanClass = ganClassRepository.findByClassID(classID);
				GanClass ganClass = null;
				GanClass ganClass1 = listGanClass.get(0);
				ganChannelImageRepository.updateClassLabelByGanClass(new Date(System.currentTimeMillis()), ganClass,
						ApplicationConstants.NO, ganClass1);
				ganClassRepository.deleteById(classID);

				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("deleted.gan.class.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Deleted GAN Class Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Does No Exist Class Entity.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("does.no.exist.class.entity", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Error In Delete GAN Class.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.delete.gan.class", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> resumeTrainWizard(Long trainingId) {
		PythonSucessResponse pythonSucessResponse = null;
		try {
			GanTrainingWizard ganTrainingWizard = ganTrainingWizardRepository.getReferenceById(trainingId);

			pythonSucessResponse = ganTrainingProcess(ganTrainingWizard);
			return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);
		} catch (WebClientRequestException e) {
			LOG.error("Error In  Resume Process  For trainingId - {}",trainingId);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("invalid.json.in.resume.process.for.trainingid", null,
							LocaleContextHolder.getLocale()) + trainingId,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServerErrorException e) {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 503,
					ApplicationConstants.SERVICE_UNAVAILABLE, messageSource.getMessage(
							"server.is.down.please.try.after.sometimes", null, LocaleContextHolder.getLocale()),
					null);
			LOG.error("Server Error Exception. Please try after sometimes.");
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (Exception e) {
			LOG.error("Error In Resume Process  For trainingId - {}", trainingId);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.resume.process.for.trainingId",
							null, LocaleContextHolder.getLocale()) + trainingId,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> discardTheimage(GanDiscardImageRequest ganDiscardImageRequest) {
		try {
			Long datasetID = ganDiscardImageRequest.getDatasetID();
			List<GanChannels> listGanChannels = ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);
			if(listGanChannels.size()==1) {
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage("Discarded The Images From Channel Successfully.");
				LOG.info("Discarded The Images From Channel Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
			
			discardTheChannel(listGanChannels, datasetID);
			
			Long latestCountOfGanChannels=ganChannelsRepository.countByDatasetID(datasetID);
			LOG.info("Latest Count Of Gan Channels :{}",latestCountOfGanChannels);
			List<GanChannelImage> listGanChannelImage = ganChannelImageRepository.findByDatasetID(datasetID);
			List<Long> listGanImageChannelID1 = new ArrayList<>();
			for (int i = 0; i < listGanChannelImage.size(); i++) {
				String likeStatement = listGanChannelImage.get(i).getImageName();
				likeStatement = likeStatement.substring(0, listGanChannelImage.get(i).getImageName().lastIndexOf(".")+1);
				List<Long> listGanImageChannelID = ganChannelImageRepository.findListOfImageByDatasetIDLike(datasetID,
						likeStatement);
				if (listGanImageChannelID.size() != latestCountOfGanChannels) {
					listGanImageChannelID1.addAll(listGanImageChannelID);
				} 
			}

			List<GanChannelImage> deleteGanChannelImage = ganChannelImageRepository
					.findChannelImageByChannelImageID(listGanImageChannelID1);
			for (int i = 0; i < deleteGanChannelImage.size(); i++) {
				ganChannelImageRepository.deleteById(deleteGanChannelImage.get(i).getChannelImageID());
				storageService.deleteImage(deleteGanChannelImage.get(i).getGanChannels().getChannelPath(),
						deleteGanChannelImage.get(i).getImageName());
			}

			HttpOperationResponseBean response = null;
			response = new HttpOperationResponseBean();
			response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			response.setStatus(HttpStatus.OK);
			response.setMessage("Discarded The Images From Channel Successfully.");
			LOG.info("Discarded The Images From Channel Successfully.");
			return new ResponseEntity<>(response, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Error In Discard The GAN Image");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.discard.the.gan.image", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}
	@Transactional
	public void discardTheChannel(List<GanChannels> listGanChannels, Long datasetID) throws IOException {
		for (GanChannels ganChannels : listGanChannels) {
			List<String> imageCount = storageService.getListOfFilesImages(ganChannels.getChannelPath());
			if (imageCount.isEmpty()) {
				storageService.deleteFolder(ganChannels.getChannelPath());
			}
		}

		for (int i = 0; i < listGanChannels.size(); i++) {
			Long channelID = listGanChannels.get(i).getChannelID();
			Long count = ganChannelImageRepository.countByDatasetIDAndGanChannelsAndIsActive(datasetID,
					listGanChannels.get(i), "Y");
			if (count == 0) {
				ganChannelsRepository.deleteById(channelID);
			}
		}

		List<GanChannels> renameListGanChannels = ganChannelsRepository.findListOfGanChannelsByDatasetID(datasetID);
		if (renameListGanChannels.size() != listGanChannels.size()) {
			GanDataset ganDataset = ganDatasetRepository.getDatasetByDatasetID(datasetID);
			for (int i = 0; i < renameListGanChannels.size(); i++) {

				File file1 = new File(renameListGanChannels.get(i).getChannelPath());
				File file2 = new File(
						ganDataset.getDatasetPath() + File.separator + ApplicationConstants.CHANNEL + (i + 1));
				file1.renameTo(file2);
				ganChannelsRepository.updateChannelNameChannelPathByChannelID(
						ApplicationConstants.CHANNEL + (i + 1), new Date(System.currentTimeMillis()),
						ganDataset.getDatasetPath() + File.separator + ApplicationConstants.CHANNEL + (i + 1),
						renameListGanChannels.get(i).getChannelID());
				ganDatasetRepository.updateNoOfChannelBydatasetID(new Date(System.currentTimeMillis()),
						(long) (i + 1), datasetID);
				LOG.info("File renamed : {}", file2);
			}
		}
		if(renameListGanChannels.isEmpty()) {
			ganDatasetRepository.updateNoOfChannelBydatasetID(new Date(System.currentTimeMillis()),
					0L, datasetID);
		}
	}
	@Override
	public ResponseEntity<?> getListOfGANResultFolder(Long versionID) {
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String versionPath = gaudiAIVersion.get(0).getVersionPath();
			List<String> listOfFolder = storageService.getListOfFolder(versionPath + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT);
			if (listOfFolder.isEmpty()) {
				LOG.error("No Output Folder Created Under Result. versionID - {}", versionID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.ouput.folder.created.under.result.versionid", null, LocaleContextHolder.getLocale()) + versionID, null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

			}
			Collections.reverse(listOfFolder);
			return new ResponseEntity<>(listOfFolder, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Error In List Of GAN Result Folder");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,messageSource.getMessage("error.in.list.of.gan.result.folder", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> deSelectionDatasetForVersion(DeselectionOfDatasetRequest deselectionOfDatasetRequest) {
		try { 
			Long versionID = deselectionOfDatasetRequest.getVersionID();
			Long datasetID = deselectionOfDatasetRequest.getDatasetID();
			if (gaudiAIVersionRepository.existsById(versionID) && ganDatasetRepository.existsById(datasetID)) {
				gaudiAIVersionRepository.updateGanDatasetIDByVersionID(new Date(System.currentTimeMillis()), null,
						versionID);
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("deselect.dataset.for.version.successfully", null, LocaleContextHolder.getLocale()));
				LOG.info("De-Selected Dataset For Version Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Does No Exist Entity.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage(messageSource.getMessage("does.no.exist.entity", null, LocaleContextHolder.getLocale()), null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Error In De-Selected Dataset For Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.deselected.dataset.for.version", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}
private boolean isDefaultModel(String folderName) {
	String path=baseFolderpath+File.separator+ApplicationConstants.DEFAULT_MODELS;
	List<String> fetchFolderNames = storageService.fetchFolderNames(path);
	for (String name : fetchFolderNames) {
		if(name.equals(folderName)) {
			return true;
		}
	}
	return false;
}
	@Override
	public ResponseEntity<?> saveGanTestWizard(GanTestWizardRequest ganTestWizardRequest) {
		GanTestWizard saveGanTestWizard = null;
		PythonSucessResponse pythonSucessResponse = null;
		try {
			GanTestWizard ganTestWizard = new GanTestWizard();
			ganTestWizard.setGaudiVersionId(ganTestWizardRequest.getGaudiVersionId());
			ganTestWizard.setCreatedBy(ganTestWizardRequest.getCreatedBy());
			ganTestWizard.setCreatedDate(new Date(System.currentTimeMillis()));
			ganTestWizard.setIsActive(ApplicationConstants.YES);
			ganTestWizard.setNoOfImagesPerClass(ganTestWizardRequest.getNoOfImagesPerClass());
			ganTestWizard.setTestAutoFilter(ganTestWizardRequest.getTestAutoFilter());
			String testClassName = new ObjectMapper().writeValueAsString(ganTestWizardRequest.getTestClassName());
			ganTestWizard.setTestClassNames(testClassName);
			ganTestWizard.setTestFolder(ganTestWizardRequest.getTestTick());
			if (ganTestWizardRequest.getTestAutoFilter().equalsIgnoreCase(ApplicationConstants.YES)) {
				ganTestWizard.setTestNoOfCluster(ganTestWizardRequest.getTestNoOfCluster());
			} else {
				ganTestWizard.setTestNoOfCluster(0L);
			}
			boolean defaultModel = isDefaultModel(ganTestWizardRequest.getTestTick());
			if(defaultModel) {
			ganTestWizard.setDefaultModel("Y");
			}else {
				ganTestWizard.setDefaultModel("N");
			}

			ganTestWizard.setTestSeed(ganTestWizardRequest.getTestSeed());
			saveGanTestWizard = ganTestWizardRepository.save(ganTestWizard);
			if(saveGanTestWizard.getTestId()>0) {
				pythonSucessResponse = ganTestProcess(saveGanTestWizard);
			}
				return new ResponseEntity<>(pythonSucessResponse, HttpStatus.OK);	
			
		} catch (WebClientResponseException |WebClientRequestException e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse,  HttpStatus.BAD_REQUEST);
		}  catch (ServerErrorException e) {
			LOG.error("Server Error Exception. Please try after sometimes");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes",
					null, LocaleContextHolder.getLocale()));
		} catch (IOException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource
					.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (Exception e) {
			LOG.error("Error In Save Generated Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.save.gan.test.json", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		

	}

	@Override
	public ResponseEntity<?> getGanTestWizard(Long testID) {
		GanTestWizardResponse ganTestWizardResponse = null;
		try {
			if(testID!=null) {
			List<GanTestWizard> listOfGanTest = ganTestWizardRepository.findBytestId(testID);
			if (!listOfGanTest.isEmpty()) {
				ganTestWizardResponse = setTestTabResponse(listOfGanTest.get(0));
				return new ResponseEntity<>(ganTestWizardResponse, HttpStatus.OK);
			} else {
				LOG.error("No gan test Data Available For testID - {}",testID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.the.test.data.for.testid", null,
								LocaleContextHolder.getLocale()) + testID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			}else {
				LOG.error("Error  - Get test Data.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("error.get.test.data", null, LocaleContextHolder.getLocale()), null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error  - Get test Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.get.test.data", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

		
	}

	private GanTestWizardResponse setTestTabResponse(GanTestWizard ganTestWizard) {

		GanTestWizardResponse ganTestWizardResponse = new GanTestWizardResponse();
		ganTestWizardResponse.setCreatedBy(ganTestWizard.getCreatedBy());
		ganTestWizardResponse.setCreatedDate(ganTestWizard.getCreatedDate());
		ganTestWizardResponse.setGaudiVersionId(ganTestWizard.getGaudiVersionId());
		ganTestWizardResponse.setIsActive(ganTestWizard.getIsActive());
		ganTestWizardResponse.setNoOfImagesPerClass(ganTestWizard.getNoOfImagesPerClass());
		ganTestWizardResponse.setTestAutoFilter(ganTestWizard.getTestAutoFilter());
		Gson g = new Gson();
		List<?> convert = null;
		convert = g.fromJson(ganTestWizard.getTestClassNames(), List.class);
		ganTestWizardResponse.setTestClassNames(convert);
		ganTestWizardResponse.setTestFolder(ganTestWizard.getTestFolder());
		ganTestWizardResponse.setTestId(ganTestWizard.getTestId());
		ganTestWizardResponse.setTestNoOfCluster(ganTestWizard.getTestNoOfCluster());
		ganTestWizardResponse.setIsDefaultModel(ganTestWizard.getDefaultModel());
		ganTestWizardResponse.setTestSeed(ganTestWizard.getTestSeed());
		return ganTestWizardResponse;

	}

	private PythonSucessResponse ganTestProcess(GanTestWizard ganTestWizard) throws IOException {
		PythonGanTestRequest pythonGanTestRequest = null;
		PythonSucessResponse pythonSucessResponse = null;
		try {
			pythonGanTestRequest = new PythonGanTestRequest();

			List<GanTestJsonRequest> listGanTest = new ArrayList<>();

			GanTestJsonRequest ganTestJsonRequest = new GanTestJsonRequest();

			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(ganTestWizard.getGaudiVersionId());
			pythonGanTestRequest.setOperation(Arrays.asList(ApplicationConstants.TEST));
			ganTestJsonRequest.setLogPath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.DOC + File.separator + ApplicationConstants.LOG);

			ganTestJsonRequest.setSmartId(gaudiAIVersion.get(0).getSmartID());

			ganTestJsonRequest.setRootPath(gaudiAIVersion.get(0).getVersionPath());
			ganTestJsonRequest.setIteration(ganTestWizard.getTestFolder());
			ganTestJsonRequest.setNoOfImage(ganTestWizard.getNoOfImagesPerClass());
			String jsonFilePath=null;
			if(ganTestWizard.getDefaultModel().equalsIgnoreCase(ApplicationConstants.NO)) {
				jsonFilePath= gaudiAIVersion.get(0).getVersionPath() + File.separator
						+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT+File.separator+ganTestWizard.getTestFolder()+File.separator+ApplicationConstants.MODEL_DATA_JSON;
				}else {
					 jsonFilePath=baseFolderpath+File.separator+ApplicationConstants.DEFAULT_MODELS+ File.separator + ganTestWizard.getTestFolder() + File.separator
								+ ApplicationConstants.MODEL_DATA_JSON;
				}
			JsonNode jsonNode=storageService.readJsonFile(jsonFilePath);
			ObjectMapper mapper = new ObjectMapper();
			List<?> classList = mapper.convertValue(jsonNode.get(ApplicationConstants.CLASS_LIST), ArrayList.class);			 
			ganTestJsonRequest.setClasses(classList);
			ganTestJsonRequest.setSeed(ganTestWizard.getTestSeed());
			boolean autoFilter = (ganTestWizard.getTestAutoFilter().equalsIgnoreCase(ApplicationConstants.NO)) ? false: true;
			ganTestJsonRequest.setAutoFilter(autoFilter);
			boolean defaultModel=(ganTestWizard.getDefaultModel().equalsIgnoreCase(ApplicationConstants.YES))?true:false;
			ganTestJsonRequest.setDefaultModel(defaultModel);
			ganTestJsonRequest.setNoOfCluster(ganTestWizard.getTestNoOfCluster());
			
			listGanTest.add(ganTestJsonRequest);

			pythonGanTestRequest.setParams(listGanTest);

			LOG.info(pythonGanTestRequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			pythonSucessResponse = webClient.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.TEST)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonGanTestRequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();

			LOG.info(pythonSucessResponse);
		
		} catch (ServiceUnavailableException e) {
			LOG.error("Connection Error. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource
					.getMessage("connection.error.please.try.after.sometimes", null, LocaleContextHolder.getLocale()));
		} catch (ServerErrorException e) {
			LOG.error("Server Error Exception. Please try after sometimes.");
			throw new ServiceUnavailableException(messageSource.getMessage("server.is.down.please.try.after.sometimes",
					null, LocaleContextHolder.getLocale()));
		}
		return pythonSucessResponse;
	}

	@Override
	public ResponseEntity<?> imageDimension(Long datasetID) {
		try {
			GanChannelImage ganChannelImage = ganChannelImageRepository
					.findOneByDatasetIDAndLabelledYNAndAndIsActive(datasetID, ApplicationConstants.YES, ApplicationConstants.YES);
			if (ganChannelImage != null) {
				String imagePath = ganChannelImage.getGanChannels().getChannelPath() + File.separator
						+ ganChannelImage.getImageName();
				ImagePlus imp = IJ.openImage(imagePath);
				
				ImageProperties imageProperties = new ImageProperties();
				imageProperties.setImagePath(imagePath);
				imageProperties.setImageName(ganChannelImage.getImageName());
				if (imp != null) {
					imageProperties.setImageHeight(imp.getHeight());
					imageProperties.setImageWidth(imp.getWidth());
				} else {
					imageProperties.setImageHeight(256);
					imageProperties.setImageWidth(256);
				}
				return new ResponseEntity<>(imageProperties, HttpStatus.OK);
			} else {

				LOG.error("No Image Available For datasetID {} .", datasetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.NO_CONTENT, messageSource.getMessage("no.image.available.for.datasetid", null, LocaleContextHolder.getLocale())+ datasetID , null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

			}
		} catch (Exception e) {
			LOG.error("Error  - Get Image Dimension.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,messageSource.getMessage("error.get.image.dimension", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ResponseEntity<?> deleteOutputFolder(Long versionID, String outputFolderName) {
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String outputFolderPath = gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT + File.separator
					+ outputFolderName;
			
			List<GanTestWizard> ganTestWizards = ganTestWizardRepository.findBygaudiVersionId(versionID);
			if(!ganTestWizards.isEmpty()) {
				List<GanTestWizard>	 ganTestWizard = ganTestWizardRepository.findGanTestWizardByGaudiVersionIdAndTestFolder(versionID,
						outputFolderName);
				for (GanTestWizard ganTestWizard2 : ganTestWizard) {
					Long testId = ganTestWizard2.getTestId();
					ganTestWizardRepository.deleteById(testId);
				}
			}
			
			File file = new File(outputFolderPath);
			if (!file.exists()) {
				LOG.error("OutputFolder Is Not Available To Delete.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT, messageSource.getMessage("output.folder.is.not.available.to.delete", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
			storageService.deleteFolder(outputFolderPath);
			HttpOperationResponseBean response = new HttpOperationResponseBean();
			response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			response.setStatus(HttpStatus.OK);
			response.setMessage(messageSource.getMessage("output.folder.deleted.successfully", null, LocaleContextHolder.getLocale()));
			LOG.info("Output Folder Deleted Successfully.");
			return new ResponseEntity<>(response, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Error  - Delete Output Folder.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.delete.output.folder", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ResponseEntity<?> deleteImageFromOutputFolder(Long versionID, String ganModuletabName,
			String outputFolderName, String className, String imageName) {
		try {
			Boolean status=false;
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			String versionPath = gaudiAIVersion.get(0).getVersionPath();

			int noToIterateTheLoop = 0;
			if (ganModuletabName.equalsIgnoreCase(ApplicationConstants.TRAIN_MODULE)) {
				List<GanTrainingWizard> listGanTrainingWizard = ganTrainingWizardRepository
						.findBygaudiVersionId(versionID);
				if(listGanTrainingWizard.isEmpty()) {

					LOG.error("No Gan Training Wizard Under VersionID - {}", versionID);
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
							ApplicationConstants.NO_CONTENT,messageSource.getMessage("no.gan.tarining.wizard.under.versionid" , null, LocaleContextHolder.getLocale())+ versionID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

				
				}
				String postProcessAutoFilter = listGanTrainingWizard.get(0).getPostProcessAutoFilter();
				noToIterateTheLoop = postProcessAutoFilter != null
						&& postProcessAutoFilter.equalsIgnoreCase(ApplicationConstants.YES) ? 2 : 1;
			}
			if (ganModuletabName.equalsIgnoreCase(ApplicationConstants.TEST_MODULE)) {
				GanTestWizard ganTestWizard = ganTestWizardRepository
						.findLatestGanTestWizardByGaudiVersionId(versionID,outputFolderName);
				if(ganTestWizard == null) {

					LOG.error("No Gan Test Wizard Under VersionID - {}", versionID);
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
							ApplicationConstants.NO_CONTENT,messageSource.getMessage("no.gan.tarining.wizard.under.versionid" , null, LocaleContextHolder.getLocale())+ versionID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

				
				}
				String testAutoFilter = ganTestWizard.getTestAutoFilter();
				noToIterateTheLoop = testAutoFilter != null && testAutoFilter.equalsIgnoreCase(ApplicationConstants.YES)
						? 2
						: 1;
			}

			String filter =ApplicationConstants.FILTER;
			String image = ApplicationConstants.IMAGES;

			List<GanChannels> listGanChannels = ganChannelsRepository
					.findListOfGanChannelsByDatasetID(gaudiAIVersion.get(0).getDatasetID());
			for (int i = 0; i < noToIterateTheLoop; i++) {
				if (!listGanChannels.isEmpty()) {
					for (GanChannels ganChannels : listGanChannels) {
						String filterPath = null;
						if (i == 0) {
							filterPath = versionPath + File.separator + ApplicationConstants.IMAGE + File.separator
									+ ApplicationConstants.RESULT + File.separator + outputFolderName + File.separator
									+ ganModuletabName + File.separator + image + File.separator + className
									+ File.separator + ganChannels.getChannelName() + File.separator;
						}
						if (i == 1) {
							filterPath = versionPath + File.separator + ApplicationConstants.IMAGE + File.separator
									+ ApplicationConstants.RESULT + File.separator + outputFolderName + File.separator
									+ ganModuletabName + File.separator + filter + File.separator + className
									+ File.separator + ganChannels.getChannelName() + File.separator;
						}
						List<String> listOfFilesImages = storageService.getListOfFilesImages(filterPath);
						if (!listOfFilesImages.isEmpty()) {
							ListOfGanResultResponse listOfGanResultResponse = new ListOfGanResultResponse();
							listOfGanResultResponse.setTotalImageCount(listOfFilesImages.size());
							for (int k = 0; k < listOfFilesImages.size(); k++) {
								if (listOfFilesImages.get(k).contains(imageName)) {
									storageService.deleteImage(filterPath, listOfFilesImages.get(k));
									status=true;
								}
							}
						}
					}
				}
			}
			if(Boolean.TRUE.equals(status)) {
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("result.images.deleted.successfully", null, LocaleContextHolder.getLocale()));
				LOG.info("Result Images Deleted Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
		} catch (Exception e) {
			LOG.error("Error In Delete Image From Output Folder.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					"Error In Delete Image From Output Folder.",
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
		return null;
	}

	@Override
	@Transactional
	public ResponseEntity<?> unLabelTheImage(UnLabelTheImageRequest unLabelTheImageRequest) {
		try {
			List<String> listOfChannelImage = unLabelTheImageRequest.getChannelImageName();
			if (!listOfChannelImage.isEmpty()) {
				Boolean labelStatus = false;
				for (int i = 0; i < listOfChannelImage.size(); i++) {
					String likeStatement = listOfChannelImage.get(i);
					likeStatement = likeStatement.substring(0, listOfChannelImage.get(i).lastIndexOf(".")+1);
					List<Long> listGanChannelID = ganChannelImageRepository
							.findListOfImageByDatasetIDLike(unLabelTheImageRequest.getDatasetID(), likeStatement);
					GanClass ganClass= null;
					int updateStatusID=ganChannelImageRepository.updateClassLabelByListChannelImageID(new Date(System.currentTimeMillis()),
							ganClass, ApplicationConstants.NO, listGanChannelID);
					if (updateStatusID > 0) {
						labelStatus = true;
					} else {
						labelStatus = false;
					}
				}
				if (Boolean.TRUE.equals(labelStatus)) {
					HttpOperationResponseBean response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage("Unlabelled The Image Successfully.");
					LOG.info("Unlabelled The Image Successfully.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					LOG.error("Unlabelled The Image Failed.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, "Unlabelled The Image Failed.", null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}

			} else {
				LOG.error("List Of Selected Image Empty.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("list.of.selected.image.empty", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Exception - Un Label The Image.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, "Exception - Un Label The Image.",
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}}
	
	@Override
	public ResponseEntity<?> saveGanTrainingSetting(GanTrainingWizardRequest ganSaveSettingRequest) {
		LOG.info("GANServiceImpl saveGanTrainingSetting() GanSaveSettingRequest - {}", ganSaveSettingRequest);
		GanTrainWizardSetting saveGanTrainWizardSetting = null;
		HttpOperationResponseBean response = null;
		try {
			int settingNameExistCount = ganSaveSettingRepository.countBySettingNameAndCreatedBy(
					ganSaveSettingRequest.getSettingName(), ganSaveSettingRequest.getCreatedBy());
			int defaultSettingNameExistCount = ganSaveSettingRepository.countBySettingNameAndCreatedBy(
					ganSaveSettingRequest.getSettingName(), null);
			if (settingNameExistCount > 0 || defaultSettingNameExistCount>0) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 302,
						ApplicationConstants.FOUND,
						messageSource.getMessage("duplicate.setting.name.entered.please.enter.different.setting.name",
								null, LocaleContextHolder.getLocale()),
						null);
				LOG.error("Duplicate Setting Name Entered. Please Enter Different Setting Name");
				return new ResponseEntity<>(errorResponse, HttpStatus.FOUND);
			} else {
				GanTrainWizardSetting ganTrainWizardSetting = new GanTrainWizardSetting();
				ganTrainWizardSetting.setSettingName(ganSaveSettingRequest.getSettingName());
				ganTrainWizardSetting.setSettingType(ganSaveSettingRequest.getSettingType());
				if (ganSaveSettingRequest.getDataHeight().equals(ganSaveSettingRequest.getDataWidth())) {
					ganTrainWizardSetting.setDataWidth(ganSaveSettingRequest.getDataWidth());
					ganTrainWizardSetting.setDataHeight(ganSaveSettingRequest.getDataHeight());
				} else {
					LOG.error("Data height and Width must be Same");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
									"data.height.and.width.must.be.same", null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				ganTrainWizardSetting.setDataUseGray(ganSaveSettingRequest.getDatauseGray());
				ganTrainWizardSetting.setOptimizerType(ganSaveSettingRequest.getOptimizerType());
				ganTrainWizardSetting.setOptimizerGLearningRate(ganSaveSettingRequest.getOptimizerGLearningRate());
				ganTrainWizardSetting.setOptimizerDLearningRate(ganSaveSettingRequest.getOptimizerDLearningRate());
				ganTrainWizardSetting.setOptimizerBeta1(ganSaveSettingRequest.getOptimizerBeta1());
				ganTrainWizardSetting.setOptimizerBeta2(ganSaveSettingRequest.getOptimizerBeta2());
				ganTrainWizardSetting.setOptimizerVisionLoss(ganSaveSettingRequest.getOptimizerVisionLoss());
				ganTrainWizardSetting.setTrainingArchitecture(ganSaveSettingRequest.getTrainingArchitecture());
				ganTrainWizardSetting.setTrainingIterations(ganSaveSettingRequest.getTrainingIterations());
				ganTrainWizardSetting.setTrainingBatchSize(ganSaveSettingRequest.getTrainingBatchSize());
				ganTrainWizardSetting.setTrainingGamma(ganSaveSettingRequest.getTrainingGamma());
				ganTrainWizardSetting
						.setTrainingMinimumIterations(ganSaveSettingRequest.getTrainingMinimumIterations());
				ganTrainWizardSetting.setTrainingNoOfWorkers(ganSaveSettingRequest.getTrainingNoOfWorkers());
				ganTrainWizardSetting.setTrainingSampleInterval(ganSaveSettingRequest.getTrainingSampleInterval());
				ganTrainWizardSetting.setTrainingSampleNumber(ganSaveSettingRequest.getTrainingSampleNumber());
				ganTrainWizardSetting.setTrainingSeedPoint(ganSaveSettingRequest.getTrainingSeedPoint());
				ganTrainWizardSetting.setAugmentation(ganSaveSettingRequest.getAugmentation());
				if (ganTrainWizardSetting.getAugmentation().equalsIgnoreCase(ApplicationConstants.NOAUG)) {

					ganTrainWizardSetting.setAugmentationXFrac(0.0f);
					ganTrainWizardSetting.setAugmentationAnisotropy(0.0f);
					ganTrainWizardSetting.setAugmentationBrightness(0.0f);
					ganTrainWizardSetting.setAugmentationContrast(0.0f);
					ganTrainWizardSetting.setAugmentationIntegerTranslation(0.0f);
					ganTrainWizardSetting.setAugmentationPValue(0.0f);
					ganTrainWizardSetting.setAugmentationRotate(0.0f);
					ganTrainWizardSetting.setAugmentationRotate90(0.0f);
					ganTrainWizardSetting.setAugmentationScalling(0.0f);
					ganTrainWizardSetting.setAugmentationTarget(0.0f);
					ganTrainWizardSetting.setAugmentationXFlip(0.0f);
					ganTrainWizardSetting.setAugmentationHue(0.0f);
					ganTrainWizardSetting.setAugmentationLumaFlip(0.0f);
					ganTrainWizardSetting.setAugmentationSaturation(0.0f);
				} else {
					ganTrainWizardSetting.setAugmentationXFrac(ganSaveSettingRequest.getAugmentationXFrac());
					ganTrainWizardSetting.setAugmentationAnisotropy(ganSaveSettingRequest.getAugmentationAnisotropy());
					ganTrainWizardSetting.setAugmentationBrightness(ganSaveSettingRequest.getAugmentationBrightness());
					ganTrainWizardSetting.setAugmentationContrast(ganSaveSettingRequest.getAugmentationContrast());
					ganTrainWizardSetting.setAugmentationIntegerTranslation(
							ganSaveSettingRequest.getAugmentationIntegerTranslation());
					ganTrainWizardSetting.setAugmentationPValue(ganSaveSettingRequest.getAugmentationPValue());
					ganTrainWizardSetting.setAugmentationRotate(ganSaveSettingRequest.getAugmentationRotate());
					ganTrainWizardSetting.setAugmentationRotate90(ganSaveSettingRequest.getAugmentationRotate90());
					ganTrainWizardSetting.setAugmentationScalling(ganSaveSettingRequest.getAugmentationScalling());
					ganTrainWizardSetting.setAugmentationTarget(ganSaveSettingRequest.getAugmentationTarget());
					ganTrainWizardSetting.setAugmentationXFlip(ganSaveSettingRequest.getAugmentationXFlip());
					ganTrainWizardSetting.setAugmentationHue(ganSaveSettingRequest.getAugmentationHue());
					ganTrainWizardSetting.setAugmentationLumaFlip(ganSaveSettingRequest.getAugmentationLumaFlip());
					ganTrainWizardSetting.setAugmentationSaturation(ganSaveSettingRequest.getAugmentationSaturation());
				}
				ganTrainWizardSetting.setPostProcessAutoFilter(ganSaveSettingRequest.getPostProcessAutoFilter());
				if (ganTrainWizardSetting.getPostProcessAutoFilter().equalsIgnoreCase(ApplicationConstants.YES)) {
					ganTrainWizardSetting.setPostProcessNoOfCluster(ganSaveSettingRequest.getPostProcessNoOfCluster());
				} else {
					ganTrainWizardSetting.setPostProcessNoOfCluster(0L);
				}
				ganTrainWizardSetting
						.setPostProcessGenerateHeight(ganSaveSettingRequest.getPostProcessGenerateHeight());
				ganTrainWizardSetting.setPostProcessGenerateWidth(ganSaveSettingRequest.getPostProcessGenerateWidth());
				ganTrainWizardSetting.setCreatedBy(ganSaveSettingRequest.getCreatedBy());
				ganTrainWizardSetting.setIsActive(ApplicationConstants.YES);
				ganTrainWizardSetting.setCreatedDate(new Date(System.currentTimeMillis()));
				saveGanTrainWizardSetting = ganSaveSettingRepository.save(ganTrainWizardSetting);

				if (saveGanTrainWizardSetting.getSettingID() > 0) {
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.CREATED);
					response.setMessage(messageSource.getMessage("gan.training.setting.saved.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("GAN TrainWizard Setting saved Successfully.");
					return new ResponseEntity<>(response, HttpStatus.CREATED);
				} else {
					LOG.error("GAN TrainWizard Setting Creatation Failure.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("error.in.save.gan.trainWizard.setting", null,
									LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			}
		} catch (Exception e) {
			LOG.error("Exception - GAN TrainWizard Setting Creatation Failure.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.save.gan.trainWizard.setting",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	@Override
	public ResponseEntity<?> getGanTrainingSettingData(Long settingID,Long datasetID) {
		LOG.info("GanServiceImpl getGanTrainingSettingData() settingID - {}", settingID);
		GanTrainingResponse ganSaveSettingReponse = null;
		try {
			if (datasetID == null) {
				LOG.error("Please Link The Version With DataSet");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("please.link.the.version.with.dataset", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
			if (ganSaveSettingRepository.existsById(settingID)) {
				List<GanTrainWizardSetting> ganTrainingWizardSettingList = ganSaveSettingRepository
						.getGanTrainingWizardSettingBySettingID(settingID);
				ganSaveSettingReponse = setTrainingWizardSettingTabResponse(ganTrainingWizardSettingList.get(0));
				ResponseEntity<?> imageDimensionData=imageDimension(datasetID);
				if (imageDimensionData.getStatusCode().equals(HttpStatus.OK)) {
					ImageProperties body = (ImageProperties) imageDimensionData.getBody();
					ganSaveSettingReponse.setPostProcessGenerateHeight((long)body.getImageHeight());
					ganSaveSettingReponse.setPostProcessGenerateWidth((long) body.getImageWidth());
				}
				LOG.info("Get Gan Training Setting Data Successfully");
				return new ResponseEntity<>(ganSaveSettingReponse, HttpStatus.OK);
			} else {

				LOG.error("No gan Training Setting Data Available For settingID {},datasetID {} .", settingID,datasetID);
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("do.not.find.data.for.settingid.datasetid", null,
								LocaleContextHolder.getLocale()) + settingID+ApplicationConstants.FORWORD_SHLASH+datasetID,
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

		} catch (Exception e) {
			LOG.error("Error  - Get Training setting Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.get.training.setting.data", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	

	}

	private GanTrainingResponse setTrainingWizardSettingTabResponse(GanTrainWizardSetting ganTrainingWizardSetting) {

		GanTrainingResponse ganSaveSettingReponse = new GanTrainingResponse();
		ganSaveSettingReponse.setSettingID(ganTrainingWizardSetting.getSettingID());
		ganSaveSettingReponse.setSettingName(ganTrainingWizardSetting.getSettingName());
		ganSaveSettingReponse.setSettingType(ganTrainingWizardSetting.getSettingType());
		ganSaveSettingReponse.setTrainingArchitecture(ganTrainingWizardSetting.getTrainingArchitecture());
		ganSaveSettingReponse.setDataWidth(ganTrainingWizardSetting.getDataWidth());
		ganSaveSettingReponse.setDataHeight(ganTrainingWizardSetting.getDataHeight());
		ganSaveSettingReponse.setDatauseGray(ganTrainingWizardSetting.getDataUseGray());
		ganSaveSettingReponse.setOptimizerType(ganTrainingWizardSetting.getOptimizerType());
		ganSaveSettingReponse.setOptimizerGLearningRate(ganTrainingWizardSetting.getOptimizerGLearningRate());
		ganSaveSettingReponse.setOptimizerDLearningRate(ganTrainingWizardSetting.getOptimizerDLearningRate());
		ganSaveSettingReponse.setOptimizerBeta1(ganTrainingWizardSetting.getOptimizerBeta1());
		ganSaveSettingReponse.setOptimizerBeta2(ganTrainingWizardSetting.getOptimizerBeta2());
		ganSaveSettingReponse.setOptimizerVisionLoss(ganTrainingWizardSetting.getOptimizerVisionLoss());
		ganSaveSettingReponse.setTrainingIterations(ganTrainingWizardSetting.getTrainingIterations());
		ganSaveSettingReponse.setTrainingBatchSize(ganTrainingWizardSetting.getTrainingBatchSize());
		ganSaveSettingReponse.setTrainingGamma(ganTrainingWizardSetting.getTrainingGamma());
		ganSaveSettingReponse.setTrainingMinimumIterations(ganTrainingWizardSetting.getTrainingMinimumIterations());
		ganSaveSettingReponse.setTrainingNoOfWorkers(ganTrainingWizardSetting.getTrainingNoOfWorkers());
		ganSaveSettingReponse.setTrainingSampleInterval(ganTrainingWizardSetting.getTrainingSampleInterval());
		ganSaveSettingReponse.setTrainingSampleNumber(ganTrainingWizardSetting.getTrainingSampleNumber());
		ganSaveSettingReponse.setTrainingSeedPoint(ganTrainingWizardSetting.getTrainingSeedPoint());
		ganSaveSettingReponse.setAugmentation(ganTrainingWizardSetting.getAugmentation());
		ganSaveSettingReponse.setAugmentationXFrac(ganTrainingWizardSetting.getAugmentationXFrac());
		ganSaveSettingReponse.setAugmentationAnisotropy(ganTrainingWizardSetting.getAugmentationAnisotropy());
		ganSaveSettingReponse.setAugmentationBrightness(ganTrainingWizardSetting.getAugmentationBrightness());
		ganSaveSettingReponse.setAugmentationContrast(ganTrainingWizardSetting.getAugmentationContrast());
		ganSaveSettingReponse
				.setAugmentationIntegerTranslation(ganTrainingWizardSetting.getAugmentationIntegerTranslation());
		ganSaveSettingReponse.setAugmentationPValue(ganTrainingWizardSetting.getAugmentationPValue());
		ganSaveSettingReponse.setAugmentationRotate(ganTrainingWizardSetting.getAugmentationRotate());
		ganSaveSettingReponse.setAugmentationRotate90(ganTrainingWizardSetting.getAugmentationRotate90());
		ganSaveSettingReponse.setAugmentationScalling(ganTrainingWizardSetting.getAugmentationScalling());
		ganSaveSettingReponse.setAugmentationTarget(ganTrainingWizardSetting.getAugmentationTarget());
		ganSaveSettingReponse.setAugmentationXFlip(ganTrainingWizardSetting.getAugmentationXFlip());
		ganSaveSettingReponse.setAugmentationHue(ganTrainingWizardSetting.getAugmentationHue());
		ganSaveSettingReponse.setAugmentationLumaFlip(ganTrainingWizardSetting.getAugmentationLumaFlip());
		ganSaveSettingReponse.setAugmentationSaturation(ganTrainingWizardSetting.getAugmentationSaturation());
		ganSaveSettingReponse.setPostProcessAutoFilter(ganTrainingWizardSetting.getPostProcessAutoFilter());
		ganSaveSettingReponse.setPostProcessNoOfCluster(ganTrainingWizardSetting.getPostProcessNoOfCluster());
		ganSaveSettingReponse.setPostProcessGenerateHeight(ganTrainingWizardSetting.getPostProcessGenerateHeight());
		ganSaveSettingReponse.setPostProcessGenerateWidth(ganTrainingWizardSetting.getPostProcessGenerateWidth());
		ganSaveSettingReponse.setCreatedBy(ganTrainingWizardSetting.getCreatedBy());
		ganSaveSettingReponse.setCreatedDate(ganTrainingWizardSetting.getCreatedDate());
		ganSaveSettingReponse.setModifiedDate(ganTrainingWizardSetting.getModifiedDate());
		ganSaveSettingReponse.setIsActive(ganTrainingWizardSetting.getIsActive());

		return ganSaveSettingReponse;
	}

	@Override
	@Transactional
	public ResponseEntity<?> updateTrainingSettingData(GanTrainingWizardRequest ganSaveSettingRequest) {
		LOG.info("GanServiceImpl updateTrainingSettingData() ganTrainingWizardRequest : - {}", ganSaveSettingRequest);
		HttpOperationResponseBean httpResponse = null;
		List<GanTrainWizardSetting> existTrainingData = ganSaveSettingRepository
				.getGanTrainingWizardSettingBySettingID(ganSaveSettingRequest.getSettingID());
		Long ganSettingID = ganSaveSettingRequest.getSettingID();

		try {
			if (ganSettingID != null) {

				if (existTrainingData.isEmpty()) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("do.not.find.the.training.setting.data.for.settingID", null,
									LocaleContextHolder.getLocale()) + ganSettingID,
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}

				GanTrainWizardSetting ganTrainWizardSetting = ganSaveSettingRepository.getReferenceById(ganSettingID);

				ganTrainWizardSetting.setSettingType(ganSaveSettingRequest.getSettingType());
				ganTrainWizardSetting.setTrainingArchitecture(ganSaveSettingRequest.getTrainingArchitecture());

				if (ganSaveSettingRequest.getDataHeight().equals(ganSaveSettingRequest.getDataWidth())) {
					ganTrainWizardSetting.setDataWidth(ganSaveSettingRequest.getDataWidth());
					ganTrainWizardSetting.setDataHeight(ganSaveSettingRequest.getDataHeight());
				} else {
					LOG.error("Data height and Width must be Same");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
									"data.height.and.width.must.be.same", null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}

				ganTrainWizardSetting.setDataUseGray(ganSaveSettingRequest.getDatauseGray());
				ganTrainWizardSetting.setOptimizerType(ganSaveSettingRequest.getOptimizerType());
				ganTrainWizardSetting.setOptimizerGLearningRate(ganSaveSettingRequest.getOptimizerGLearningRate());
				ganTrainWizardSetting.setOptimizerDLearningRate(ganSaveSettingRequest.getOptimizerDLearningRate());
				ganTrainWizardSetting.setOptimizerBeta1(ganSaveSettingRequest.getOptimizerBeta1());
				ganTrainWizardSetting.setOptimizerBeta2(ganSaveSettingRequest.getOptimizerBeta2());
				ganTrainWizardSetting.setOptimizerVisionLoss(ganSaveSettingRequest.getOptimizerVisionLoss());
				ganTrainWizardSetting.setTrainingIterations(ganSaveSettingRequest.getTrainingIterations());
				ganTrainWizardSetting.setTrainingBatchSize(ganSaveSettingRequest.getTrainingBatchSize());
				ganTrainWizardSetting.setTrainingGamma(ganSaveSettingRequest.getTrainingGamma());
				ganTrainWizardSetting
						.setTrainingMinimumIterations(ganSaveSettingRequest.getTrainingMinimumIterations());
				ganTrainWizardSetting.setTrainingNoOfWorkers(ganSaveSettingRequest.getTrainingNoOfWorkers());
				ganTrainWizardSetting.setTrainingSampleInterval(ganSaveSettingRequest.getTrainingSampleInterval());
				ganTrainWizardSetting.setTrainingSampleNumber(ganSaveSettingRequest.getTrainingSampleNumber());
				ganTrainWizardSetting.setTrainingSeedPoint(ganSaveSettingRequest.getTrainingSeedPoint());
				ganTrainWizardSetting.setAugmentation(ganSaveSettingRequest.getAugmentation());
				if (ganTrainWizardSetting.getAugmentation().equalsIgnoreCase(ApplicationConstants.NOAUG)) {

					ganTrainWizardSetting.setAugmentationXFrac(0.0f);
					ganTrainWizardSetting.setAugmentationAnisotropy(0.0f);
					ganTrainWizardSetting.setAugmentationBrightness(0.0f);
					ganTrainWizardSetting.setAugmentationContrast(0.0f);
					ganTrainWizardSetting.setAugmentationIntegerTranslation(0.0f);
					ganTrainWizardSetting.setAugmentationPValue(0.0f);
					ganTrainWizardSetting.setAugmentationRotate(0.0f);
					ganTrainWizardSetting.setAugmentationRotate90(0.0f);
					ganTrainWizardSetting.setAugmentationScalling(0.0f);
					ganTrainWizardSetting.setAugmentationTarget(0.0f);
					ganTrainWizardSetting.setAugmentationXFlip(0.0f);
					ganTrainWizardSetting.setAugmentationHue(0.0f);
					ganTrainWizardSetting.setAugmentationLumaFlip(0.0f);
					ganTrainWizardSetting.setAugmentationSaturation(0.0f);
				} else {

					ganTrainWizardSetting.setAugmentationXFrac(ganSaveSettingRequest.getAugmentationXFrac());
					ganTrainWizardSetting.setAugmentationAnisotropy(ganSaveSettingRequest.getAugmentationAnisotropy());
					ganTrainWizardSetting.setAugmentationBrightness(ganSaveSettingRequest.getAugmentationBrightness());
					ganTrainWizardSetting.setAugmentationContrast(ganSaveSettingRequest.getAugmentationContrast());
					ganTrainWizardSetting.setAugmentationIntegerTranslation(
							ganSaveSettingRequest.getAugmentationIntegerTranslation());
					ganTrainWizardSetting.setAugmentationPValue(ganSaveSettingRequest.getAugmentationPValue());
					ganTrainWizardSetting.setAugmentationRotate(ganSaveSettingRequest.getAugmentationRotate());
					ganTrainWizardSetting.setAugmentationRotate90(ganSaveSettingRequest.getAugmentationRotate90());
					ganTrainWizardSetting.setAugmentationScalling(ganSaveSettingRequest.getAugmentationScalling());
					ganTrainWizardSetting.setAugmentationTarget(ganSaveSettingRequest.getAugmentationTarget());
					ganTrainWizardSetting.setAugmentationXFlip(ganSaveSettingRequest.getAugmentationXFlip());
					ganTrainWizardSetting.setAugmentationHue(ganSaveSettingRequest.getAugmentationHue());
					ganTrainWizardSetting.setAugmentationLumaFlip(ganSaveSettingRequest.getAugmentationLumaFlip());
					ganTrainWizardSetting.setAugmentationSaturation(ganSaveSettingRequest.getAugmentationSaturation());
				}
				ganTrainWizardSetting.setPostProcessAutoFilter(ganSaveSettingRequest.getPostProcessAutoFilter());
				if (ganTrainWizardSetting.getPostProcessAutoFilter().equalsIgnoreCase(ApplicationConstants.YES)) {
					ganTrainWizardSetting.setPostProcessNoOfCluster(ganSaveSettingRequest.getPostProcessNoOfCluster());
				} else {
					ganTrainWizardSetting.setPostProcessNoOfCluster(0L);
				}
				ganTrainWizardSetting
						.setPostProcessGenerateHeight(ganSaveSettingRequest.getPostProcessGenerateHeight());
				ganTrainWizardSetting.setPostProcessGenerateWidth(ganSaveSettingRequest.getPostProcessGenerateWidth());

				ganTrainWizardSetting.setCreatedBy(ganSaveSettingRequest.getCreatedBy());
				ganTrainWizardSetting.setIsActive(ApplicationConstants.YES);
				ganTrainWizardSetting.setModifiedDate(new Date(System.currentTimeMillis()));
				LOG.info(ganTrainWizardSetting);

					ganSaveSettingRepository.save(ganTrainWizardSetting);
					httpResponse = new HttpOperationResponseBean();
					httpResponse.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					httpResponse.setStatus(HttpStatus.OK);
					httpResponse.setMessage(messageSource.getMessage("gan.training.setting.Updated.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("The Training Setting data Updated successfully.");
					return new ResponseEntity<>(httpResponse, HttpStatus.OK);
				
		   } else {
			LOG.error("Error In The training setting Data For ganSettingID {}- " + ganSettingID);
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("do.not.find.the.training.setting.data.for.settingID",
							null, LocaleContextHolder.getLocale())+ ganSettingID,
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
			
		} catch (Exception e) {
			LOG.error("Error In Updating The Training setting Data");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.updating.the.training.setting.data", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public ResponseEntity<?> getListOfGANTrainingSetting(Long userID) {
		LOG.info("GanServiceImpl getListOfGANTrainingSetting() userID - {}", userID);
		ListOfGanTrainingSettings listOfGanTrainingSettings = null;
		try {
			listOfGanTrainingSettings = new ListOfGanTrainingSettings();
			List<GanTrainWizardSetting> defaultListOfGanTrainingSetting = ganSaveSettingRepository
					.findDefaultGanTrainWizardSettings();
			List<GanTrainWizardSetting> customListOfGanTrainingSetting = ganSaveSettingRepository
					.findByCreatedBy(userID);

			if (!customListOfGanTrainingSetting.isEmpty()) {
				listOfGanTrainingSettings.setDefaultSettings(defaultListOfGanTrainingSetting);
				listOfGanTrainingSettings.setCustomSettings(customListOfGanTrainingSetting);
				LOG.info("Get listOfGanTrainingSetting Delivered Successfully");
				return new ResponseEntity<>(listOfGanTrainingSettings, HttpStatus.OK);
			} else {
				listOfGanTrainingSettings.setDefaultSettings(defaultListOfGanTrainingSetting);
				listOfGanTrainingSettings.setCustomSettings(null);
				LOG.info("Get listOfGanTrainingSetting Delivered Successfully");
				return new ResponseEntity<>(listOfGanTrainingSettings, HttpStatus.OK);
			}

		} catch (Exception e) {
			LOG.error("Error In Get List Of GAN Training Setting.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
							"error.in.get.list.of.gan.training.setting", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	public ResponseEntity<?> deleteGanTrainingSetting(Long settingID) {
		LOG.info("GanServiceImpl deleteGanTrainingSetting() settingID - {}", settingID);
		try {
			if (ganSaveSettingRepository.existsById(settingID)) {
				ganSaveSettingRepository.deleteById(settingID);
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("gan.training.setting.deleted.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Gan Training Setting Deleted Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("GanTrainingSetting  Is Not Available To Delete.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("gan.training.setting.is.not.available.to.delete", null,
								LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);

			}
		} catch (Exception e) {
			LOG.error("Error  - Delete Gan Training Setting.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.delete.gan.training.setting",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteDataset(Long datasetID) {
		try {
			if (ganDatasetRepository.existsById(datasetID)) {
				GanDataset ganDataset = ganDatasetRepository.getDatasetByDatasetID(datasetID);
				String ganDatasetPath = ganDataset.getDatasetPath();
				gaudiAIVersionRepository.updateDatasetIDNull(new Date(System.currentTimeMillis()), null, datasetID);
				ganChannelImageRepository.deleteChannelImageByDatasetID(datasetID);
				ganChannelsRepository.deleteGanChannelsByDatasetID(datasetID);
				ganClassRepository.deleteGanClassByDatasetID(datasetID);
				ganDatasetRepository.deleteGanDatasetByDatasetID(datasetID);
				storageService.deleteFolder(ganDatasetPath);
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage("Gan Dataset Deleted Successfully.");
				LOG.info("Gan Dataset Deleted Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.error("Dataset Is Not Available To Delete.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,"Dataset Is Not Available To Delete.",null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} catch (Exception e) {
			LOG.error("Error  - Delete Gan Dataset.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
							"exception.get.list.Of.gan.class.from.json", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		
		}
	}

	@Override
	public ResponseEntity<?> getListOfGANClassFromJson(Long versionID, String folderName) {
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(versionID);
			if(!gaudiAIVersionRepository.existsById(versionID)) {
				LOG.error("Version Does Not Exist.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("version.does.not.exist", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
			String jsonFilePath= gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.IMAGE + File.separator + ApplicationConstants.RESULT+File.separator+folderName+File.separator+ApplicationConstants.MODEL_DATA_JSON;

			JsonNode jsonNode=storageService.readJsonFile(jsonFilePath);
			ObjectMapper mapper = new ObjectMapper();
			List<?> classList = mapper.convertValue(jsonNode.get(ApplicationConstants.CLASS_LIST), ArrayList.class);
			ListOfGanClass listOfGanClass = new ListOfGanClass();
			listOfGanClass.setClassName(classList);
			return new ResponseEntity<>(listOfGanClass, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Exception - Get List Of GAN Class From Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage(
							"exception.get.list.Of.gan.class.from.json", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}
	
	@Override
	public ResponseEntity<?> getListOfGANChannelFromJson(Long versionID, String folderName) {
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if (!gaudiAIVersionRepository.existsById(versionID)) {
				LOG.error("Version Does Not Exist.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("version.does.not.exist", null, LocaleContextHolder.getLocale()),
						null);

				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
			String jsonFilePath =null;
			boolean defaultModel = isDefaultModel(folderName);

			if(defaultModel) {
				jsonFilePath=baseFolderpath+File.separator+ApplicationConstants.DEFAULT_MODELS+ File.separator + folderName + File.separator
				+ ApplicationConstants.MODEL_DATA_JSON;
			}else {
			jsonFilePath= gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
					+ File.separator + ApplicationConstants.RESULT + File.separator + folderName + File.separator
					+ ApplicationConstants.MODEL_DATA_JSON;
			}
			JsonNode jsonNode = storageService.readJsonFile(jsonFilePath);
			ObjectMapper mapper = new ObjectMapper();
			Long channelNumber = mapper.convertValue(jsonNode.get(ApplicationConstants.DATA_CHANNELS), Long.class);
			List<String> channelName = new ArrayList<>();
			for (int i = 0; i < channelNumber; i++) {
				channelName.add(ApplicationConstants.CHANNEL + (i + 1));
			}
			ListOfGanChannel listOfGanChannel = new ListOfGanChannel();
			listOfGanChannel.setChannelName(channelName);
			return new ResponseEntity<>(listOfGanChannel, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Exception - Get List Of GAN Channel From Json.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("exception.get.list.Of.gan.channel.from.json", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	@Override
	public ResponseEntity<List<String>> getListOfDefaultModelName() {
		try {
		
			String pathToDefaultModels=baseFolderpath+File.separator+ApplicationConstants.DEFAULT_MODELS;
			List<String> list = storageService.fetchFolderNames(pathToDefaultModels);
			LOG.info("get List Of GAN Default Model Channel And Class From Json successfully");
			return new ResponseEntity<>(list, HttpStatus.OK);
		} catch (Exception e) {
			LOG.error("Exception - Get List Of Default Models.");
			throw new BadRequestException(messageSource.getMessage("exception.get.list.Of.gan.default.models", null,
					LocaleContextHolder.getLocale()));
		}
			
		
	}
	@SuppressWarnings("unchecked")
	@Override
	public ResponseEntity<GanDefaultModelClassAndChannel> getListOfGANDefaultModelChannelAndClassFromJson(String folderName) {
		GanDefaultModelClassAndChannel classAndChannel=null;
		try {
			String pathToDefaultModelsJson=baseFolderpath+File.separator+ApplicationConstants.DEFAULT_MODELS+ File.separator + folderName + File.separator
					+ ApplicationConstants.MODEL_DATA_JSON;
			JsonNode jsonNode;
			
				jsonNode = storageService.readJsonFile(pathToDefaultModelsJson);
			
			ObjectMapper mapper = new ObjectMapper();
			List<String> classList = mapper.convertValue(jsonNode.get(ApplicationConstants.CLASS_LIST), ArrayList.class);
			Long channelNumber = mapper.convertValue(jsonNode.get(ApplicationConstants.DATA_CHANNELS), Long.class);
			List<String> channelName = new ArrayList<>();
			for (int i = 0; i < channelNumber; i++) {
				channelName.add(ApplicationConstants.CHANNEL + (i + 1));
			}
			classAndChannel=new GanDefaultModelClassAndChannel();
			classAndChannel.setClassName(classList);
			classAndChannel.setChannelName(channelName);
			LOG.info("get List Of GAN Default Model Channel And Class From Json successfully");
			return new ResponseEntity<>(classAndChannel, HttpStatus.OK);
			} catch (IOException e) {
				LOG.error("Exception - Get List Of Default Model className and ChannelName");
				throw new BadRequestException(messageSource.getMessage("exception.get.list.Of.gan.default.model.classname.and.channelname", null,
						LocaleContextHolder.getLocale()));
			}
			
	}
}
-----------------------------------------------------------------------------------------------------------------------------
imageProcessing.java
---------------------
package com.gaudi.ai.service;

import org.springframework.http.ResponseEntity;
import org.springframework.web.multipart.MultipartHttpServletRequest;

import com.gaudi.ai.request.DeleteImageRequest;
import com.gaudi.ai.request.ImageProcessingGenerateRequest;

public interface ImageProcessingService {

	ResponseEntity<?> imageProcessing(ImageProcessingGenerateRequest imageProcessingGenerateRequest);
	
	ResponseEntity<?> deleteImageProcessingImage(DeleteImageRequest deleteImageRequest);
	
	public void saveDefectImage(MultipartHttpServletRequest request);

	ResponseEntity<?> getIPParticularVersion(Long versionID);
}
-----------------------------------------------------------------------------------------------------------------
ImageProcessingService.impl

package com.gaudi.ai.service;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Locale.LanguageRange;
import java.util.SortedSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.constants.PythonServiceEndPointConstant;
import com.gaudi.ai.exception.AppError;
import com.gaudi.ai.exception.FileUploadException;
import com.gaudi.ai.exception.ServiceUnavailableException;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import com.gaudi.ai.request.DeleteImageRequest;
import com.gaudi.ai.request.FileInfo;
import com.gaudi.ai.request.ImageProcessingGenerateRequest;
import com.gaudi.ai.request.ImageProcessingJsonRequest;
import com.gaudi.ai.request.PythonImageProcessingRequest;
import com.gaudi.ai.response.GaudiAIIPVersionData;
import com.gaudi.ai.response.HttpOperationResponseBean;
import com.gaudi.ai.response.IPTabDetails;
import com.gaudi.ai.response.PythonSucessResponse;
import com.gaudi.ai.util.ApplicationUtil;
import com.google.gson.Gson;

@Service
public class ImageProcessingServiceImpl  implements ImageProcessingService {

	private static final Logger LOG = LogManager.getLogger(ImageProcessingServiceImpl.class);
	
	@Autowired
	private GaudiAIVersionRepository gaudiAIVersionRepository;
	
	@Autowired
	private ApplicationUtil applicationUtil;

	@Autowired
	private MessageSource messageSource;

	@Autowired
	private WebClient webClient;

	@Value("#{'${gaudiServiceUrl}'}")
	String gaudiServiceUrl;
	
	@Autowired
	private FilesStorageService filesStorageService;
	
	@Override
	public ResponseEntity<?> imageProcessing(ImageProcessingGenerateRequest imageProcessingGenerateRequest) {
		PythonImageProcessingRequest pythonImageProcessingRequest = null;
		PythonSucessResponse sucessResponse = null;
		HttpOperationResponseBean responseBean = null;
		try {
			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository
					.findListOfVersionByVersionID(imageProcessingGenerateRequest.getGaudiVersionID());

			ImageProcessingJsonRequest imageProcessingJsonRequest = new ImageProcessingJsonRequest();

			List<ImageProcessingJsonRequest> listimageProcessingJsonRequest = new ArrayList<>();

			pythonImageProcessingRequest = new PythonImageProcessingRequest();
			pythonImageProcessingRequest.setOperation(Arrays.asList(ApplicationConstants.IP));
			imageProcessingJsonRequest.setLogPath(gaudiAIVersion.get(0).getVersionPath() + File.separator
					+ ApplicationConstants.DOC + File.separator + ApplicationConstants.LOG);
			imageProcessingJsonRequest.setRootPath(gaudiAIVersion.get(0).getVersionPath());
			imageProcessingJsonRequest.setSmartId(gaudiAIVersion.get(0).getSmartID());
			imageProcessingJsonRequest
					.setDefectImageList(imageProcessingGenerateRequest.getSelectedDefectPatternName());
			imageProcessingJsonRequest.setOkImageList(imageProcessingGenerateRequest.getSelectedOkImageName());
			imageProcessingJsonRequest.setNoOfImage(imageProcessingGenerateRequest.getImageCount());

			listimageProcessingJsonRequest.add(imageProcessingJsonRequest);

			pythonImageProcessingRequest.setParams(listimageProcessingJsonRequest);

			LOG.info("pythonImageProcessingRequest -{} ", pythonImageProcessingRequest);
			List<LanguageRange> header = applicationUtil.getHeader();
			sucessResponse = webClient.post().uri(gaudiServiceUrl + PythonServiceEndPointConstant.IMAGE_PROCESSING)
					.headers(h->{
						h.setAcceptLanguage(header);
					}).body(BodyInserters.fromValue(pythonImageProcessingRequest)).retrieve()
					.bodyToMono(PythonSucessResponse.class).block();

			responseBean = new HttpOperationResponseBean();
			responseBean.setStatus(HttpStatus.OK);
			responseBean.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
			responseBean.setMessage(sucessResponse.getMessage());
			
			return new ResponseEntity<>(responseBean, HttpStatus.OK);
		} catch (WebClientResponseException | WebClientRequestException e) {
			LOG.error("error in submitting Job-GPU memory full, please try after sometime");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.submitting.job.gpu.memory.full.please.try.after.sometime", null,
							LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		} catch (ServiceUnavailableException e) {
			LOG.error("Server Down,try afterSome time");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.SERVICE_UNAVAILABLE,
					messageSource.getMessage("server.down.try.afterSome.time", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.SERVICE_UNAVAILABLE);
		} catch (Exception e) {
			LOG.error("Error  - Get IP Generate Data.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.get.ip.generate.data", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	@Override
	public void saveDefectImage(MultipartHttpServletRequest request) {
		
			List<String> fileNames = new ArrayList<>();
			Long versionID = (long) Integer.parseInt(request.getParameter(ApplicationConstants.VERSIONID));
			String tabName = request.getParameter(ApplicationConstants.TABNAME);

			LOG.info("Upload Image File versionID - {} , tabName - {}", versionID, tabName);

			List<MultipartFile> mpf = request.getFiles(ApplicationConstants.FILE);
			LOG.info("mpf.size() : {}", mpf.size());

			List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);

			String uploadImagePath = null;

			uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
					+ File.separator + tabName;

			LOG.info("uploadImagePath--------------------------{}", uploadImagePath);
			String renamefile = null;
			for (MultipartFile multipartFile : mpf) {

				try (InputStream inputStream = multipartFile.getInputStream()) {

					renamefile = getUniqueFileName(multipartFile.getOriginalFilename(), uploadImagePath);

					File destFile = new File(uploadImagePath, renamefile);

					multipartFile.transferTo(destFile);

				} catch (IOException e) {
					LOG.info("Error in Rename Defect Pattern");
					throw new FileUploadException(messageSource.getMessage("could.not.store.the.file.error", null,
							LocaleContextHolder.getLocale()) + e.getMessage());
				}

				fileNames.add(renamefile);
			}

		
	}

	private String getUniqueFileName(String originalFilename, String directory) {
		try {
			final String FILE_PREFIX = ApplicationConstants.DEFECT_PATTERN+ApplicationConstants.UNDERSCORE;
			String fileWithoutExtension = originalFilename.substring(0, originalFilename.lastIndexOf(ApplicationConstants.DOT));
			String extenstion = originalFilename.substring(originalFilename.lastIndexOf(ApplicationConstants.DOT));
			Integer number = null;
			File folder = new File(directory);
			File[] files = folder.listFiles();
			if (files != null && files.length > 0) {
				Arrays.sort(files, Comparator.comparingLong(File::lastModified).reversed());
				File lastfile = files[0];
				String lastfilename = lastfile.getName();
				Pattern pattern = Pattern.compile(ApplicationConstants.BACKSLASH+ApplicationConstants.D+ApplicationConstants.PLUSE);
				Matcher matcher = pattern.matcher(lastfilename);
				if (matcher.find()) {
					String digit = matcher.group();
					number = Integer.parseInt(digit);
				}
			} else {
				number = 0;
			}
			String uniqueFileName = fileWithoutExtension + extenstion;
			int count = number;
			File filewithSameName = new File(directory, uniqueFileName);
			if (filewithSameName.exists()) {
				return uniqueFileName;
			} else {
				count++;
				uniqueFileName = FILE_PREFIX + count + extenstion;
			}
			return uniqueFileName;
		}catch (Exception e) {
			LOG.info("Error in rename Image");
			return null;
		}
	}

	@Transactional
	public ResponseEntity<?> deleteImageProcessingImage(DeleteImageRequest deleteImageRequest) {
		HttpOperationResponseBean response = null;
		try {
			if (deleteImageRequest != null) {
				Long versionID = deleteImageRequest.getVersionID();
				String tabName = deleteImageRequest.getTabName();
				if (tabName == null) {
					LOG.error("TabName Is Empty. Please Add TabName In Request.");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, "TabName Is Empty. Please Add TabName In Request.", null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

				}
				List<GaudiAIVersion> gaudiAIVersion = gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
				List<String> listImageName = deleteImageRequest.getImageName();
				Boolean deleteAllImage = false;
				LOG.info("Service Delete ImageProcessing Image.");
				if (listImageName == null || listImageName.isEmpty()) {
					deleteAllImage = true;
				}

				String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator
						+ ApplicationConstants.IMAGE + File.separator + tabName;
				File file = new File(uploadImagePath);

				if (file.exists()) {
					deleteFolderImage(gaudiAIVersion, tabName, deleteAllImage, listImageName);
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage("ImageProcessing Image(s) Deleted Successfully.");
					LOG.info("ImageProcessing Image(s) Deleted Successfully.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					LOG.error("Folder not exist");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST, "Folder Not Exist", null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			} else {
				LOG.error("Request Is Empty");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST, "Request Is Empty", null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}

		} catch (Exception e) {
			LOG.error("Error In Delete ImageProcessing Image");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, "Error In Delete ImageProcessing Image", null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	@SuppressWarnings("unchecked")
	@Override
	public ResponseEntity<?> getIPParticularVersion(Long versionID) {
		GaudiAIIPVersionData gaudiAIVersionData = new GaudiAIIPVersionData();
		try {
			if (gaudiAIVersionRepository.existsById(versionID)) {
				GaudiAIVersion gaudiAIVersion = gaudiAIVersionRepository.getReferenceById(versionID);
				gaudiAIVersionData = setGaudiAIIPVersionData(gaudiAIVersion);
				List<IPTabDetails> ipTabResponse = new ArrayList<>();

				String variablePath = gaudiAIVersion.getVersionPath() + File.separator
						+ ApplicationConstants.IMAGE;
				List<String> listOfFolder = filesStorageService.getListOfFolder(variablePath);
				for (int i = 0; i < listOfFolder.size(); i++) {
					ResponseEntity<?> entity = filesStorageService.loadAll(versionID, listOfFolder.get(i), null);
					if (entity.getStatusCode().equals(HttpStatus.OK)) {
						IPTabDetails response = new IPTabDetails();
						response.setTabName(listOfFolder.get(i));
						List<FileInfo> body = (List<FileInfo>) entity.getBody();

						if (!body.isEmpty()) {
							response.setImagePresent(true);
							response.setImageCount(body.size());
						} else {
							response.setImagePresent(false);
							response.setImageCount(body.size());
						}

						ipTabResponse.add(response);
					}

				}
				gaudiAIVersionData.setIpTabDetails(ipTabResponse);
				return new ResponseEntity<>(gaudiAIVersionData, HttpStatus.OK);
			} else {
				LOG.error("No IP Version Data Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.ip.version.data.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}

		} catch (Exception e) {
			LOG.error("Error In Get IP Particular Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.get.ip.particular.version",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}
	public GaudiAIIPVersionData setGaudiAIIPVersionData(GaudiAIVersion gaudiAIVersion) {
		GaudiAIIPVersionData gaudiAIVersionData = new GaudiAIIPVersionData();
		gaudiAIVersionData.setVersionID(gaudiAIVersion.getVersionID());
		gaudiAIVersionData.setProjectID(gaudiAIVersion.getProjectID());
		gaudiAIVersionData.setVersionName(gaudiAIVersion.getVersionName());
		gaudiAIVersionData.setNotes(gaudiAIVersion.getNotes());
		Gson g = new Gson();
		SortedSet<?> convert = g.fromJson(gaudiAIVersion.getActiveStep(), SortedSet.class);
		gaudiAIVersionData.setActiveStep(convert);
		gaudiAIVersionData.setProcessStatus(gaudiAIVersion.getProcessStatus());
		gaudiAIVersionData.setErrorMessage(gaudiAIVersion.getErrorMessage());
		gaudiAIVersionData.setVersionPath(gaudiAIVersion.getVersionPath());
		gaudiAIVersionData.setIsClone(gaudiAIVersion.getIsClone());
		gaudiAIVersionData.setCloneVersionID(gaudiAIVersion.getCloneVersionID());
		gaudiAIVersionData.setIsActive(gaudiAIVersion.getIsActive());
		gaudiAIVersionData.setCreatedDate(gaudiAIVersion.getCreatedDate());
		gaudiAIVersionData.setModifiedDate(gaudiAIVersion.getModifiedDate());
		gaudiAIVersionData.setCreatedBy(gaudiAIVersion.getCreatedBy());
		gaudiAIVersionData.setLockUnlock(gaudiAIVersion.getLockUnlock());
		gaudiAIVersionData.setSmartID(gaudiAIVersion.getSmartID());
		return gaudiAIVersionData;
	}
	@Transactional
	public void deleteFolderImage(List<GaudiAIVersion> gaudiAIVersion, String tabName, Boolean deleteAllImage,
			List<String> listImageName) {

		String uploadImagePath = gaudiAIVersion.get(0).getVersionPath() + File.separator + ApplicationConstants.IMAGE
				+ File.separator + tabName;
		if (Boolean.TRUE.equals(deleteAllImage)) {
			filesStorageService.deleteFolder(uploadImagePath);
			applicationUtil.createDirectory(uploadImagePath);
		} else {
			for (int i = 0; i < listImageName.size(); i++) {
				filesStorageService.deleteImage(uploadImagePath, listImageName.get(i));
			}
		}

	}
}
----------------------------------------------------------------------------------------------------------------
ProjectDashboardService.java
-----------------------------

package com.gaudi.ai.service;

import com.gaudi.ai.request.CloneVersionRequest;
import com.gaudi.ai.request.EditProject;
import com.gaudi.ai.request.ProjectCreationRequest;
import com.gaudi.ai.request.VersionBodyRequest;
import com.gaudi.ai.response.*;
import com.gaudi.ai.request.AddVersionNote;

import org.springframework.http.ResponseEntity;

import java.util.List;


public interface ProjectDashboardService {

	ResponseEntity<?> createProject(ProjectCreationRequest projectCreationRequest);

	ResponseEntity<ListOfProjectResponse> getListOfProject(int pageSize, int pageNum, String sortField, String sortDir, Long userID,
			String projectModule,String projectKeyword);

	ResponseEntity<?> getListOfVersion(int pageSize, int pageNum, String sortField, String sortDir, Long projectID);

	ResponseEntity<?> createNewVersion(Long projectID);

	HttpOperationResponseBean cloneVersion(CloneVersionRequest request) throws Exception;

	ResponseEntity<?> deleteVersion(List<Long> list);

	ResponseEntity<?> deleteProject(Long projectID);

	ResponseEntity<?> editProject(EditProject editProject);

	ResponseEntity<?> createGanNewVersion(Long projectID);
	
	ResponseEntity<?> deleteGanVersion(List<Long> list);

	ResponseEntity<?> deleteGanProject(Long projectID);
	
	ResponseEntity<?> versionLock(VersionBodyRequest VersionBodyRequest);
	
    ResponseEntity<?> deleteIpVersion(List<Long> versionIds);
	
	ResponseEntity<?> deleteIpProject(Long projectID);
	
	ResponseEntity<HttpOperationResponseBean> addVersionNote(AddVersionNote addVersionNote) throws Exception;

}
-------------------------------------------------------------------------------------------------------------------
ProjectDashboardServiceImpl.java
----------------------------------
package com.gaudi.ai.service;

import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.exception.*;
import com.gaudi.ai.model.AdminUsers;
import com.gaudi.ai.model.GanTestWizard;
import com.gaudi.ai.model.GanTrainingWizard;
import com.gaudi.ai.model.GaudiAIBlendingGenerate;
import com.gaudi.ai.model.GaudiAIProjects;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.AdminUserRepository;
import com.gaudi.ai.repository.GanTestWizardRepository;
import com.gaudi.ai.repository.GanTrainingWizardRepository;
import com.gaudi.ai.repository.GaudiAIBlendingGenerateRepository;
import com.gaudi.ai.repository.GaudiAIProjectsRepository;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import com.gaudi.ai.request.CloneVersionRequest;
import com.gaudi.ai.request.EditProject;
import com.gaudi.ai.request.ProjectCreationRequest;
import com.gaudi.ai.request.VersionBodyRequest;
import com.gaudi.ai.request.AddVersionNote;
import com.gaudi.ai.response.GaudiAIProjectData;
import com.gaudi.ai.response.HttpOperationResponseBean;
import com.gaudi.ai.response.ListOfProjectResponse;
import com.gaudi.ai.response.ListOfVersionResponse;
import com.gaudi.ai.response.ProjectCreationResponse;
import com.gaudi.ai.strategies.cloneversion.BlendingCloneVersionStrategy;
import com.gaudi.ai.strategies.cloneversion.CloneVersionStrategy;
import com.gaudi.ai.util.ApplicationUtil;
import lombok.NonNull;
import org.apache.commons.io.FileUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.beans.factory.config.AutowireCapableBeanFactory;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;


@Service
public class ProjectDashboardServiceImpl implements ProjectDashboardService {

	private static final Logger LOG = LogManager.getLogger(ProjectDashboardServiceImpl.class);
	private  static int maxChar = 1000;
	@Autowired
	private AutowireCapableBeanFactory beanFactory;

	@Autowired
	private GaudiAIProjectsRepository gaudiAIProjectsRepository;

	@Autowired
	private AdminUserRepository adminUserRepository;

	@Autowired
	private GaudiAIVersionRepository gaudiAIVersionRepository;

	@Autowired
	private ApplicationUtil applicationUtil;

	@Autowired
	private GaudiAIBlendingGenerateRepository gaudiAIBlendingGenerateRepository;

	@Autowired
	private GanTrainingWizardRepository ganTrainingWizardRepository;
	
	@Autowired
	private GanTestWizardRepository ganTestWizardRepository;

	@Autowired
	private BlendingServiceImpl blendingServiceImpl;

	private static DecimalFormat decimalFormat = new DecimalFormat(ApplicationConstants.DEFAULT);
	@Autowired
	private MessageSource messageSource;

	@Value("#{'${gaudiServiceUrl}'}")
	String gaudiServiceUrl;

	@Override
	@Transactional
	public ResponseEntity<?> createProject(ProjectCreationRequest projectCreationRequest) {
		LOG.info("ProjectDashboardServiceImpl : createProject");
		ProjectCreationResponse response = null;
		GaudiAIProjects saveGaudiAIProjects = null;
		GaudiAIVersion saveGaudiAIVersion = null;
		try {

			int projectNameExistCount = gaudiAIProjectsRepository.checkProjectNameExists(
					projectCreationRequest.getProjectName(), projectCreationRequest.getCreatedBy(),
					projectCreationRequest.getProjectModule());
			if (projectNameExistCount > 0) {
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 302,
						ApplicationConstants.FOUND,
						messageSource.getMessage(
								"duplicate.project.name.entered.please.enter.different.project.name", null,
								LocaleContextHolder.getLocale()),
						null);
				LOG.error("Duplicate Project Name Entered. Please Enter Different Project Name");
				return new ResponseEntity<>(errorResponse, HttpStatus.FOUND);
			} else {
				GaudiAIProjects gaudiAIProjects = new GaudiAIProjects();
				gaudiAIProjects.setProjectName(projectCreationRequest.getProjectName());
				gaudiAIProjects.setProjectDesc(projectCreationRequest.getProjectDesc());
				gaudiAIProjects.setProjectModule(projectCreationRequest.getProjectModule());
				gaudiAIProjects.setIsActive(ApplicationConstants.YES);
				gaudiAIProjects.setCreatedDate(new Date(System.currentTimeMillis()));
				gaudiAIProjects.setCreatedBy(projectCreationRequest.getCreatedBy());
				if(projectCreationRequest.getProjectModule().equals(ApplicationConstants.BLENDING) && projectCreationRequest.getNoOfChannel() != null && projectCreationRequest.getNoOfChannel() <0 ) {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("no.of.channel.for.blending.is.mandatory", null,
									LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
				gaudiAIProjects.setNoOfChannel(projectCreationRequest.getNoOfChannel());
				saveGaudiAIProjects = gaudiAIProjectsRepository.save(gaudiAIProjects);
				List<AdminUsers> userDetails = adminUserRepository
						.findUserByUserID(projectCreationRequest.getCreatedBy());
				String userPath = userDetails.get(0).getUserPath();
				String folderPath = userPath + File.separator + projectCreationRequest.getProjectModule()
						+ File.separator + projectCreationRequest.getProjectName() + ApplicationConstants.UNDERSCORE
						+ saveGaudiAIProjects.getProjectID();
				boolean folder = applicationUtil.createFolder(folderPath);
				gaudiAIProjectsRepository.updateProjectPath(new Date(System.currentTimeMillis()), folderPath,
						saveGaudiAIProjects.getProjectID());
				GaudiAIVersion gaudiAIVersion = new GaudiAIVersion();
				gaudiAIVersion.setProjectID(saveGaudiAIProjects.getProjectID());
				gaudiAIVersion.setVersionName(ApplicationConstants.V1_0);
				gaudiAIVersion.setIsActive(ApplicationConstants.YES);
				gaudiAIVersion.setCreatedDate(new Date(System.currentTimeMillis()));
				gaudiAIVersion.setNotes(ApplicationConstants.BLANK);
				gaudiAIVersion.setLockUnlock(ApplicationConstants.NO);
				gaudiAIVersion.setCreatedBy(projectCreationRequest.getCreatedBy());
				saveGaudiAIVersion = gaudiAIVersionRepository.save(gaudiAIVersion);
				String versionFolderPath = folderPath + File.separator + ApplicationConstants.V1_0;
				boolean versionSubfolder = applicationUtil.createFolder(versionFolderPath);
				if (folder && versionSubfolder) {
					String prifix = projectCreationRequest.getProjectModule().contains(ApplicationConstants.BLENDING)
							? ApplicationConstants.BL+ApplicationConstants.UNDERSCORE
							: projectCreationRequest.getProjectModule().contains(ApplicationConstants.GAN)
									? ApplicationConstants.GAN+ApplicationConstants.UNDERSCORE
									: ApplicationConstants.IP+ApplicationConstants.UNDERSCORE;
					String smartID = prifix + saveGaudiAIVersion.getProjectID() + ApplicationConstants.UNDERSCORE
							+ saveGaudiAIVersion.getVersionID();
					gaudiAIVersionRepository.updateSmartIDVersionPath(new Date(System.currentTimeMillis()),
							versionFolderPath, smartID, saveGaudiAIVersion.getVersionID());
					applicationUtil.createSubFolder(versionFolderPath, projectCreationRequest.getProjectModule(),projectCreationRequest.getNoOfChannel());

					response = new ProjectCreationResponse();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setProjectID(saveGaudiAIVersion.getProjectID());
					response.setProjectName(saveGaudiAIProjects.getProjectName());
					response.setVersionID(saveGaudiAIVersion.getVersionID());
					response.setMessage(messageSource.getMessage("project.and.version.created.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Project and version created successfully.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				} else {
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
							ApplicationConstants.BAD_REQUEST,
							messageSource.getMessage("project.and.version.donot.created.successfully", null,
									LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
				}
			}
		} catch (Exception e) {
			LOG.error("Error In Project and version creatation.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST, messageSource.getMessage("error.in.project.and.version.creation",
							null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}

	}

	@Override
	public ResponseEntity<ListOfProjectResponse> getListOfProject(int pageSize, int pageNum, String sortField, String sortDir, Long userID,
			String projectModule,String projectKeyword) {
		try {
			Page<GaudiAIProjects> page = listOfProject(pageSize, pageNum, sortField, sortDir, userID, projectModule,projectKeyword);
			List<GaudiAIProjects> listProject = page.getContent();

			if (!listProject.isEmpty()) {
				ListOfProjectResponse listOfProjectResponse = new ListOfProjectResponse();
				List<GaudiAIProjectData> listGaudiAIProjectData = new ArrayList<>();
				for (GaudiAIProjects gaudiAIProjects : listProject) {
					GaudiAIProjectData gaudiAIProjectData = new GaudiAIProjectData();
					gaudiAIProjectData = setGaudiAIProjectData(gaudiAIProjects);
					listGaudiAIProjectData.add(gaudiAIProjectData);
				}
				Integer totalProjectCount = null;
				if (projectKeyword == null) {
					totalProjectCount = gaudiAIProjectsRepository.findCountOfProjectByProjectID(userID, projectModule).orElse(0);
				} else {
					totalProjectCount = gaudiAIProjectsRepository
							.findCountOfProjectByProjectName(userID, projectModule, projectKeyword)
							.orElse(0);
				}
				listOfProjectResponse.setTotalProjectCount(totalProjectCount);
				listOfProjectResponse.setGaudiAIProjectData(listGaudiAIProjectData);
				return new ResponseEntity<>(listOfProjectResponse, HttpStatus.OK);
			} else {
				LOG.error("No Project Found");
				return ResponseEntity.noContent().build();

			}
		} catch (Exception e) {
			LOG.error("Error In Get List Of Project.");
			throw new BadRequestException(messageSource.getMessage("error.in.get.list.of.project", null, LocaleContextHolder.getLocale()));
		}
	}

	private GaudiAIProjectData setGaudiAIProjectData(GaudiAIProjects gaudiAIProjects) {
		GaudiAIProjectData gaudiAIProjectData = new GaudiAIProjectData();
		gaudiAIProjectData.setProjectID(gaudiAIProjects.getProjectID());
		gaudiAIProjectData.setProjectName(gaudiAIProjects.getProjectName());
		gaudiAIProjectData.setProjectDesc(gaudiAIProjects.getProjectDesc());
		gaudiAIProjectData.setProjectModule(gaudiAIProjects.getProjectModule());
		gaudiAIProjectData.setProjectType(gaudiAIProjects.getProjectType());
		gaudiAIProjectData.setProjectPath(gaudiAIProjects.getProjectPath());
		gaudiAIProjectData.setIsActive(gaudiAIProjects.getIsActive());
		gaudiAIProjectData.setCreatedDate(gaudiAIProjects.getCreatedDate());
		gaudiAIProjectData.setModifiedDate(gaudiAIProjects.getModifiedDate());
		gaudiAIProjectData.setCreatedBy(gaudiAIProjects.getCreatedBy());
		gaudiAIProjectData.setNoOfChannel(gaudiAIProjects.getNoOfChannel());
		return gaudiAIProjectData;
	}

	private Page<GaudiAIProjects> listOfProject(int pageSize, int pageNum, String sortField, String sortDir,
			Long userID, String projectModule,String projectKeyword) {
		Pageable pageable = PageRequest.of(pageNum - 1, pageSize,
				sortDir.equals(ApplicationConstants.ASC) ? Sort.by(sortField).ascending()
						: Sort.by(sortField).descending());
		if (projectKeyword == null) {
			return gaudiAIProjectsRepository.findAllByProjectModuleAndCreatedBy(projectModule, userID, pageable);
		} else {
			return gaudiAIProjectsRepository.findProjectByProjectIDAndName(projectModule, projectKeyword, userID,
					pageable);
		}
}

	@Override
	public ResponseEntity<?> getListOfVersion(int pageSize, int pageNum, String sortField, String sortDir,
			Long projectID) {
		try {
			Page<GaudiAIVersion> page = listOfVersion(pageSize, pageNum, sortField, sortDir, projectID);

			ListOfVersionResponse listOfVersionResponse = null;
			List<GaudiAIVersion> listVersion = page.getContent();
			if (!listVersion.isEmpty()) {
				listOfVersionResponse = new ListOfVersionResponse();

				Integer totalVersionCount = gaudiAIVersionRepository.findCountOfVersionByProjectID(projectID)
						.orElseThrow(() -> new BadRequestException(
								messageSource.getMessage("no.first.version.created.for.projectid", null,
										LocaleContextHolder.getLocale()) + projectID));

				listOfVersionResponse.setTotalVersionCount(totalVersionCount);
				listOfVersionResponse.setGaudiAIVersionData(listVersion);
				return new ResponseEntity<>(listOfVersionResponse, HttpStatus.OK);
			} else {
				LOG.error("No Version Details Found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("no.version.details.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}

		} catch (Exception e) {
			LOG.error("Error In Get List Of Version.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.get.list.of.version", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}
	}

	private Page<GaudiAIVersion> listOfVersion(int pageSize, int pageNum, String sortField, String sortDir,
			Long projectID) {
		Pageable pageable = PageRequest.of(pageNum - 1, pageSize,
				sortDir.equals(ApplicationConstants.ASC) ? Sort.by(sortField).ascending()
						: Sort.by(sortField).descending());

		return gaudiAIVersionRepository.findListOfVersionByProjectID(projectID, pageable);
	}

	@Override
	@Transactional
	public ResponseEntity<?> createNewVersion(Long projectID) {
		HttpOperationResponseBean response = null;
		GaudiAIVersion saveGaudiAIVersion = null;

		try {
			GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.findByProjectID(projectID).orElseThrow(
					() -> new BadRequestException(messageSource.getMessage("do.not.find.project.for.projectid", null,
							LocaleContextHolder.getLocale()) + projectID));

			String versionName = gaudiAIVersionRepository.findLatesVersionNameByProjectID(projectID);
			String newVersionString = null;
			if (versionName != null) {
				versionName = versionName.replace(ApplicationConstants.V, ApplicationConstants.BLANK);
				float newVersion = Float.parseFloat(versionName) + 0.1f;
				newVersionString = ApplicationConstants.V + decimalFormat.format(newVersion);
			} else {
				newVersionString = ApplicationConstants.V1_0;
			}

			GaudiAIVersion gaudiAIVersion = new GaudiAIVersion();
			gaudiAIVersion.setProjectID(gaudiAIProjects.getProjectID());
			LOG.info("newVersionString ----:{}", newVersionString);
			gaudiAIVersion.setVersionName(newVersionString);
			gaudiAIVersion.setIsActive(ApplicationConstants.YES);
			gaudiAIVersion.setCreatedDate(new Date(System.currentTimeMillis()));
			gaudiAIVersion.setNotes(ApplicationConstants.BLANK);
			gaudiAIVersion.setLockUnlock(ApplicationConstants.NO);
			gaudiAIVersion.setCreatedBy(gaudiAIProjects.getCreatedBy());
			saveGaudiAIVersion = gaudiAIVersionRepository.save(gaudiAIVersion);

			String versionFolderPath = gaudiAIProjects.getProjectPath() + File.separator + newVersionString;
			boolean versionSubfolder = applicationUtil.createFolder(versionFolderPath);
			if (versionSubfolder) {
				String prifix = gaudiAIProjects.getProjectModule().contains(ApplicationConstants.BLENDING)
						? ApplicationConstants.BL+ApplicationConstants.UNDERSCORE
						: gaudiAIProjects.getProjectModule().contains(ApplicationConstants.GAN)
								? ApplicationConstants.GAN+ApplicationConstants.UNDERSCORE
								: ApplicationConstants.IP+ApplicationConstants.UNDERSCORE;
				String smartID = prifix + saveGaudiAIVersion.getProjectID() + ApplicationConstants.UNDERSCORE
						+ saveGaudiAIVersion.getVersionID();
				gaudiAIVersionRepository.updateSmartIDVersionPath(new Date(System.currentTimeMillis()),
						versionFolderPath, smartID, saveGaudiAIVersion.getVersionID());
				applicationUtil.createSubFolder(versionFolderPath, gaudiAIProjects.getProjectModule(),gaudiAIProjects.getNoOfChannel());
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("new.version.created.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("New Version Created Successfully.");
			} else {
				LOG.error("New Version Creation Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("new.version.creation.failure", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

			}

		} catch (Exception e) {

			LOG.error("Error In New Version Creatation.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.new.version.creation", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}

		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	@Override
	public HttpOperationResponseBean cloneVersion(@NonNull final CloneVersionRequest request) throws Exception {
		final CloneVersionStrategy cloneVersionStrategy = getCloneVersionStrategy(request.getModule());
		cloneVersionStrategy.cloneVersion(request.getVersionId());
		final String successMessage = messageSource.getMessage("clone-version.messages.success.request-successful",
				null, LocaleContextHolder.getLocale());
		return HttpOperationResponseBean.builder()
				.timestamp(new Date().toString())
				.status(HttpStatus.OK)
				.message(successMessage)
				.build();
	}

	private CloneVersionStrategy getCloneVersionStrategy(final String module)
			throws VersionCloningException, InvocationTargetException, NoSuchMethodException,
			InstantiationException, IllegalAccessException {
		switch (module) {
			case ApplicationConstants.BLENDING:
				return initialize(BlendingCloneVersionStrategy.class);
			default:
				final String errorMessage = messageSource.getMessage("clone-version.messages.error.invalid-module",
						null, LocaleContextHolder.getLocale());
				throw new VersionCloningException(errorMessage);
		}
	}

	private CloneVersionStrategy initialize(final Class<? extends CloneVersionStrategy> cloneVersionStrategy)
			throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
		final Constructor<? extends CloneVersionStrategy> constructor = cloneVersionStrategy.getConstructor();
		final CloneVersionStrategy strategy = constructor.newInstance();

		beanFactory.autowireBean(strategy);
		return strategy;
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteVersion(List<Long> versionIds) {
		try {
			Boolean deleteStatus = false;
			List<String> listOfVersionPath = gaudiAIVersionRepository.findVersionPathByversionId(versionIds);
			for (Long id : versionIds) {
				if (gaudiAIVersionRepository.existsById(id)) {
					deleteStatus = deleteTabVersion(id);
				} else {
					deleteStatus = false;
				}
			}
			if (Boolean.TRUE.equals(deleteStatus)) {

				deleteVersionFIle(listOfVersionPath);
				HttpOperationResponseBean response = null;
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("delete.the.versions.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Delete the versions Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
		} catch (Exception e) {
			LOG.error("versionId not found");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("versionid.not.found", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}
		AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
				ApplicationConstants.NO_CONTENT,
				messageSource.getMessage("versionid.not.found", null, LocaleContextHolder.getLocale()), null);
		return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
	}

	@Transactional
	public Boolean deleteTabVersion(Long versionID) {
//		List<GaudiAIBlendingSource> gaudiAIBlendingSource = gaudiAIBlendingSourceRepository
//				.findByGaudiVersionID(versionID);
//		if (!gaudiAIBlendingSource.isEmpty())
//			gaudiAIBlendingSourceRepository.deleteGaudiAIBlendingSourceByGaudiVersionID(versionID);
//		List<GaudiAIBlendingMask> gaudiAIBlendingMask = gaudiAIBlendingMaskRepository.findByGaudiVersionID(versionID);
//		if (!gaudiAIBlendingMask.isEmpty())
//			gaudiAIBlendingMaskRepository.deleteGaudiAIBlendingMaskByGaudiVersionID(versionID);
//		List<GaudiAIBlendingTarget> gaudiAIBlendingTarget = gaudiAIBlendingTargetRepository
//				.findByGaudiVersionID(versionID);
//		if (!gaudiAIBlendingTarget.isEmpty())
//			gaudiAIBlendingTargetRepository.deleteGaudiAIBlendingTargetByGaudiVersionID(versionID);
//		List<GaudiAIBlendingTargetMask> gaudiAIBlendingTargetMask = gaudiAIBlendingTargetMaskRepository
//				.findByGaudiVersionID(versionID);
//		if (!gaudiAIBlendingTargetMask.isEmpty())
//			gaudiAIBlendingTargetMaskRepository.deleteGaudiAIBlendingTargetMaskByGaudiVersionID(versionID);
		List<GaudiAIBlendingGenerate> gaudiAIBlendingGenerate = gaudiAIBlendingGenerateRepository
				.getGaudiAIBlendingGenerate(versionID);
		if (!gaudiAIBlendingGenerate.isEmpty())
			gaudiAIBlendingGenerateRepository.deleteaudiAIBlendingGenerateByGaudiVersionID(versionID);
		gaudiAIVersionRepository.deleteById(versionID);
		return true;
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteProject(Long projectID) {
		Boolean deleteStatus = false;
		if (gaudiAIProjectsRepository.existsById(projectID)) {

			List<GaudiAIVersion> list = gaudiAIVersionRepository.findVerionsByProjectId(projectID);

			List<Long> versionIdlist = list.stream().map(GaudiAIVersion::getVersionID).collect(Collectors.toList());
			String projectPath = gaudiAIProjectsRepository.findProjectPathByProjectId(projectID);
			try {
				if (!versionIdlist.isEmpty()) {
					for (Long long1 : versionIdlist) {
						if (gaudiAIVersionRepository.existsById(long1))
							deleteStatus = deleteTabVersion(long1);
					}
				} else {

					deleteStatus = true;

				}

				if (Boolean.TRUE.equals(deleteStatus)) {
					gaudiAIProjectsRepository.deleteById(projectID);
					
					File file = new File(projectPath);
					if (file.exists()) {
						if (file.isDirectory()) {
							FileUtils.deleteDirectory(file);
							deleteStatus = true;
							LOG.info("FInd The File Dirctory and Delete directory ");
						}
					}
				
				}

				if (Boolean.TRUE.equals(deleteStatus)) {
					HttpOperationResponseBean response = null;
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("delete.the.project.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Delete the project Successfully.");
					return new ResponseEntity<>(response, HttpStatus.OK);
				}
			} catch (Exception e) {
				LOG.error("versionId not found");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("error.in.delete.the.project", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} else {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("project.not.found", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}
		AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
				ApplicationConstants.NO_CONTENT,
				messageSource.getMessage("project.not.found", null, LocaleContextHolder.getLocale()), null);
		return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
	}

	private void deleteVersionFIle(List<String> versionPaths) throws Exception {
		LOG.info("List Of version Ids Inputs ");
		for (String vPath : versionPaths) {
			File file = new File(vPath);
			if (file.exists()) {
				if (file.isDirectory()) {
					FileUtils.deleteDirectory(file);
					LOG.info("FInd The File Dirctory and Delete directory ");
				} else {
					file.delete();
					LOG.info("FInd The File  and Delete File ");
				}
			}
		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> editProject(EditProject editProject) {
		HttpOperationResponseBean response = null;
		LOG.info("projectDashboradService: editproject() editProject ", editProject);
		try {
			if (gaudiAIProjectsRepository.existsById(editProject.getProjectID())) {
				gaudiAIProjectsRepository.updateProjectDescByProjectId(editProject.getProjectDesc(),
						editProject.getProjectID(), new Date(System.currentTimeMillis()));
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(
						messageSource.getMessage("project.update.successfully", null, LocaleContextHolder.getLocale()));
				LOG.info("project desc update Successfully!!..");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.info("ProjectId not found ");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 404,
						ApplicationConstants.NOT_FOUND, messageSource.getMessage("project.not.found.by.given.projectID",
								null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
			}
		} catch (Exception e) {
			e.printStackTrace();
			LOG.info("Error in Edit Project ");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.edit.project", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
		}

	}

	@Override
	@Transactional
	public ResponseEntity<?> createGanNewVersion(Long projectID) {
		HttpOperationResponseBean response = null;
		GaudiAIVersion saveGaudiAIVersion = null;
		try {
			GaudiAIProjects gaudiAIProjects = gaudiAIProjectsRepository.findByProjectID(projectID).orElseThrow(
					() -> new BadRequestException(messageSource.getMessage("do.not.find.project.for.projectid", null,
							LocaleContextHolder.getLocale())+ projectID ));
			String versionName = gaudiAIVersionRepository.findLatesVersionNameByProjectID(projectID);
			String newVersionString = null;
			if (versionName != null) {
				versionName = versionName.replace(ApplicationConstants.V, ApplicationConstants.BLANK);
				float newVersion = Float.parseFloat(versionName) + 0.1f;
				newVersionString = ApplicationConstants.V + decimalFormat.format(newVersion);
			} else {
				newVersionString = ApplicationConstants.V1_0;
			}
			GaudiAIVersion existingGaudiAIVersion = gaudiAIVersionRepository.findLatesVersionByProjectID(projectID);
			if (existingGaudiAIVersion != null) {
				GaudiAIVersion gaudiAIVersion = setNewGaudiAIVersion(existingGaudiAIVersion);
				gaudiAIVersion.setVersionName(newVersionString);
				gaudiAIVersion.setNotes(ApplicationConstants.BLANK);
				gaudiAIVersion.setLockUnlock(ApplicationConstants.NO);
				gaudiAIVersion.setProcessStatus(null);
				gaudiAIVersion.setErrorMessage(null);
				gaudiAIVersion.setProcessGanTestStatus(null);
				gaudiAIVersion.setErrorGanTestMessage(null);
				gaudiAIVersion.setCreatedDate(new Date(System.currentTimeMillis()));
				gaudiAIVersion.setModifiedDate(null);
				gaudiAIVersion.setActiveStep(null);
				saveGaudiAIVersion = gaudiAIVersionRepository.save(gaudiAIVersion);
				LOG.info("saveGaudiAIVersion.getVersionID()-----------------------------"+saveGaudiAIVersion.getVersionID());
				List<GanTrainingWizard> listGanTrainingWizard = ganTrainingWizardRepository
						.findBygaudiVersionId(existingGaudiAIVersion.getVersionID());
				if (!listGanTrainingWizard.isEmpty()) {
					GanTrainingWizard ganTrainingWizard = setNewTrainingTabResponse(listGanTrainingWizard.get(0));
					ganTrainingWizard.setGaudiVersionId(saveGaudiAIVersion.getVersionID());
					ganTrainingWizard.setTrainClassName(null);
					ganTrainingWizard.setModifiedDate(null);
					LOG.info("ganTrainingWizard------------------"+ganTrainingWizard);
					if(ganTrainingWizard.getPostProcessGenerateHeight() == null || ganTrainingWizard.getPostProcessGenerateHeight() == 0) {
						
					}
					GanTrainingWizard saveGanTrainingWizard = ganTrainingWizardRepository.save(ganTrainingWizard);
					blendingServiceImpl.updateActiveSteps(saveGaudiAIVersion, 1);
					blendingServiceImpl.updateActiveSteps(saveGaudiAIVersion, 2);

					LOG.info("newVersionString--{} VersionID--{} TrainingId--{}", newVersionString,
							saveGaudiAIVersion.getVersionID(), saveGanTrainingWizard.getTrainingId());
				}
			} else {
				GaudiAIVersion gaudiAIVersion = new GaudiAIVersion();
				gaudiAIVersion.setProjectID(gaudiAIProjects.getProjectID());
				LOG.info("newVersionString ----:{}", newVersionString);
				gaudiAIVersion.setVersionName(newVersionString);
				gaudiAIVersion.setIsActive(ApplicationConstants.YES);
				gaudiAIVersion.setCreatedDate(new Date(System.currentTimeMillis()));
				gaudiAIVersion.setNotes(ApplicationConstants.BLANK);
				gaudiAIVersion.setLockUnlock(ApplicationConstants.NO);
				gaudiAIVersion.setCreatedBy(gaudiAIProjects.getCreatedBy());
				saveGaudiAIVersion = gaudiAIVersionRepository.save(gaudiAIVersion);
			}
			
			LOG.info("saveGaudiAIVersion ----:{}", saveGaudiAIVersion.getVersionID());
			String versionFolderPath = gaudiAIProjects.getProjectPath() + File.separator + newVersionString;
			boolean versionSubfolder = applicationUtil.createFolder(versionFolderPath);
			if (versionSubfolder) {
				String prifix = gaudiAIProjects.getProjectModule().contains(ApplicationConstants.BLENDING)
						? ApplicationConstants.BL+ApplicationConstants.UNDERSCORE
						: gaudiAIProjects.getProjectModule().contains(ApplicationConstants.GAN)
								? ApplicationConstants.GAN+ApplicationConstants.UNDERSCORE
								: ApplicationConstants.IP+ApplicationConstants.UNDERSCORE;
				String smartID = prifix + saveGaudiAIVersion.getProjectID() + ApplicationConstants.UNDERSCORE
						+ saveGaudiAIVersion.getVersionID();
				gaudiAIVersionRepository.updateSmartIDVersionPath(new Date(System.currentTimeMillis()),
						versionFolderPath, smartID, saveGaudiAIVersion.getVersionID());
				applicationUtil.createSubFolder(versionFolderPath, gaudiAIProjects.getProjectModule(),gaudiAIProjects.getNoOfChannel());
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("new.version.created.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("GAN New Version Created Successfully.");
			} else {
				LOG.error("Gan New Version Creation Failure.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
						ApplicationConstants.BAD_REQUEST,
						messageSource.getMessage("new.version.creation.failure", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
			}
		} catch (Exception e) {
			LOG.error("Error In GAN New Version Creatation.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,
					messageSource.getMessage("error.in.new.version.creation", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}

	public GaudiAIVersion setNewGaudiAIVersion(GaudiAIVersion gaudiAIVersion) {
		GaudiAIVersion newGaudiAIVersion = new GaudiAIVersion();
		newGaudiAIVersion.setProjectID(gaudiAIVersion.getProjectID());
		newGaudiAIVersion.setVersionName(gaudiAIVersion.getVersionName());
		newGaudiAIVersion.setNotes(gaudiAIVersion.getNotes());
		newGaudiAIVersion.setActiveStep(gaudiAIVersion.getActiveStep());
		newGaudiAIVersion.setProcessStatus(gaudiAIVersion.getProcessStatus());
		newGaudiAIVersion.setErrorMessage(gaudiAIVersion.getErrorMessage());
		newGaudiAIVersion.setVersionPath(gaudiAIVersion.getVersionPath());
		newGaudiAIVersion.setIsClone(gaudiAIVersion.getIsClone());
		newGaudiAIVersion.setCloneVersionID(gaudiAIVersion.getCloneVersionID());
		newGaudiAIVersion.setIsActive(gaudiAIVersion.getIsActive());
		newGaudiAIVersion.setCreatedDate(gaudiAIVersion.getCreatedDate());
		newGaudiAIVersion.setModifiedDate(gaudiAIVersion.getModifiedDate());
		newGaudiAIVersion.setCreatedBy(gaudiAIVersion.getCreatedBy());
		newGaudiAIVersion.setLockUnlock(gaudiAIVersion.getLockUnlock());
		newGaudiAIVersion.setSmartID(gaudiAIVersion.getSmartID());
		newGaudiAIVersion.setDatasetID(gaudiAIVersion.getDatasetID());
		newGaudiAIVersion.setProcessGanTestStatus(gaudiAIVersion.getProcessGanTestStatus());
		newGaudiAIVersion.setErrorGanTestMessage(gaudiAIVersion.getErrorGanTestMessage());
		return newGaudiAIVersion;
	}

	private GanTrainingWizard setNewTrainingTabResponse(GanTrainingWizard ganTrainingWizard) {

		GanTrainingWizard ganNewTrainingWizard = new GanTrainingWizard();
		ganNewTrainingWizard.setGaudiVersionId(ganTrainingWizard.getGaudiVersionId());
		ganNewTrainingWizard.setTrainingArchitecture(ganTrainingWizard.getTrainingArchitecture());
		ganNewTrainingWizard.setDataWidth(ganTrainingWizard.getDataWidth());
		ganNewTrainingWizard.setDataHeight(ganTrainingWizard.getDataHeight());
		ganNewTrainingWizard.setDataUseGray(ganTrainingWizard.getDataUseGray());
		ganNewTrainingWizard.setTrainClassName(ganTrainingWizard.getTrainClassName());
		ganNewTrainingWizard.setOptimizerType(ganTrainingWizard.getOptimizerType());
		ganNewTrainingWizard.setOptimizerGLearningRate(ganTrainingWizard.getOptimizerGLearningRate());
		ganNewTrainingWizard.setOptimizerDLearningRate(ganTrainingWizard.getOptimizerDLearningRate());
		ganNewTrainingWizard.setOptimizerBeta1(ganTrainingWizard.getOptimizerBeta1());
		ganNewTrainingWizard.setOptimizerBeta2(ganTrainingWizard.getOptimizerBeta2());
		ganNewTrainingWizard.setOptimizerVisionLoss(ganTrainingWizard.getOptimizerVisionLoss());
		ganNewTrainingWizard.setTrainingIterations(ganTrainingWizard.getTrainingIterations());
		ganNewTrainingWizard.setTrainingBatchSize(ganTrainingWizard.getTrainingBatchSize());
		ganNewTrainingWizard.setTrainingGamma(ganTrainingWizard.getTrainingGamma());
		ganNewTrainingWizard.setTrainingMinimumIterations(ganTrainingWizard.getTrainingMinimumIterations());
		ganNewTrainingWizard.setTrainingNoOfWorkers(ganTrainingWizard.getTrainingNoOfWorkers());
		ganNewTrainingWizard.setTrainingSampleInterval(ganTrainingWizard.getTrainingSampleInterval());
		ganNewTrainingWizard.setTrainingSampleNumber(ganTrainingWizard.getTrainingSampleNumber());
		ganNewTrainingWizard.setTrainingSeedPoint(ganTrainingWizard.getTrainingSeedPoint());
		ganNewTrainingWizard.setAugmentation(ganTrainingWizard.getAugmentation());
		ganNewTrainingWizard.setAugmentationXFrac(ganTrainingWizard.getAugmentationXFrac());
		ganNewTrainingWizard.setAugmentationAnisotropy(ganTrainingWizard.getAugmentationAnisotropy());
		ganNewTrainingWizard.setAugmentationBrightness(ganTrainingWizard.getAugmentationBrightness());
		ganNewTrainingWizard.setAugmentationContrast(ganTrainingWizard.getAugmentationContrast());
		ganNewTrainingWizard.setAugmentationIntegerTranslation(ganTrainingWizard.getAugmentationIntegerTranslation());
		ganNewTrainingWizard.setAugmentationPvalue(ganTrainingWizard.getAugmentationPvalue());
		ganNewTrainingWizard.setAugmentationRotate(ganTrainingWizard.getAugmentationRotate());
		ganNewTrainingWizard.setAugmentationRotate90(ganTrainingWizard.getAugmentationRotate90());
		ganNewTrainingWizard.setAugmentationScalling(ganTrainingWizard.getAugmentationScalling());
		ganNewTrainingWizard.setAugmentationTarget(ganTrainingWizard.getAugmentationTarget());
		ganNewTrainingWizard.setAugmentationXFlip(ganTrainingWizard.getAugmentationXFlip());
		ganNewTrainingWizard.setAugmentationHue(ganTrainingWizard.getAugmentationHue());
		ganNewTrainingWizard.setAugmentationLumaFlip(ganTrainingWizard.getAugmentationLumaFlip());
		ganNewTrainingWizard.setAugmentationSaturation(ganTrainingWizard.getAugmentationSaturation());
		ganNewTrainingWizard.setPostProcessAutoFilter(ganTrainingWizard.getPostProcessAutoFilter());
		ganNewTrainingWizard.setPostProcessNoOfCluster(ganTrainingWizard.getPostProcessNoOfCluster());
		ganNewTrainingWizard.setCreatedBy(ganTrainingWizard.getCreatedBy());
		ganNewTrainingWizard.setCreatedDate(ganTrainingWizard.getCreatedDate());
		ganNewTrainingWizard.setModifiedDate(ganTrainingWizard.getModifiedDate());
		ganNewTrainingWizard.setIsActive(ganTrainingWizard.getIsActive());
		ganNewTrainingWizard.setPostProcessGenerateHeight(ganTrainingWizard.getPostProcessGenerateHeight());
		ganNewTrainingWizard.setPostProcessGenerateWidth(ganTrainingWizard.getPostProcessGenerateWidth());
		return ganNewTrainingWizard;
	}
	@Override
	@Transactional
	public ResponseEntity<?> deleteGanVersion(List<Long> versionIds) {
		HttpOperationResponseBean response = null;
		try {
			Boolean deleteStatus = false;
			List<String> listOfVersionPath = gaudiAIVersionRepository.findVersionPathByversionId(versionIds);
			for (Long id : versionIds) {
				if (gaudiAIVersionRepository.existsById(id)) {
					deleteStatus = deleteGanTabVersion(id);
				} else {
					deleteStatus = false;
				}
			}
			if (Boolean.TRUE.equals(deleteStatus)) {
				deleteVersionFIle(listOfVersionPath);
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("delete.the.versions.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Delete the versions Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
		} catch (Exception e) {
			LOG.error("versionId not found");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("versionid.not.found", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}
		AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
				ApplicationConstants.NO_CONTENT,
				messageSource.getMessage("versionid.not.found", null, LocaleContextHolder.getLocale()), null);
		return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
	
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteGanProject(Long projectID) {
		HttpOperationResponseBean response = null;
		Boolean deleteStatus = false;
		if (gaudiAIProjectsRepository.existsById(projectID)) {

			List<GaudiAIVersion> list = gaudiAIVersionRepository.findVerionsByProjectId(projectID);
             LOG.info("List of versions   "+list+" by project Id " +projectID);
			List<Long> versionIdlist = list.stream().map(GaudiAIVersion::getVersionID).collect(Collectors.toList());
			String projectPath = gaudiAIProjectsRepository.findProjectPathByProjectId(projectID);
			try {
				if (!versionIdlist.isEmpty()) {
					for (Long long1 : versionIdlist) {
						if (gaudiAIVersionRepository.existsById(long1))
							deleteStatus = deleteGanTabVersion(long1);
					}
				} else {
					deleteStatus = true;
				}

					if (Boolean.TRUE.equals(deleteStatus)) {
						gaudiAIProjectsRepository.deleteById(projectID);
		
						File file = new File(projectPath);
						if (file.exists()) {
							if (file.isDirectory()) {
								FileUtils.deleteDirectory(file);
								deleteStatus = true;
								LOG.info("FInd The File Dirctory and Delete directory ");
							}
						}
					}
				if (Boolean.TRUE.equals(deleteStatus)) {
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("delete.the.project.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Delete the project Successfully.");
					
				}
			} catch (Exception e) {
				LOG.error("error in delete the project");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("error.in.delete.the.project", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} else {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("project.not.found", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}
		return new ResponseEntity<>(response, HttpStatus.OK);
	}
	
	@Transactional
	public Boolean deleteGanTabVersion(Long versionID) {
		try {
			List<GanTestWizard> gaudiTestWizard = ganTestWizardRepository.findBygaudiVersionId(versionID);
			if (!gaudiTestWizard.isEmpty()) {
				ganTestWizardRepository.deleteGanTestWizardByGaudiVersionId(versionID);
			}
			List<GanTrainingWizard> gaudiAIGantrainWizard = ganTrainingWizardRepository.findBygaudiVersionId(versionID);
			if (!gaudiAIGantrainWizard.isEmpty()) {
				Long trainingId = gaudiAIGantrainWizard.get(0).getTrainingId();
				ganTrainingWizardRepository.deleteById(trainingId);
			}
			gaudiAIVersionRepository.deleteById(versionID);
			return true;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return false;
	}
	
		@Override
	@Transactional
	public ResponseEntity<?> versionLock(VersionBodyRequest VersionBodyRequest) {
		try {
			Long versionID=VersionBodyRequest.getVersionID();
			List<GaudiAIVersion> listGaudiAIVersion=gaudiAIVersionRepository.findListOfVersionByVersionID(versionID);
			if(!listGaudiAIVersion.isEmpty()) {
				gaudiAIVersionRepository.updateLockUnlockByVersionID(new Date(System.currentTimeMillis()), ApplicationConstants.YES, versionID);
				HttpOperationResponseBean response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("version.locked", null, LocaleContextHolder.getLocale()));
				LOG.info("Version Locked");
				return new ResponseEntity<>(response, HttpStatus.OK);
			} else {
				LOG.info("Version not found.");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 404,
						ApplicationConstants.NOT_FOUND, messageSource.getMessage("version.not.found", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
			}
		} catch (Exception e) {
			LOG.error("Error In Version Lock.");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 400,
					ApplicationConstants.BAD_REQUEST,messageSource.getMessage("error.in.version.lock", null, LocaleContextHolder.getLocale()),
					null);
			return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);

		}
	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteIpVersion(List<Long> versionIds) {
		HttpOperationResponseBean response = null;
		try {
			Boolean deleteStatus = false;
			List<String> listOfVersionPath = gaudiAIVersionRepository.findVersionPathByversionId(versionIds);
			for (Long id : versionIds) {
				if (gaudiAIVersionRepository.existsById(id)) {
					gaudiAIVersionRepository.deleteById(id);
					deleteStatus = true;
				} else {
					LOG.error("versionId not found");
					AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
							ApplicationConstants.NO_CONTENT,
							messageSource.getMessage("versionid.not.found", null, LocaleContextHolder.getLocale()),
							null);
					return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
				}
			}
			if (Boolean.TRUE.equals(deleteStatus)) {
				deleteVersionFIle(listOfVersionPath);
				response = new HttpOperationResponseBean();
				response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
				response.setStatus(HttpStatus.OK);
				response.setMessage(messageSource.getMessage("delete.the.versions.successfully", null,
						LocaleContextHolder.getLocale()));
				LOG.info("Deleted the versions Successfully.");
				return new ResponseEntity<>(response, HttpStatus.OK);
			}
			return new ResponseEntity<>(HttpStatus.NO_CONTENT);
		} catch (Exception e) {
			LOG.error("Error : In  Delete Version");
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("error.in.delete.version", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}

	}

	@Override
	@Transactional
	public ResponseEntity<?> deleteIpProject(Long projectID) {
		HttpOperationResponseBean response = null;
		Boolean deleteStatus = false;
		if (gaudiAIProjectsRepository.existsById(projectID)) {

			List<GaudiAIVersion> list = gaudiAIVersionRepository.findVerionsByProjectId(projectID);
			LOG.info("List of versions - {} by project Id -{}", list, projectID);
			List<Long> versionIdlist = list.stream().map(GaudiAIVersion::getVersionID).collect(Collectors.toList());
			String projectPath = gaudiAIProjectsRepository.findProjectPathByProjectId(projectID);
			try {
				if (!versionIdlist.isEmpty()) {
					deleteIpVersion(versionIdlist);
					deleteStatus = true;
				}

				if (Boolean.TRUE.equals(deleteStatus)) {
					gaudiAIProjectsRepository.deleteById(projectID);

					File file = new File(projectPath);
					if (file.exists()) {
						if (file.isDirectory()) {
							FileUtils.deleteDirectory(file);
							deleteStatus = true;
							LOG.info("Find The File Dirctory and Delete Directory ");
						}
					}
				}
				if (Boolean.TRUE.equals(deleteStatus)) {
					response = new HttpOperationResponseBean();
					response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
					response.setStatus(HttpStatus.OK);
					response.setMessage(messageSource.getMessage("delete.the.project.successfully", null,
							LocaleContextHolder.getLocale()));
					LOG.info("Delete the project Successfully.");
					return new ResponseEntity<>(response,HttpStatus.OK);
				}
				return new ResponseEntity<>(HttpStatus.NO_CONTENT);
			} catch (Exception e) {
				LOG.error("error in delete the project");
				AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
						ApplicationConstants.NO_CONTENT,
						messageSource.getMessage("error.in.delete.the.project", null, LocaleContextHolder.getLocale()),
						null);
				return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
			}
		} else {
			AppError errorResponse = new AppError(String.valueOf(new Date(System.currentTimeMillis())), 204,
					ApplicationConstants.NO_CONTENT,
					messageSource.getMessage("project.not.found", null, LocaleContextHolder.getLocale()), null);
			return new ResponseEntity<>(errorResponse, HttpStatus.NO_CONTENT);
		}
	}
	
	@Transactional
	@Override
	public ResponseEntity<HttpOperationResponseBean> addVersionNote(AddVersionNote addVersionNote) throws Exception {

		if (addVersionNote.getNotes().length() > maxChar) {
			String errorMessage = messageSource.getMessage("version.note.should.be.less.than.1000.characters", null,
					LocaleContextHolder.getLocale());
			throw new BadRequestException(errorMessage);
		}
		Long versionId = addVersionNote.getVersionId();
		Optional<GaudiAIVersion> versionOptional = gaudiAIVersionRepository.findById(versionId);

		if (!versionOptional.isPresent()) {
			String errorMessage = messageSource.getMessage("version.not.found.by.given.versionID", null,
					LocaleContextHolder.getLocale());
			throw new NotFoundException(errorMessage);
		}
		GaudiAIVersion existingVersion = versionOptional.get();
		String newNotes = addVersionNote.getNotes();
		existingVersion.setNotes(newNotes);
		existingVersion.setModifiedDate((new Date(System.currentTimeMillis())));
		gaudiAIVersionRepository.save(existingVersion);
		HttpOperationResponseBean response = new HttpOperationResponseBean();
		response.setTimestamp(String.valueOf(new Date(System.currentTimeMillis())));
		response.setStatus(HttpStatus.OK);
		response.setMessage(
				messageSource.getMessage("version.note.updated.successfully", null, LocaleContextHolder.getLocale()));
		LOG.info("Version notes updated Successfully!!..");
		return new ResponseEntity<>(response, HttpStatus.OK);
	}
}
---------------------------------------------------------------------------------------------------------------

Cloneversion:
-------------
BlendingCloneVersionStrategy.java
----------------------------------
package com.gaudi.ai.strategies.cloneversion;

import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.exception.VersionCloningException;
import com.gaudi.ai.model.GaudiAIBlendingGenerate;
import com.gaudi.ai.model.GaudiAIVersion;
import com.gaudi.ai.repository.GaudiAIBlendingGenerateRepository;
import com.gaudi.ai.repository.GaudiAIBlendingMaskRepository;
import com.gaudi.ai.repository.GaudiAIBlendingSourceRepository;
import com.gaudi.ai.repository.GaudiAIBlendingTargetMaskRepository;
import com.gaudi.ai.repository.GaudiAIBlendingTargetRepository;
import com.gaudi.ai.repository.GaudiAIVersionRepository;
import lombok.NonNull;
import org.apache.commons.io.FileUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.transaction.annotation.Transactional;

import java.io.File;
import java.io.IOException;
import java.util.Date;

public class BlendingCloneVersionStrategy extends CloneVersionStrategy {
    private static final Integer RESULT_STEP = 6;
    private static final String PREFIX = "BL";
    private Long existingVersionId;
    private Long savedVersionId;
    private String existingVersionPath;
    private String savedVersionPath;

    @Autowired
    private GaudiAIVersionRepository gaudiAIVersionRepository;
    @Autowired
    private GaudiAIBlendingSourceRepository gaudiAIBlendingSourceRepository;
    @Autowired
    private GaudiAIBlendingTargetRepository gaudiAIBlendingTargetRepository;
    @Autowired
    private GaudiAIBlendingMaskRepository gaudiAIBlendingMaskRepository;
    @Autowired
    private GaudiAIBlendingTargetMaskRepository gaudiAIBlendingTargetMaskRepository;
    @Autowired
    private GaudiAIBlendingGenerateRepository gaudiAIBlendingGenerateRepository;
    @Autowired
    private MessageSource messageSource;

    @Override
    @Transactional
    public void cloneVersion(@NonNull final Long versionId) throws Exception {
        this.existingVersionId = versionId;
        cloneVersionData();
        cloneGenerateData();
        cloneFileData();
    }

    private void cloneVersionData() throws Exception {
        if (! gaudiAIVersionRepository.existsById(existingVersionId)) {
            final String errorMessage = messageSource.getMessage("clone-version.messages.error.version-not-found",
                    null, LocaleContextHolder.getLocale());
            throw new VersionCloningException(errorMessage);
        }

        final GaudiAIVersion existingGaudiAiVersion = gaudiAIVersionRepository.getReferenceById(existingVersionId);

        final String latestVersion = gaudiAIVersionRepository
                .findLatesVersionNameByProjectID(existingGaudiAiVersion.getProjectID());
        final String incrementedVersion = getIncrementedVersionName(latestVersion);

        final GaudiAIVersion gaudiAIVersion = GaudiAIVersion.builder()
                .projectID(existingGaudiAiVersion.getProjectID())
                .versionName(incrementedVersion)
                .notes("")
                .activeStep(updateActiveSteps(existingGaudiAiVersion.getActiveStep(), RESULT_STEP))
                .versionPath(updateVersionPath(existingGaudiAiVersion.getVersionPath(), incrementedVersion))
                .isClone("Y")
                .cloneVersionID(existingVersionId)
                .isActive("Y")
                .createdDate(new Date())
                .createdBy(existingGaudiAiVersion.getCreatedBy())
                .datasetID(existingGaudiAiVersion.getDatasetID())
                .build();

        final GaudiAIVersion savedGaudiAiVersion = gaudiAIVersionRepository.save(gaudiAIVersion);

        if (savedGaudiAiVersion.getVersionID() == null) {
            final String errorMessage = messageSource.getMessage("clone-version.messages.error.failed-to-save-data",
                    null, LocaleContextHolder.getLocale());
            throw new VersionCloningException(errorMessage);
        }

        savedVersionId = savedGaudiAiVersion.getCloneVersionID();
        savedVersionPath = savedGaudiAiVersion.getVersionPath();
        existingVersionPath = existingGaudiAiVersion.getVersionPath();

        final String smartId = updateSmartId(PREFIX, savedGaudiAiVersion.getProjectID(), savedGaudiAiVersion.getVersionID());
        savedGaudiAiVersion.setSmartID(smartId);
        gaudiAIVersionRepository.save(savedGaudiAiVersion);
    }

    private void cloneGenerateData() {
        final GaudiAIBlendingGenerate generateData = gaudiAIBlendingGenerateRepository
                .findTop1ByGaudiVersionIDOrderByBlendingGenerateIDDesc(existingVersionId);

        if (generateData == null) {
            return;
        }

        final GaudiAIBlendingGenerate generateDataToSave = GaudiAIBlendingGenerate.builder()
                .gaudiVersionID(savedVersionId)
                .saveDefectMask(generateData.getSaveDefectMask())
                .defectXScale(generateData.getDefectXScale())
                .defectYScale(generateData.getDefectYScale())
                .imageCount(generateData.getImageCount())
                .algorithm(generateData.getAlgorithm())
                .iteration(generateData.getIteration())
                .gradWeight(generateData.getGradWeight())
                .styleWeight(generateData.getStyleWeight())
                .seed(generateData.getSeed())
                .isActive("Y")
                .createdBy(generateData.getCreatedBy())
                .createdDate(new Date())
                .rotation(generateData.getRotation())
                .degreeOfRotationMin(generateData.getDegreeOfRotationMin())
                .degreeOfRotationMax(generateData.getDegreeOfRotationMax())
                .defectRandomScale(generateData.getDefectRandomScale())
                .build();

        gaudiAIBlendingGenerateRepository.save(generateDataToSave);
    }

    private void cloneFileData() throws IOException {
        emptyFolder(savedVersionPath);
        copyData(existingVersionPath, savedVersionPath);

        final String resultPath = String.join(File.separator, savedVersionPath, ApplicationConstants.IMAGE, ApplicationConstants.RESULT);
        final String resultMaskPath = String.join(File.separator, savedVersionPath, ApplicationConstants.IMAGE, ApplicationConstants.RESULT_MASK);
        emptyFolder(resultPath);
        emptyFolder(resultMaskPath);
    }

    private void emptyFolder(final String path) throws IOException {
        final File folder = new File(path);
        if (folder.exists() && folder.isDirectory()) {
            FileUtils.cleanDirectory(folder);
        }
    }
}
------------------------------------------------------------------------------------------------------
CloneVersionStrategy.java
-------------------------

package com.gaudi.ai.strategies.cloneversion;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.gaudi.ai.constants.ApplicationConstants;
import com.gaudi.ai.exception.VersionCloningException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;

import java.io.File;
import java.io.IOException;
import java.util.SortedSet;

public abstract class CloneVersionStrategy {
    private static final String VERSION_PREFIX = "V";
    private static final String DOT = ".";

    @Autowired
    protected ObjectMapper mapper;
    @Autowired
    protected MessageSource messageSource;

    public abstract void cloneVersion(Long versionId) throws Exception;

    protected String getIncrementedVersionName(final String version) throws Exception {
        final String errorMessage = messageSource.getMessage("clone-version.messages.error.invalid-version",
                null, LocaleContextHolder.getLocale());

        if (! validVersion(version)) {
            throw new VersionCloningException(errorMessage);
        }

        final String numericPartOfVersion = version.substring(VERSION_PREFIX.length());
        if (! NumberUtils.isParsable(numericPartOfVersion)) {
            throw new VersionCloningException(errorMessage);
        }

        final int majorVersion = Integer.parseInt(numericPartOfVersion.substring(0, numericPartOfVersion.indexOf(DOT)));
        final int minorVersion = Integer.parseInt(numericPartOfVersion
                .substring(numericPartOfVersion.indexOf(DOT) + 1)) + 1;

        return VERSION_PREFIX + (majorVersion + minorVersion / 10) + DOT + (minorVersion % 10);
    }

    protected boolean validVersion(final String version) {
        if (StringUtils.isBlank(version)) {
            return false;
        }

        return version.startsWith(VERSION_PREFIX);
    }

    protected String updateVersionPath(final String versionPath, final String version) throws Exception {
        if (StringUtils.isBlank(versionPath)) {
            final String errorMessage = messageSource.getMessage("clone-version.messages.error.invalid-version-path",
                    null, LocaleContextHolder.getLocale());
            throw new VersionCloningException(errorMessage);
        }

        final String parentVersionPath = new File(versionPath).getParent();
        return parentVersionPath + File.separator + version;
    }

    protected String updateActiveSteps(final String activeSteps,
                                       final Integer resultStep
    ) throws JsonProcessingException {
        if (StringUtils.isBlank(activeSteps)) {
            return activeSteps;
        }
        final SortedSet<Integer> setOfActiveSteps = mapper.readValue(activeSteps, new TypeReference<SortedSet<Integer>>() {});
        setOfActiveSteps.remove(resultStep);
        return mapper.writeValueAsString(setOfActiveSteps);
    }

    protected String updateSmartId(final String prefix, final Long projectId, final Long versionId) {
        return String.join(ApplicationConstants.UNDERSCORE, prefix, projectId.toString(), versionId.toString());
    }

    protected void copyData(final String oldPath, final String newPath) throws IOException {
        final File oldFolder = new File(oldPath);
        final File newFolder = new File(newPath);

        FileUtils.copyDirectory(oldFolder, newFolder);
    }
}
---------------------------------------------------------------------------------------------------
ApplicationUtil:
----------------
package com.gaudi.ai.util;

import java.io.File;
import java.util.List;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.gaudi.ai.constants.ApplicationConstants;


@Component
public class ApplicationUtil {

	private static final Logger LOG = LogManager.getLogger(ApplicationUtil.class);
	@Autowired
	HttpServletRequest request;
	/* It will create folder to particular location */
	public boolean createFolder(String folderPath) {
		try {
			createDirectory(folderPath);
			return true;
		} catch (Exception e) {
			LOG.error("Error in creating folder and saving base models..... e:");
			return false;

		}
	}

	public void createDirectory(String directoryPath) {
		File dir1 = new File(directoryPath);
		if (dir1.exists())
			LOG.info("Directory existsss");
		else
			dir1.mkdirs();
	}
	/* It will create 4 folder to particular location */
	public boolean createSubFolder(String folderPath, String projectModule, Long noOfChannel) {
		try {
			createDirectory(folderPath);
			String imageSubFolder = folderPath + File.separatorChar +ApplicationConstants.IMAGE;
			String docSubFolder = folderPath + File.separatorChar + ApplicationConstants.DOC;
			createDirectory(imageSubFolder);
			createDirectory(docSubFolder);
			createDirectory(docSubFolder + File.separatorChar + ApplicationConstants.JSON);
			createDirectory(docSubFolder + File.separatorChar + ApplicationConstants.LOG);
			if (projectModule.equalsIgnoreCase(ApplicationConstants.BLENDING)) {
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.SOURCE);
				createChannelFolder(imageSubFolder + File.separatorChar + ApplicationConstants.SOURCE, noOfChannel);
				createDirectory(imageSubFolder + File.separatorChar +  ApplicationConstants.SOURCE_MASK);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.TARGET);
				createChannelFolder(imageSubFolder + File.separatorChar + ApplicationConstants.TARGET, noOfChannel);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.TARGET_MASK);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.RESULT);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.RESULT_MASK);
			}else if(projectModule.equalsIgnoreCase(ApplicationConstants.GAN)) {
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.RESULT);
			}else if(projectModule.equals(ApplicationConstants.IMAGE_PROCESSING)) {
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.LOAD_IMAGE);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.DEFECT_PATTERN);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.OK_IMAGE);
				createDirectory(imageSubFolder + File.separatorChar + ApplicationConstants.RESULT);
			}
			return true;
		} catch (Exception e) {
			LOG.error("Error in creating folder and saving base models..... e:");
			return false;
		}
	}
	public boolean createChannelFolder(String folderPath,Long noOfChannel) {
		try {
			for (int i = 0; i < noOfChannel; i++) {
				createDirectory(folderPath+File.separatorChar + ApplicationConstants.CHANNEL+(i+1));
			}
			
			return true;
		} catch (Exception e) {
			LOG.error("Error in creating folder and saving base models..... e:");
			return false;

		}
	}
	public List<Locale.LanguageRange> getHeader() {
		String headerLang = request.getHeader(ApplicationConstants.ACCEPT_LANGUAGE);
		List<Locale.LanguageRange> language=Locale.LanguageRange.parse(headerLang);
		return language;
	}
}
-----------------------------------------------------------------------------------------------

ErrorMessage.properties
----------------------
api.error.user.not.found=Requested User Not Found In Registry. Please check and retry
api.error.user.already.registered=Username already registered. Please use different username and retry
hello=Hello World!
welcome=Welcome to this guide!
nas.configuration.creation.failure=NAS Configuration Creation Failure.
exception.nas.configuration=Exception - NAS Configuration.
do.not.find.list.of.nas.for.userid=Do Not Find List Of NAS for UserID - 
error.in.get.list.of.configured.nas=Error In Get List Of Configured NAS.
do.not.find.the.nas.configure.for.userid=Do Not Find The NAS Configure For UserID -
error.in.updating.list.of.configured.nas=Error In Updating List Of Configured NAS.
error.in.deletation.the.configured.nasid=Error In Deletion The Configured NAS - NAS ID 
source.data.saved.failure=Source Data Saved Failure.
error.in.save.source=Error In Save Source
mask.data.saved.failure=Mask Data Saved Failure
error.in.save.mask=Error In Save Mask
target.data.saved.failure=Target Data Saved Failure
error.in.save.target=Error In Save Target
target.mask.data.saved.failure=Target Mask Data Saved Failure
error.in.save.target.mask=Error In Save Target Mask
error.in.save.generated.json=Error In Save Generated Json
process.is.not.found.for.smartid=Process Is Not Found For smartID -
error.in.get.log.process.Status.for.smartid=Error In Get Log Process Status For smartID -
web.client.exception.in.the.terminating.blending.for.smartid=Web Client Exception In The Terminating Blending For smartID - 
error.in.the.terminating.blending.for.smartid=Error In The Terminating Blending For smartID -
no.source.data.available.for.sourceid=No Source Data Available For SourceID -
error-get.source.data=Error - Get Source Data
no.mask.data.available.for.maskid=No Mask Data Available For MaskID -
error-get.mask.data=Error  - Get Mask Data
no.target.data.available.for.targetid=No Target Data Available For TargetID - 
error-get.target.data=Error  - Get Target Data
no.target.mask.data.available.for.targetMaskid=No Target Mask Data Available For TargetMaskID - 
error-get.targetMask.data=Error - Get TargetMask Data
no.generated.data.available.for.generateid=No Generated Data Available For GenerateID -
error-get.generate.data=Error  - Get Generate Data
could.not.store.the.file.error=Error : Could not store the file
could.not.read.the.file=Could not read the file!
error=Error: 
gaudi.ai.version.is.empty=gaudi AI Version is empty
could.not.load.the.files=Could not load the files!
duplicate.project.name.entered.please.enter.different.project.name=Duplicate Project Name Entered. Please Enter Different Project Name.
project.and.version.donot.created.successfully=Project and version donot created successfully
error.in.project.and.version.creatation=Error In Project and version creatation.
no.first.project.created.for.userID=No First Project Created For userID - 
no.project.details.found=No Project Details Found
error.in.get.list.Of.project=Error In Get List Of Project.
no.first.version.created.for.projectID=No First Version Created For ProjectID -
no.Version.details.found=No Version Details Found
error.in.get.list.Of.version=Error In Get List Of Version.
do.not.find.project.for.projectID=Do Not Find Project For projectID -
project.and.version.creation.failure=Project And Version Creation Failure.
error.in.new.version.creation=Error In New Version Creation.
server.error.exception=server.error.exception
versionId.not.found=versionId not found
error.in.updating.the.mask.data=Error In Updating The Mask Data
error.in.updating.the.target.data=Error In Updating The Target Data
error.in.updating.the.targetmask.data=Error.In.Updating.The.TargetMask.Data
error.in.updating.the.generate.data=Error.In.Updating.The.Generate.Data
project.not.found.by.given.projectID=Project not found by given ProjectID
do.not.find.the.source.data.for.versionid=Do Not Find The Source Data For VersionID
do.not.find.the.source.data.for.blendingSourceid=Do Not Find The Source Data For blendingSourceID
do.not.find.the.generate.data.for.versionid=Do Not Find The Generate Data For VersionID
do.not.find.the.generate.data.for.blendingGenerateid=Do Not Find The Generate Data For blendingGenerateID
do.not.find.the.mask.data.for.versionid=Do Not Find The Mask Data For VersionID
do.not.find.the.mask.data.for.blendingMaskid=Do Not Find The Mask Data For blendingMaskID
do.not.find.the.target.data.for.versionid=Do Not Find The Target Data For VersionID
do.not.find.the.target.data.for.blendingtargetid=Do Not Find The Target Data For blendingTargetID
do.not.find.the.targetmask.data.for.versionid=Do Not Find The TargetMask Data For VersionID
do.not.find.the.targetmask.data.for.blendingtargetmaskid=Do Not Find The TargetMask Data For blendingTargetMaskID
error.in.resume.process.for.trainingId=Error In Resume Process For trainingId - 
server.is.down.please.try.after.sometimes=Server is down. Please try after sometimes.
error.in.pause.for.smartid=Error In pause For smartID - 
webclient.exception.in.pause.the.process.for.smartid=Web Client Exception In pause the process For smartID - 
error.in.process.gan.result=Error In Process GAN Result.
error.in.process.default.gan.result=Error In Process Default GAN Result.
error.in.selected.dataset.for.version=Error In Selected Dataset For Version.
does.no.exist.entity=Does No Exist Entity.
error.in.discard.the.gan.image=Error In Discard The GAN Image
error.in.get.particular.gan.dataset=Error In Get Particular GAN DataSet.
error.gan.dataset.found=No GAN DataSet Found.
exception.gan.channel.deletion.failure=Exception - GAN Channel Deletion Failure.
list.of.selected.image.empty=List Of Selected Image Is Empty.
select.lable.class.does.not.find=Select Label Class Does Not Find.
error.in.get.list.of.gan.dataset=Error In Get List Of GAN Dataset.
no.list.of.gan.dataset.found=No List Of GAN Dataset Found
exception.gan.channel.deletion.failure=Exception - GAN Channel Deletion Failure.
no.of.channel.should.be.less.than.or.equal.to.10=No of Channel should be less than or equal to 10.
exception.gan.channel.creation.failure=Exception - GAN Channel Creatation Failure.
exception.gan.dataset.creation.failure=Exception - GAN Dataset Creatation Failure.
gan.dataset.creation.failure=GAN Dataset Creatation Failure.
error.in.get.gan.particular.version=Error In Get GAN Particular Version.
no.gan.version.data.found=No GAN Version Data Found
connection.error.please.try.after.sometimes=Connection Error. Please try after sometimes.
error.in.classname.details=Error In Get ClassName Details.
datasetid.cannot.be.null=dataSetId cannot be null.
error.in.get.image.details=Error In Get Image Details.
no.image.details.found=No Image Details Found
error.in.updating.the.training.data=Error In Updating The Training Data
do.not.find.the.training.data.for.ganTrainingid=Do Not Find The Training Data For ganTrainingID
unprocessble.content=Unprocessble Content
error.get.training.data=Error  - Get Training Data.
error.in.save.gan.training.json=Error In Save gan training Json.
data.height.and.width.must.be.same=Data height and Width must be Same.
exception.get.list.of.gan.channel.failure=Exception - Get List Of GAN Channel Failure.
no.gan.channel.found=No GAN Channel Found
exception.gan.class.update.failure= Exception - GAN Class Update Failure.
no.gan.class.found=No GAN Class Found
exception.gan.class.creation.failure=Exception - GAN Class Creation Failure.
exception.get.gan.class.failure=Exception - Get GAN Class Failure.
exception.no.gan.class.found=Exception No GAN Class Found
no.class.is.labelled.datasetid=No Class is Labelled.  DatasetID -
no.channel.listed.datasetid=No Channel Listed datasetID -
no.output.folder.created.under.result.datasetid=No Output Folder Created Under Result . datasetID - 
error.in.discard.the.image=Error In Discard The Image
could.not.read.the.file=Could not read the file!
could.not.store.the.file.error=Could not store the file. Error: 
duplicate.project.name.entered.please.enter.different.project.name.for=Duplicate Project Name Entered. Please Enter Different Project Name For 
error.in.project.and.version.creation=Error In Project and version creatation.
new.version.creation.failure=New Version Creation Failure.
error.in.delete.the.project=Error in Delete the project
project.not.found=Project not found
error.in.edit.project=Error In Edit project
error.get.test.data=Error Get Test Data
do.not.find.the.test.data.for.testid=Do Not Find The Test Data For testID
error.in.save.gan.test.json=Error In Save Gan Test Json
version.not.found=Version not found
error.in.version.lock=Error In Version Lock
no.gan.tarining.wizard.under.versionid=No Gan Training Wizard Under VersionID - 
error.delete.output.folder=Error  - Delete Output Folder
output.folder.is.not.available.to.delete=OutputFolder Is Not Available To Delete
error.get.image.dimension=Error  - Get Image Dimension
no.image.available.for.datasetid=No Image Available For datasetID
error.in.deselected.dataset.for.version=Error In De-Selected Dataset For Version
does.no.exist.entity=does.no.exist.entity
error.in.list.of.gan.result.folder=Error In List Of GAN Result Folder
no.ouput.folder.created.under.result.versionid=No Output Folder Created Under Result. versionID -
error.in.delete.gan.class=Error in delete gan class
does.no.exist.class.entity=does no exist class entity
image.are.not.available.for.the.selected.folder=Images Are Not Available For The Selected Folder
not.correct.module.tab.name.given=Not Correct Module Tab Name Given - 
duplicate.class.name.entered.please.enter.different.class.name=Duplicate Class Name Entered. Please Enter Different Class Name
please.load.dataset.and.then.create.class=Please load dataset and then create class
duplicate.dataset.name.entered.please.enter.different.dataset.name=Duplicate Dataset Name Entered. Please Enter Different Dataset Name
version.id.is.null=Version ID Is Null.
error.in.save.gan.trainWizard.setting=Error In Save Gan Training Wizard Setting 
do.not.find.the.training.setting.data.for.settingID=DO Not Find The Training Setting Data For SettingID 
error.get.training.setting.data=Error Get Training Setting Data 
error.in.updating.the.training.setting.data=Error In Updating The Training Setting Data 
gan.training.setting.is.not.available.to.delete=Gan Training Setting Is Not Available To Delete 
error.delete.gan.training.setting=Error Delete Gan Training Setting
duplicate.setting.name.entered.please.enter.different.setting.name=Duplicate Setting Name Entered. Please Enter Different Setting Name
error.in.submitting.job.gpu.memory.full.please.try.after.sometime=error in submitting Job\GPU memory full, please try after sometime
fail.to.upload.files=Fail to upload files
import.model.failure=Import Model Failure
folder.name.is.null=Folder Name Is Null
do.not.find.data.for.settingid.datasetid=Do Not Find  Data For SettingID Or DatasetID - 
error.get.ip.generate.data=Error - Get IP Generate Data
no.ip.version.data.found=No IP Version Data Found
error.in.get.ip.particular.version=Error In Get IP Particular Version
exception.get.list.Of.gan.class.from.json=Exception - Get List Of GAN class From Json
exception.get.list.Of.gan.channel.from.json=Exception - Get List Of GAN Channel From Json
version.does.not.exist=Version Does Not Exist
error.in.delete.blending.image=Error In Delete Blending Image
request.is.empty=Request Is Empty
tabname.is.empty.please.add.tabname.in.request=TabName Is Empty. Please Add TabName In Request
defect.y.scale.value.must.be.between.0.1f.and.2.0f=DefectYScale value must be between 0.1f and 2.0f
defect.x.scale.value.must.be.between.0.1f.and.2.0f=DefectXScale value must be between 0.1f and 2.0f
no.of.channel.for.blending.is.mandatory=No of Channel for Blending Is Mandatory.
exception.get.list.Of.channels=Exception - Get List Of Channels
error.in.check.the.blending.image.count.basis=Error In Check The Blending Image Count Basis
clone-version.messages.error.invalid-version=Invalid Version
clone-version.messages.error.invalid-version-path=Invalid Version Path
clone-version.messages.error.version-not-found=Version to Clone not Found
clone-version.messages.error.failed-to-save-data=Failed to Save Version Data to Database
clone-version.messages.error.invalid-module=Invalid Module Name
version.not.found.by.given.versionID=Version Not Found By Given VersionID
error.in.adding.the.note=Error in Adding the Note
version.note.should.be.less.than.1000.characters=Version Note Should Be Less Than 1000 Characters
tabName.is.empty=TabName Is Empty
please.upload.atleast.one.image=Please Upload At Least One Image in Mask Tab
image.count.mismatch.across.channels.in.source.tab=Image Count Mismatch Across Channels in Source Tab
image.count.mismatch.across.channels.in.target.tab=Image Count Mismatch Across Channels in Target Tab
exception.get.list.Of.gan.default.models=Exception - Get List Of Gan Default Models
exception.get.list.Of.gan.default.model.classname.and.channelname=Exception - Get List Of Gan Default Model className And channelName
invalid.input.only.gan,blending,image-processing.allowed=Invalid Input Only GAN,Blending,image-processing Allowed
error.response.from.python=Error Response From Python
please.upload.atleast.one.image.in.source.tab=Please Upload At Least One Image In Source Tab
please.upload.atleast.one.image.in.target.tab=Please Upload At Least One Image In Target Tab
channels.are.not.available.for.the.selected.folder=Channels Are Not Available For The Selected Folder
please.link.the.version.with.dataset=Please Link The Version With Dataset

--------------------------------------------------------------------------------------------------------------
ResponseMessage.properties
--------------------------
api.response.user.creation.successful=User registered successfully inside the application.
api.response.user.update.successful=User update request successfully applied.
welcome.to.website=Welcome to Gaudi Admin.
gan.class.created.successfully=GAN Class created Successfully.
gan.class.updated.successfully=GAN Class Updated Successfully.
gan.dataset.created.successfully=GAN Dataset created Successfully.
created.the.channel.successfully=Created The Channel Successfully.
delete.the.channel.successfully=Channel deleted Successfully.
labelled.the.image.successfully=Labeled The Image Successfully.
selected.dataset.for.version.added.successfully=Selected Dataset For Version Added Successfully.
deleted.gan.class.successfully=Deleted GAN Class Successfully.
nas.configuration.created.successfully=NAS Configuration created successfully.
the.nas.configure.updated.successfully=The NAS Configure Updated Successfully.
the.nas.configure.deleted.successfully=The NAS Configure Deleted Successfully.
the.sourceData.updated.successfully=The SourceData Updated Successfully.
the.maskdata.updated.successfully=The MaskData Updated Successfully.
the.target.data.updated.successfully=The Target Data Updated Successfully.
the.targetmask.data.updated.successfully=The TargetMask Data Updated Successfully.
the.generate.data.updated.successfully=The Generate Data Updated Successfully.
source.data.saved.successfully= Source Data Saved Successfully.
mask.data.saved.successfully=Mask Data Saved Successfully.
targe.data.saved.successfully=Target Data Saved Successfully.
targetmask.data.saved.successfully=Target Mask Data Saved Successfully.
project.and.version.created.successfully=Project and version created successfully
deleted.gan.class.successfully=Deleted GAN Class Successfully.
project.and.version.created.successfully=Project and version created successfully
new.version.created.successfully=New Version Created Successfully.
delete.the.versions.successfully=Version deleted Successfully.
delete.the.project.successfully=Project deleted Successfully.
project.update.successfully=Project Updated  successfully
version.locked=Version Locked
result.images.deleted.successfully=Result Images Deleted Successfully
output.folder.deleted.successfully=Output Folder Deleted Successfully
deselect.dataset.for.version.successfully=De-Selected Dataset For Version Successfully
gan.training.setting.saved.successfully=Gan Training Setting Saved Successfully
gan.training.setting.Updated.successfully=Gan Training Setting Updated Successfully
gan.training.setting.deleted.successfully=Gan Training Setting Deleted Successfully
file.uploaded.successfully=Files uploaded successfully ,Duplicate's Excluded
blending.image.deleted.successfully=Blending Image Deleted Successfully
good.to.go.for.next.step=Good To Go For Next Step.
please.make.images.equal.in.all.channel=Please Make Images Equal In All Channel.
clone-version.messages.success.request-successful=Version Cloned Successfully.
version.note.updated.successfully=Version Note Updated Successfully

--------------------------------------------------------------------------------

application_dev.properties
---------------------------
#Port number to run the application
server.port = 8501

#db config details
spring.datasource.url=jdbc:mysql://107.99.139.56:3306/gaudi_dev?useSSL=false&useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=gaudi_user
spring.datasource.password=semco123
spring.datasource.platform=mysql
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect

spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

logging.level.org.springframework.web=INFO
logging.config=classpath:log4j2.properties

#dp.adminuser=http://107.108.32.82:8500/gaudi-user/getUserInfo?authToken=

gaudiServiceUrl=http://107.99.131.58:8000

## MULTIPART (MultipartProperties)
spring.servlet.multipart.max-file-size=500MB
spring.servlet.multipart.max-request-size=500MB

baseFolder.path=Z:/GAUDIPROJECT

------------------------------------------------------
application_prod.properties
----------------------------
#Port number to run the application
server.port = 8501

#db config details
spring.datasource.url=jdbc:mysql://16.3.14.97:3306/gaudi_prod?useSSL=false&useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=gaudi_prod_user
spring.datasource.password=semco123
spring.datasource.platform=mysql
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect

spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

logging.level.org.springframework.web=INFO
logging.config=classpath:log4j2.properties

gaudiServiceUrl=http://16.3.14.97:8000

## MULTIPART (MultipartProperties)
spring.servlet.multipart.max-file-size=500MB
spring.servlet.multipart.max-request-size=500MB

baseFolder.path=D:/GAUDI/storage/GAUDIPROJECT
-------------------------------------------------------
application_qc.properties
--------------------------
#Port number to run the application
server.port = 8501

#db config details
spring.datasource.url=jdbc:mysql://107.99.139.56:3320/gaudi_qc?useSSL=false&useUnicode=true&characterEncoding=UTF-8
spring.datasource.username=gaudi_qc_user
spring.datasource.password=semco123
spring.datasource.platform=mysql
spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL8Dialect

spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp

logging.level.org.springframework.web=INFO
logging.config=classpath:log4j2.properties

gaudiServiceUrl=http://107.99.131.122:9000



## MULTIPART (MultipartProperties)
spring.servlet.multipart.max-file-size=500MB
spring.servlet.multipart.max-request-size=500MB

#project folder path
baseFolder.path=Z:/GAUDIPROJECT

-----------------------------------------------------------------
log4j2.properties
------------------

status = erro
name = PropertiesConfig
#Make sure to change log file path as per your need
property.filename = Z:\\GAUDIAILogs\\GaudiAI-log.log
#property.filename = D:\\GAUDI\\GAUDIAILogs\\GaudiAI-log.log
 
filters = threshold
 
filter.threshold.type = ThresholdFilter
filter.threshold.level = debug
 
appenders = rolling
 
appender.rolling.type = RollingFile
appender.rolling.name = RollingFile
appender.rolling.fileName = ${filename}
appender.rolling.filePattern = Z:\\GAUDIAILogs\\Previous\\GaudiAI-log-backup-%d{MM-dd-yy-HH-mm-ss}-%i.log.gz
#appender.rolling.filePattern = D:\\GAUDI\\GAUDIAILogs\\Previous\\GaudiAI-log-backup-%d{MM-dd-yy-HH-mm-ss}-%i.log.gz
appender.rolling.layout.type = PatternLayout
appender.rolling.layout.pattern = %d{yyyy-MM-dd HH:mm:ss.SSS} %level [%t] [%l] - %msg%n
appender.rolling.policies.type = Policies
appender.rolling.policies.size.type = SizeBasedTriggeringPolicy
appender.rolling.policies.size.size=10MB
appender.rolling.strategy.type = DefaultRolloverStrategy
appender.rolling.strategy.max = 20
 
loggers = rolling
 
#Make sure to change the package structure as per your application
 
logger.rolling.name = com.gaudi.ai
logger.rolling.level = info
logger.rolling.additivity = true
logger.rolling.appenderRef.rolling.ref = RollingFile







